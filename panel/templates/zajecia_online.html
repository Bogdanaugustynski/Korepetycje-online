<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Zajęcia online — audio + tablica</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --primary:#007bff; --ok:#28a745; --muted:#ccc; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, Arial, sans-serif; background:#f4f4f4; }
    header { background: var(--primary); color:#fff; padding:10px 14px; display:flex; align-items:center; gap:14px; flex-wrap:wrap; }
    .title { font-weight:700; font-size:18px; flex: 1 1 auto; }
    .pill { background:#fff; color:#000; padding:8px 10px; border-radius:8px; border:1px solid #ddd;
      display:flex; align-items:center; gap:8px; font-weight:600; }
    .dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
    .dot.on { background:#39d158; } .dot.off { background:#b1b1b1; }
    main { padding:24px 16px; display:flex; flex-direction:column; align-items:center; gap:18px; }
    .btn { padding:14px 24px; font-size:18px; background:var(--ok); color:#fff; border:none; border-radius:10px; text-decoration:none; display:inline-block; cursor:pointer; }
    .hint { max-width:850px; background:#fff; border:1px dashed #cfd6e4; padding:12px 14px; border-radius:8px; color:#2a2f3a; }
  </style>
</head>
<body>

<header>
  <div class="title">Zajęcia online — tryb audio</div>

  <div class="pill">
    <span id="presence-dot" class="dot off"></span>
    <span id="presence-text">Niedostępny</span>
  </div>

  <div class="pill" id="presence-count">👥 0</div>

  <button class="pill" id="connect-btn" type="button">🔊 Połącz audio</button>

  <button class="pill" id="mic-toggle" type="button" disabled>
    <span id="mic-icon">🔇</span>
    <span id="mic-label">Wycisz mikrofon</span>
  </button>

  <div class="pill">⏱ <span id="countdown">Pozostało: --:--</span></div>
</header>

<main>
  <a class="btn" target="_blank" href="{{ rezerwacja.excalidraw_link|default:'#' }}">✏️ Otwórz tablicę</a>

  {% if is_teacher %}
  <form method="POST" style="display:flex; gap:8px; flex-wrap:wrap;">
    {% csrf_token %}
    <input type="url" name="excalidraw_link" placeholder="https://excalidraw.com/#room=..." required
           style="min-width:280px; width:420px; max-width:100%; padding:10px 12px; border-radius:8px; border:1px solid #cfd6e4;">
    <button type="submit" class="pill">💾 Zapisz link</button>
  </form>
  {% endif %}

  <div class="hint">
    ℹ️ Kliknij „Połącz audio” na obu urządzeniach, zezwól na mikrofon, a potem używaj „Wycisz mikrofon”.
  </div>
</main>

<script>
  // === KONFIG ===
  const rezerwacjaId = "{{ rezerwacja.id }}";
  const csrfToken = "{{ csrf_token }}";
  const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
  const wsUrl = `${wsScheme}://${window.location.host}/ws/audio/${rezerwacjaId}/`;

  // STUN publiczny – wystarczy do P2P (możesz dodać własny TURN, gdyby sieć blokowała)
  const RTC_CONFIG = { iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] };

  // === UI ===
  const connectBtn = document.getElementById("connect-btn");
  const micBtn = document.getElementById("mic-toggle");
  const micIcon = document.getElementById("mic-icon");
  const micLabel = document.getElementById("mic-label");

  function setMicLabel(muted) {
    micIcon.textContent = muted ? "🎙️" : "🔇";
    micLabel.textContent = muted ? "Włącz mikrofon" : "Wycisz mikrofon";
  }

  // === Presence (Twoje endpointy – zostawiamy jak było) ===
  function pingOnlineStatus() {
    fetch("{% url 'ping_online_status' %}", {
      method: "POST",
      headers: { "X-CSRFToken": csrfToken, "Content-Type": "application/x-www-form-urlencoded" },
      body: "rezerwacja_id=" + encodeURIComponent(rezerwacjaId)
    }).catch(()=>{});
  }
  function checkOtherUserStatus() {
    fetch(`/check-online-status/${rezerwacjaId}/`)
      .then(r => r.json())
      .then(data => {
        const on = !!data.online;
        document.getElementById('presence-dot').className = 'dot ' + (on ? 'on' : 'off');
        document.getElementById('presence-text').textContent = on ? 'Dostępny' : 'Niedostępny';
        const count = (typeof data.count === 'number') ? data.count : (on ? 2 : 1);
        document.getElementById('presence-count').textContent = '👥 ' + count;
      })
      .catch(()=>{});
  }

  // === Countdown ===
  (function initCountdown(){
    const el = document.getElementById('countdown');
    const start = new Date("{{ rezerwacja.termin|date:'Y-m-d H:i:s' }}").getTime();
    const end = start + 55 * 60 * 1000;
    const tick = () => {
      const diff = end - Date.now();
      if (diff <= 0) { el.textContent = "Zakończone"; return; }
      const m = Math.floor(diff/60000), s = Math.floor((diff%60000)/1000);
      el.textContent = `Pozostało: ${m}:${String(s).padStart(2,'0')}`;
    };
    tick(); setInterval(tick, 1000);
  })();

  // === WebRTC + WS sygnalizacja ===
  let pc = null;
  let ws = null;
  let localStream = null;
  let started = false;
  let polite = false;  // prosty tryb „polite peer” (kolejność łączenia nie zabije sesji)

  async function startAudio() {
    if (started) return;
    started = true;
    connectBtn.disabled = true;

    // 1) Media local
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    // 2) PeerConnection
    pc = new RTCPeerConnection(RTC_CONFIG);
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    // 3) Gdy przyjdą remote-tracki (audio z drugiej strony) – nic nie wstawiamy do DOM,
    //    bo audio-tag nie jest konieczny przy direct audio? -> jednak jest:
    pc.addEventListener("track", (e) => {
      let el = document.getElementById("remoteAudio");
      if (!el) {
        el = document.createElement("audio");
        el.id = "remoteAudio";
        el.autoplay = true;
        el.playsInline = true;
        document.body.appendChild(el);
      }
      el.srcObject = e.streams[0];
    });

    // 4) ICE – wysyłamy kandydatów do drugiej strony
    pc.onicecandidate = (e) => {
      if (e.candidate && ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ type: "candidate", candidate: e.candidate }));
      }
    };

    // 5) WebSocket do sygnalizacji
    ws = new WebSocket(wsUrl);
    ws.onopen = async () => {
      // heurystyka: pierwszy kto się połączy – nie składa oferty; drugi – składa
      polite = false; // możesz też przekazać z backendu rolę (nauczyciel/uczeń)
      // tu zrobimy inicjację po 300 ms – jeśli druga strona już jest, złożymy offer
      setTimeout(async () => {
        if (pc.signalingState === "stable") {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          ws.send(JSON.stringify({ type: "offer", sdp: offer.sdp }));
        }
      }, 300);
    };

    ws.onmessage = async (event) => {
      const data = JSON.parse(event.data || "{}");
      try {
        if (data.type === "offer") {
          await pc.setRemoteDescription({ type: "offer", sdp: data.sdp });
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ type: "answer", sdp: answer.sdp }));
        } else if (data.type === "answer") {
          await pc.setRemoteDescription({ type: "answer", sdp: data.sdp });
        } else if (data.type === "candidate") {
          await pc.addIceCandidate(data.candidate);
        }
      } catch (e) {
        console.error(e);
      }
    };

    ws.onclose = () => { /* opcjonalnie: retry */ };

    // aktywuj przycisk mikrofonu
    micBtn.disabled = false;
    setMicLabel(false);
  }

  function toggleMic() {
    if (!localStream) return;
    const track = localStream.getAudioTracks()[0];
    track.enabled = !track.enabled;
    setMicLabel(!track.enabled);
  }

  document.getElementById("connect-btn").addEventListener("click", startAudio);
  document.getElementById("mic-toggle").addEventListener("click", toggleMic);

  // presence ping
  pingOnlineStatus(); checkOtherUserStatus();
  setInterval(pingOnlineStatus, 10000);
  setInterval(checkOtherUserStatus, 10000);
</script>
</body>
</html>
