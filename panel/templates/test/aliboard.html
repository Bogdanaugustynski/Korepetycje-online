{% load static %}
<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aliboard 2.5 ‚Äî PolubiszTo.pl (test)</title>

<!-- PDF render -->
<link rel="preload" as="script" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js">
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<!-- PDF export (klient) -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>

<style>
  :root{
    --brand:#0b74ff; --ink:#0b1320; --muted:#5b6777; --line:#e6edff;
    --bg:#f7f9fe; --radius:16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{
    position:sticky; top:0; z-index:20; background:#fff; border-bottom:1px solid var(--line);
    display:flex; align-items:stretch; gap:12px; padding:10px 12px;
  }
  .left{ display:flex; flex-direction:column; gap:8px; min-width:260px; }
  .brand{display:flex;align-items:center;gap:10px}
  .brand .mark{width:40px;height:40px;border-radius:10px;display:grid;place-items:center;flex:0 0 auto;overflow:hidden}
  .brand .mark img{width:100%;height:100%;object-fit:contain}
  .state{font-size:12px;color:var(--muted)}
  .toolrow{
    display:flex;
    gap:8px;
    flex-wrap:nowrap;
    overflow:hidden !important;
    white-space:nowrap;
    align-items:center;
    padding-bottom:4px;
    position:relative;
  }
  .btn,.seg{border:1px solid var(--line);background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer;font-weight:700}
  .btn.primary{background:var(--brand);color:#fff;border-color:transparent}
  .btn.is-active{ outline:2px solid var(--brand); outline-offset:2px }
  .right{margin-left:auto; display:flex; align-items:flex-start;}
  .menu-wrap{position:relative}
  .menu-btn{display:inline-flex; align-items:center; gap:8px}
  .dropdown{
    position:absolute; right:0; top:calc(100% + 8px); min-width:240px;
    background:#fff; border:1px solid var(--line); border-radius:12px;
    box-shadow:0 12px 40px rgba(11,116,255,.12); padding:8px; display:none; z-index:30;
  }
  .dropdown.open{display:block}
  .drop-group{padding:6px 6px}
  .drop-title{font-size:12px; color:var(--muted); margin:4px 6px 6px}
  .drop-item{width:100%; text-align:left; background:#fff; border:1px solid var(--line);
    border-radius:10px; padding:8px 10px; cursor:pointer; margin:4px 0}
  .drop-row{display:flex; gap:6px; flex-wrap:wrap}
  .drop-item.primary{background:var(--brand);color:#fff;border-color:transparent}

  #toolsMoreBtn{
    display:none;
    align-items:center;
    justify-content:center;
    height:36px;
    padding:6px 10px;
    background:var(--brand);
    color:#fff;
    border:none;
    border-radius:10px;
    margin-left:8px;
  }

  #toolsMorePanel.dropdown{
    top:42px;
    right:0;
    left:auto;
    min-width:180px;
    z-index:50;
  }

  /* Obszar kartek */
  .wrap{
    height:calc(100% - 64px);
    overflow:auto;
    padding:16px;
    overscroll-behavior:contain;
    overflow-anchor:none;
    -webkit-overflow-scrolling:touch;
  }
  .pages{
    display:flex; flex-direction:column; align-items:center; gap:24px;
    overflow-anchor:none;
  }
  .page{
    position:relative; background:#fff; border:1px solid var(--line);
    border-radius:12px; box-shadow:0 8px 30px rgba(11,116,255,.10);
    width:min(1200px, 96vw); aspect-ratio: 1 / 1.4142; /* A4 portret */
    overflow:hidden;
  }
  .page canvas{ position:absolute; inset:0; width:100%; height:100%; }
  .page .grid, .page .overlay{ pointer-events:none; }
  .page .board{ touch-action:none; } /* blok gest√≥w przy rysowaniu */

  /* edytor tekstu inline */
  .text-editor{
    position:absolute; z-index:50; min-width:60px;
    border:1px solid var(--line); border-radius:8px; padding:6px 8px; background:#fff;
    font: 16px ui-sans-serif, system-ui, Arial; color: var(--ink);
    outline: none; box-shadow:0 6px 20px rgba(15,23,42,.15);
  }

  /* ramka cropa */
  .crop-rect{
    position:absolute; z-index:40; border:2px dashed #0b74ff; background:rgba(11,116,255,.06); pointer-events:none;
  }
  .crop-choice-backdrop{
    position:fixed; inset:0; background:rgba(15,23,42,.45); display:flex; align-items:center; justify-content:center;
    z-index:70; opacity:0; transition:opacity .15s ease;
  }
  .crop-choice-backdrop.open{ opacity:1; }
  .crop-choice-dialog{
    background:#fff; border-radius:16px; padding:20px 24px; max-width:90vw; box-shadow:0 18px 55px rgba(15,23,42,.25);
    display:flex; flex-direction:column; gap:16px; min-width:280px;
  }
  .crop-choice-dialog p{ margin:0; font-size:15px; color:#0b1320; }
  .crop-choice-actions{ display:flex; gap:12px; flex-wrap:wrap; }
  .crop-choice-actions button{
    flex:1 1 120px; border:none; border-radius:10px; font-weight:600; padding:10px 14px; cursor:pointer;
  }
  .crop-choice-actions button.primary{ background:var(--brand); color:#fff; }
  .crop-choice-actions button.secondary{ background:#eef3ff; color:#0b1320; }
  .crop-busy-toast{
    position:fixed; top:16px; left:50%; transform:translate(-50%, -10px);
    background:#0b1320; color:#fff; padding:8px 16px; border-radius:999px;
    font-size:14px; box-shadow:0 10px 30px rgba(11,19,32,.35);
    z-index:80; pointer-events:none; opacity:0; transition:opacity .2s ease, transform .2s ease;
  }
  .crop-busy-toast.show{ opacity:1; transform:translate(-50%,0); }
  .modal-backdrop{
    position:fixed; inset:0; background:rgba(2,15,46,.55); display:none;
    align-items:center; justify-content:center; z-index:90;
  }
  .modal-backdrop.open{ display:flex; }
  .modal{
    background:#fff; border-radius:18px; padding:24px; width:min(420px, 92vw);
    box-shadow:0 25px 80px rgba(2,15,46,.35); display:flex; flex-direction:column; gap:16px;
  }
  .modal h3{ margin:0; font-size:20px; }
  .modal p{ margin:0; color:var(--muted); }
  .modal label{ display:flex; flex-direction:column; gap:6px; font-weight:600; }
  .modal input[type="text"]{
    border:1px solid var(--line); border-radius:10px; padding:10px 12px; font-size:15px;
  }
  .modal-actions{ display:flex; justify-content:flex-end; gap:12px; flex-wrap:wrap; }
  .modal-actions .btn{
    border:none; border-radius:10px; padding:10px 16px; font-weight:600; cursor:pointer;
  }
  .modal-actions .btn.secondary{ background:#eef3ff; color:#0b1320; }
  .modal-actions .btn.primary{ background:var(--brand); color:#fff; }

  .footer{ position:fixed; right:12px; bottom:12px; display:flex; gap:8px; flex-wrap:wrap; z-index:25; }

  /* mobile tap UX */
  .toolrow .btn { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

  /* === PATCH(MOBILE): kompaktowe narzƒôdzia bez "pigu≈Çy" === */
.toolrow .btn,
.toolrow label.btn{
  border:0 !important;
  box-shadow:none !important;
  background:transparent !important;     /* brak bia≈Çych kapsli */
}

/* aktywny ‚Äì cienki ring zamiast wype≈Çnienia */
.toolrow .btn.is-active{
  background:transparent !important;
  color:var(--ink) !important;
  outline:2px solid var(--brand);
  outline-offset:2px;
  border-radius:10px;
}

/* hover/focus bez zwiƒôkszania "pola" */
.toolrow .btn:focus-visible{ outline:2px solid var(--brand); outline-offset:2px }

/* same kontrolki w labelach */
.toolrow .btn input[type="color"],
.toolrow .btn select{
  border:0 !important;
  background:transparent !important;
  box-shadow:none !important;
}

/* cia≈õniej tylko na telefonie */
@media (max-width: 900px){
  .toolrow{ gap:4px; }
  .toolrow .btn{ padding:6px 8px; }      /* by≈Ço 8‚Äì10px */
}


@media (max-width: 900px){
  .left{min-width:unset}
  .toolrow{gap:4px}
  .btn{padding:8px}
}

/* [CODEX:BEGIN TOOLROW_MOBILE_OVERFLOW_FIX] */
@media (max-width: 900px){
  /* wy≈ÇƒÖcz autoscroll paska, pozw√≥l JS wykryƒá przepe≈Çnienie */
  .toolrow{
    overflow: hidden !important;
    position: relative;
  }
  /* wymuszony przycisk menu obok paska */
  #toolsMoreBtn{
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    padding: 6px 10px;
    background: var(--brand);
    color: #fff;
    border-radius: 10px;
    border: none;
    position: absolute;
    right: -44px;
    top: 0;
    bottom: 0;
    margin: auto;
    height: 36px;
  }
  /* panel overflow ‚Äì pojawia siƒô obok */
  #toolsMorePanel.dropdown{
    top: 42px;
    left: auto;
    right: 0;
    min-width: 180px;
  }
}
/* [CODEX:END TOOLROW_MOBILE_OVERFLOW_FIX] */

/* Mini-paleta figur */
.figure-palette{
  position:absolute; z-index:26; background:#fff; border:1px solid var(--line);
  border-radius:12px; box-shadow:0 12px 40px rgba(11,116,255,.12); padding:8px; display:none;
}
.figure-palette.open{ display:block; }
.figure-palette .shape-btn{
  display:inline-flex; align-items:center; justify-content:center;
  width:44px; height:36px; margin:4px; border:1px solid var(--line);
  border-radius:10px; background:#fff; cursor:pointer; font-weight:700;
}
.figure-palette .shape-btn.is-active{
  outline:2px solid var(--brand); outline-offset:2px;
}
@media (max-width:900px){
  .figure-palette{ transform:translateY(6px); }
}
</style>
</head>
<body>
<header>
  <!-- LEWA: brand + narzƒôdzia -->
  <div class="left">
    <div class="brand">
      <div class="mark">
        <!-- Sama g≈Çowa loga -->
        <img src="{% static 'img/brand/logo_head.png' %}" alt="PolubiszTo.pl" />
      </div>
      <div>
        <div style="font-weight:800">Aliboard</div>
        <div class="state" id="state">Tryb: Kursor ‚Ä¢ 3px ‚Ä¢ #0b74ff</div>
      </div>
    </div>

    <div class="toolrow" id="tools">
      <button class="btn" type="button" data-tool="select" title="Kursor (V)">üñ±Ô∏è</button>
      <button class="btn" type="button" data-tool="pen"    title="O≈Ç√≥wek (P)">‚úèÔ∏è</button>
      <button class="btn" type="button" data-tool="line"   title="Linia (L)">Ôºè</button>
      <button class="btn" type="button" data-tool="eraser" title="Gumka (E)">ü©π</button>
      <button class="btn" type="button" data-tool="text"   title="Tekst (T)">T</button>
      <button class="btn" type="button" data-tool="crop"   title="Wycinanie (C)">‚úÇÔ∏è</button>
      <button class="btn" type="button" data-tool="figure" title="Figury (F)" data-overflow="1">‚¨õÔ∏é‚ñµ‚¨°</button>

      <label class="btn" title="Kolor pisaka">
        üé® <input type="color" id="color" value="#0b74ff" style="width:28px;height:28px;border:0;padding:0;background:#fff;border-radius:8px;margin-left:6px">
      </label>
      <label class="btn" title="Grubo≈õƒá linii">
        ‚ÜïÔ∏è
        <select id="size" style="border:1px solid var(--line);border-radius:8px;padding:6px 8px;background:#fff;margin-left:6px">
          <option value="1">1px</option>
          <option value="3" selected>3px</option>
          <option value="5">5px</option>
          <option value="8">8px</option>
        </select>
      </label>

      <!-- Ikony: obraz + pdf -->
      <label class="btn" title="Wstaw obraz">
        üñºÔ∏è <input id="imgInput" type="file" accept="image/*" style="display:none">
      </label>
      <label class="btn" title="Wstaw PDF">
        üìÑ <input id="pdfInput" type="file" accept="application/pdf" style="display:none">
      </label>

      <button class="btn" type="button" id="undo" title="Cofnij (Ctrl+Z)">‚Ü∂</button>
      <button class="btn" type="button" id="clear" title="Wyczy≈õƒá tƒô stronƒô">üóëÔ∏è</button>
    </div>
  </div>

  <!-- PRAWA: MENU -->
  <div class="right">
    <div class="menu-wrap">
      <button class="btn primary menu-btn" type="button" id="menuBtn" aria-expanded="false" aria-controls="dropdown">‚ò∞ Menu</button>
      <div class="dropdown" id="dropdown" role="menu" aria-labelledby="menuBtn">
        <div class="drop-group">
          <button class="drop-item primary" type="button" id="openBoardBtn">Otw√≥rz</button>
        </div>
        <div class="drop-group">
          <button class="drop-item primary" type="button" id="saveToggle">Zapisz</button>
          <div class="drop-row" id="saveRow" style="display:none">
            <button class="drop-item" type="button" id="savePng">üíæ PNG</button>
            <button class="drop-item" type="button" id="saveJpg">üñºÔ∏è JPG</button>
            <button class="drop-item" type="button" id="savePdf">üìÑ PDF</button>
          </div>
        </div>
        <div class="drop-group">
          <button class="drop-item" type="button" id="templatesToggle">Szablony</button>
          <button class="drop-item" type="button" id="gridToggle" style="display:none">Siatka</button>
          <div class="drop-row" id="templatesRow" style="display:none">
            <button class="drop-item" type="button" data-grid="0">Brak</button>
            <button class="drop-item" type="button" data-grid="16">Ma≈Ça</button>
            <button class="drop-item" type="button" data-grid="24">≈örednia</button>
            <button class="drop-item" type="button" data-grid="32">Du≈ºa</button>
            <button class="drop-item" type="button" data-grid="tech">Papier milimetrowy</button>
          </div>
        </div>
        <div class="drop-group">
          <div class="drop-title">Nowa tablica</div>
          <div class="drop-row">
            <button class="drop-item" type="button" id="addPage">‚ûï Dodaj kartkƒô A4</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="wrap" id="wrap">
  <div class="pages" id="pages"></div>
</div>

<div class="footer">
  <a href="{% url 'pokoj_testowy' %}" class="btn">‚Üê Powr√≥t do Pokoju Testowego</a>
  <span class="btn" id="roomInfo" title="Room ID z query string">room_id: -</span>
</div>

<div class="modal-backdrop" id="openBoardModal" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="openBoardTitle">
    <h3 id="openBoardTitle">Otw√≥rz nowƒÖ tablicƒô</h3>
    <p>Utw√≥rz pustƒÖ tablicƒô. Aktualne karty zostanƒÖ zamkniƒôte.</p>
    <label>
      Nazwa tablicy (opcjonalnie)
      <input type="text" id="openBoardName" placeholder="np. Matematyka - lekcja 3">
    </label>
    <div class="modal-actions">
      <button type="button" class="btn secondary" id="openBoardCancel">Anuluj</button>
      <button type="button" class="btn primary" id="openBoardCreate">Utw√≥rz</button>
    </div>
  </div>
</div>

<script>
(function(){
  /* === PATCH: wstrzykniƒôcie delikatnego CSS dla paska narzƒôdzi (bez kapsli) === */
  const __css = `
  .toolrow .btn, .toolrow label.btn{border:0 !important;background:transparent !important;box-shadow:none !important}
  .toolrow .btn.is-active{background:transparent !important;color:var(--ink) !important;outline:2px solid var(--brand);outline-offset:2px;border-radius:10px}
  .toolrow .btn:focus-visible{outline:2px solid var(--brand);outline-offset:2px}
  .toolrow .btn input[type="color"], .toolrow .btn select{border:0 !important;background:transparent !important;box-shadow:none !important}
  @media (max-width: 900px){ .toolrow{gap:4px} .toolrow .btn{padding:6px 8px} }`;
  const styleEl = document.createElement('style'); styleEl.textContent = __css; document.head.appendChild(styleEl);

  /* ---------- STAN GLOBALNY ---------- */
  const wrapEl  = document.getElementById('wrap');
  const pagesEl = document.getElementById('pages');
  const stateEl = document.getElementById('state');
  let figureBtn = document.querySelector('[data-tool="figure"]');
  let figurePalette = null;
  let selectionRotateEnabled = false;

  function ensureFigurePalette(){
    if(figurePalette) return;
    figurePalette = document.createElement('div');
    figurePalette.className = 'figure-palette';
    figurePalette.innerHTML = `
      <button class="shape-btn" data-shape="rect" title="Kwadrat / ProstokƒÖt">‚ñ≠</button>
      <button class="shape-btn" data-shape="tri_iso" title="Tr√≥jkƒÖt (r√≥wnoramienny)">‚ñµ</button>
      <button class="shape-btn" data-shape="tri_right" title="Tr√≥jkƒÖt prostokƒÖtny">‚ó∫</button>
      <button class="shape-btn" data-shape="hex" title="Sze≈õciokƒÖt">‚¨°</button>
      <button class="shape-btn" data-shape="circle" title="Ko≈Ço">‚óØ</button>
    `;
    document.body.appendChild(figurePalette);
    updateFigurePaletteSelection();
  }

  function positionFigurePalette(){
    const btn = document.querySelector('[data-tool="figure"]');
    if(btn) figureBtn = btn;
    if(!figureBtn || !figurePalette) return;
    const r = figureBtn.getBoundingClientRect();
    figurePalette.style.left = r.left + 'px';
    figurePalette.style.top  = (r.bottom + 8) + 'px';
  }

  function updateFigurePaletteSelection(){
    if(!figurePalette) return;
    figurePalette.querySelectorAll('.shape-btn').forEach(b=>{
      b.classList.toggle('is-active', b.getAttribute('data-shape')===currentShape);
    });
  }

  function toggleFigurePalette(forceOpen){
    const open = (typeof forceOpen==='boolean') ? forceOpen : !figurePalette?.classList.contains('open');
    if(open){
      ensureFigurePalette();
      positionFigurePalette();
      figurePalette.classList.add('open');
    }else if(figurePalette){
      figurePalette.classList.remove('open');
    }
  }

  const TOOLS = { SELECT:'select', PEN:'pen', LINE:'line', ERASER:'eraser', TEXT:'text', CROP:'crop', FIGURE:'figure' };
  let tool = TOOLS.SELECT, color = '#0b74ff', size = 3, gridSize = 0;
  let currentShape = 'rect';

  // room_id info
  const qs = new URLSearchParams(location.search);
  const roomId = qs.get('room') || 'local-test';
  const roomInfoEl = document.getElementById('roomInfo');
  if(roomInfoEl) roomInfoEl.textContent = 'room_id: ' + roomId;

  /* ---------- MODEL STRONY ---------- */
  function makeEmptyPageState(){
    return { strokes: [], images: [], history: [], redo: [], selection: null, dragging: null };
  }
  const PAGES = [];
  function currentPage(){ return PAGES[PAGES.length-1] || null; }

  /* ---------- TWORZENIE STRONY ---------- */
  function createPage(scrollTo=true){
    const page = document.createElement('div');
    page.className = 'page';

    const gridC = document.createElement('canvas'); gridC.className='grid';
    const drawC = document.createElement('canvas'); drawC.className='board';
    const ovlC  = document.createElement('canvas'); ovlC.className='overlay';

    page.appendChild(gridC); page.appendChild(drawC); page.appendChild(ovlC);
    pagesEl.appendChild(page);

    const g   = gridC.getContext('2d');
    const ctx = drawC.getContext('2d');
    const ovl = ovlC.getContext('2d');

    const p = { el:page, gridC, drawC, ovlC, g, ctx, ovl, state: makeEmptyPageState() };
    PAGES.push(p);
    resizePage(p);
    refreshGrid(p);
    renderAll(p);
    bindPage(p);
    if(scrollTo) page.scrollIntoView({behavior:'smooth', block:'center'});
    return p;
  }

  /* ---------- ROZMIAR I SIATKA ---------- */
  function resizePage(p){
    const rect = p.el.getBoundingClientRect();
    const dpr  = window.devicePixelRatio || 1;
    [p.gridC, p.drawC, p.ovlC].forEach(c=>{
      c.width  = Math.floor(rect.width * dpr);
      c.height = Math.floor(rect.height * dpr);
      c.style.width  = rect.width + 'px';
      c.style.height = rect.height + 'px';
      const c2d = c.getContext('2d');
      c2d.setTransform(dpr,0,0,dpr,0,0);
    });
  }
  function drawGrid(p){
    const dpr = window.devicePixelRatio || 1;
    const w = p.gridC.width / dpr, h = p.gridC.height / dpr;
    p.g.clearRect(0,0,w,h);
    if(!gridSize) return;
    p.g.save(); p.g.strokeStyle='#e6edff'; p.g.lineWidth=1;
    for(let x=0;x<=w;x+=gridSize){ p.g.beginPath(); p.g.moveTo(x,0); p.g.lineTo(x,h); p.g.stroke(); }
    for(let y=0;y<=h;y+=gridSize){ p.g.beginPath(); p.g.moveTo(0,y); p.g.lineTo(w,y); p.g.stroke(); }
    p.g.restore();
  }
  function drawTechGrid(p){
    const dpr = window.devicePixelRatio || 1;
    const w = p.gridC.width / dpr, h = p.gridC.height / dpr;
    drawTechPattern(p.g, w, h);
  }
  function drawTechPattern(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    ctx.save();
    const thin = '#e0e6f0';
    const mid  = '#b5c0d4';
    const bold = '#7f8ba1';
    const step = 8;
    ctx.strokeStyle = thin;
    ctx.lineWidth = 0.5;
    for (let x = 0; x <= w; x += step/2){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y <= h; y += step/2){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
    ctx.strokeStyle = mid;
    ctx.lineWidth = 1;
    for (let x = 0; x <= w; x += step*5){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y <= h; y += step*5){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
    ctx.strokeStyle = bold;
    ctx.lineWidth = 1.2;
    for (let x = 0; x <= w; x += step*10){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y <= h; y += step*10){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
    ctx.restore();
  }
  function refreshGrid(p){
    if(gridSize==='tech'){ drawTechGrid(p); }
    else{ drawGrid(p); }
  }
  function resetBoard(){
    PAGES.forEach(p=> p.el.remove());
    PAGES.length = 0;
    pagesEl.innerHTML = '';
  }
  window.addEventListener('resize', ()=>{ PAGES.forEach(p=>{ resizePage(p); refreshGrid(p); renderAll(p); drawSelection(p); }); });

  /* ---------- RENDER ---------- */
  function renderAll(p){
    const dpr = window.devicePixelRatio || 1;
    const w = p.drawC.width / dpr, h = p.drawC.height / dpr;
    p.ctx.clearRect(0,0,w,h);

    for(const im of p.state.images){ if(im.img) p.ctx.drawImage(im.img, im.x, im.y, im.w, im.h); }

    p.ctx.lineCap='round'; p.ctx.lineJoin='round';
    for(const s of p.state.strokes){
      if(s.type==='pen'){
        p.ctx.strokeStyle=s.color; p.ctx.lineWidth=s.size;
        const pts=s.points; if(!pts.length) continue;
        p.ctx.beginPath(); p.ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){ p.ctx.lineTo(pts[i].x, pts[i].y); }
        p.ctx.stroke();
      }else if(s.type==='line'){
        p.ctx.strokeStyle=s.color; p.ctx.lineWidth=s.size;
        p.ctx.beginPath(); p.ctx.moveTo(s.a.x,s.a.y); p.ctx.lineTo(s.b.x,s.b.y); p.ctx.stroke();
      }else if(s.type==='text'){
        p.ctx.save(); p.ctx.fillStyle=s.color;
        p.ctx.font = `${Math.max(14, s.size*6)}px ui-sans-serif, system-ui, Arial`;
        p.ctx.textBaseline='top'; p.ctx.fillText(s.text, s.x, s.y); p.ctx.restore();
      }else if(s.type==='poly'){
        p.ctx.save();
        p.ctx.strokeStyle = s.color;
        p.ctx.lineWidth   = s.size;
        p.ctx.lineCap = 'round';
        p.ctx.lineJoin = 'round';
        if(s.points && s.points.length){
          p.ctx.beginPath();
          p.ctx.moveTo(s.points[0].x, s.points[0].y);
          for(let i=1;i<s.points.length;i++){
            p.ctx.lineTo(s.points[i].x, s.points[i].y);
          }
          if(s.closed){ p.ctx.closePath(); }
          p.ctx.stroke();
        }
        p.ctx.restore();
      }
    }
  }

  /* ---------- OBRAZY ---------- */
  function reviveImage(im, p){
    const obj = {x:im.x,y:im.y,w:im.w,h:im.h,src:im.src,meta:im.meta, img:null};
    const el = new Image();
    el.onload = ()=>{ obj.img = el; renderAll(p); };
    el.src = im.src;
    return obj;
  }
  function addImageFromSrc(src, w, h, x, y, meta, p){
    pushHistory(p);
    const im = reviveImage({src,w,h,x,y,meta}, p);
    p.state.images.push(im);
    renderAll(p);
  }

  /* ---------- HISTORIA ---------- */
  function snapshotState(p){
    return JSON.stringify({
      strokes: p.state.strokes,
      images: p.state.images.map(im=>({x:im.x,y:im.y,w:im.w,h:im.h,src:im.src,meta:im.meta}))
    });
  }
  function pushHistory(p){ p.state.redo=[]; try{ p.state.history.push(snapshotState(p)); if(p.state.history.length>100) p.state.history.shift(); }catch(_){} }
  function restoreHistoryState(p, json){
    try{
      const s = JSON.parse(json);
      p.state.strokes = s.strokes||[];
      p.state.images  = (s.images||[]).map(im=>reviveImage(im, p));
      renderAll(p); drawSelection(p);
    }catch(_){}
  }

  /* ---------- SELEKCJA I TRANSFORMACJE ---------- */
  const HANDLE_SIZE=10;
  function clearOverlay(p){ p.ovl.clearRect(0,0, p.ovlC.width, p.ovlC.height); }
  function drawPolyPreview(p, pts){
    clearOverlay(p);
    if(p.state.selection) drawSelection(p);
    if(!pts || pts.length<2) return;
    p.ovl.save();
    p.ovl.strokeStyle = color;
    p.ovl.lineWidth = Math.max(1, size);
    p.ovl.setLineDash([6,4]);
    p.ovl.beginPath();
    p.ovl.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++){ p.ovl.lineTo(pts[i].x, pts[i].y); }
    p.ovl.closePath();
    p.ovl.stroke();
    p.ovl.restore();
  }
  function bboxStroke(s){
    if(s.type==='pen'){
      const xs=s.points.map(p=>p.x), ys=s.points.map(p=>p.y);
      const minx=Math.min(...xs), maxx=Math.max(...xs), miny=Math.min(...ys), maxy=Math.max(...ys);
      return {x:minx,y:miny,w:maxx-minx,h:maxy-miny};
    }else if(s.type==='line'){
      const minx=Math.min(s.a.x,s.b.x), maxx=Math.max(s.a.x,s.b.x);
      const miny=Math.min(s.a.y,s.b.y), maxy=Math.max(s.a.y,s.b.y);
      return {x:minx,y:miny,w:maxx-minx,h:maxy-miny};
    }else if(s.type==='text'){
      const w = (Math.max(14, s.size*6)*0.6)*(s.text?.length||0);
      const h = Math.max(14, s.size*6);
      return {x:s.x, y:s.y, w, h};
    }else if(s.type==='poly'){
      if(!s.points || !s.points.length) return {x:0,y:0,w:0,h:0};
      const xs = s.points.map(pt=>pt.x);
      const ys = s.points.map(pt=>pt.y);
      const minx = Math.min(...xs), maxx = Math.max(...xs);
      const miny = Math.min(...ys), maxy = Math.max(...ys);
      return {x:minx, y:miny, w:maxx-minx, h:maxy-miny};
    }
    return {x:0,y:0,w:0,h:0};
  }
  function drawSelection(p){
    clearOverlay(p);
    const sel = p.state.selection;
    selectionRotateEnabled = false;
    if(!sel) return;
    const b = sel.bbox;
    const canRotate = sel.kind==='stroke' && p.state.strokes[sel.index]?.type==='poly';
    selectionRotateEnabled = canRotate;
    p.ovl.save();
    p.ovl.strokeStyle = '#0b74ff'; p.ovl.lineWidth = 1.5;
    p.ovl.setLineDash([6,4]); p.ovl.strokeRect(b.x, b.y, b.w, b.h); p.ovl.setLineDash([]);
    const hs = HANDLE_SIZE, pts = handlePoints(b);
    p.ovl.fillStyle='#fff'; p.ovl.strokeStyle='#0b74ff'; p.ovl.lineWidth=2;
    for(const h of pts){ p.ovl.beginPath(); p.ovl.rect(h.x-hs/2, h.y-hs/2, hs, hs); p.ovl.fill(); p.ovl.stroke(); }
    if(canRotate){
      const rotate={x:b.x+b.w/2,y:b.y-30};
      p.ovl.beginPath();
      p.ovl.moveTo(b.x+b.w/2,b.y);
      p.ovl.lineTo(rotate.x, rotate.y);
      p.ovl.stroke();
      p.ovl.beginPath();
      p.ovl.arc(rotate.x, rotate.y, hs/1.5, 0, Math.PI*2);
      p.ovl.fill();
      p.ovl.stroke();
    }
    p.ovl.restore();
  }
  function handlePoints(b){
    const cx=b.x+b.w/2, cy=b.y+b.h/2;
    return [
      {x:b.x, y:b.y}, {x:cx, y:b.y}, {x:b.x+b.w, y:b.y},
      {x:b.x, y:cy},                 {x:b.x+b.w, y:cy},
      {x:b.x, y:b.y+b.h}, {x:cx, y:b.y+b.h}, {x:b.x+b.w, y:b.y+b.h},
    ];
  }
  function hitHandle(pxy, b){
    const hs=HANDLE_SIZE, pts=handlePoints(b);
    for(let i=0;i<pts.length;i++){
      if(Math.abs(pxy.x-pts[i].x)<=hs && Math.abs(pxy.y-pts[i].y)<=hs) return i;
    }
    if(selectionRotateEnabled){
      const rotate = {x:b.x+b.w/2, y:b.y-30};
      if(Math.hypot(pxy.x-rotate.x, pxy.y-rotate.y)<=hs) return ROTATE_HANDLE;
    }
    return -1;
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function distToSegment(p, a, b){
    const ABx=b.x-a.x, ABy=b.y-a.y, APx=p.x-a.x, APy=p.y-a.y;
    const ab2=ABx*ABx+ABy*ABy; const t=ab2?Math.max(0,Math.min(1,(APx*ABx+APy*ABy)/ab2)):0;
    const proj={x:a.x+t*ABx,y:a.y+t*ABy}; return dist(p,proj);
  }
  function hitPolyline(pts, pxy, eps){ for(let i=1;i<pts.length;i++){ if(distToSegment(pxy, pts[i-1], pts[i])<=eps) return true;} return false; }
  function hitTest(pxy, p){
    for(let i=p.state.images.length-1;i>=0;i--){
      const im=p.state.images[i];
      if(pxy.x>=im.x && pxy.x<=im.x+im.w && pxy.y>=im.y && pxy.y<=im.y+im.h){
        return {kind:'image', index:i, bbox:{x:im.x,y:im.y,w:im.w,h:im.h}};
      }
    }
    const eps = Math.max(6, size*2);
    for(let i=p.state.strokes.length-1;i>=0;i--){
      const s=p.state.strokes[i];
      if(s.type==='pen'){ if(hitPolyline(s.points,pxy,eps)) return {kind:'stroke',index:i,bbox:bboxStroke(s)}; }
      else if(s.type==='line'){ if(distToSegment(pxy,s.a,s.b)<=eps) return {kind:'stroke',index:i,bbox:bboxStroke(s)}; }
      else if(s.type==='text'){
        const b=bboxStroke(s);
        if(pxy.x>=b.x&&pxy.x<=b.x+b.w&&pxy.y>=b.y&&pxy.y<=b.y+b.h) return {kind:'stroke',index:i,bbox:b};
      }else if(s.type==='poly'){
        if(s.points && hitPolyline(s.points, pxy, eps)){
          return {kind:'stroke', index:i, bbox:bboxStroke(s)};
        }
      }
    }
    return null;
  }

  const HANDLE_MIN_SIZE = 12;
  function cloneStrokeState(stroke){
    if(!stroke) return null;
    if(stroke.type==='pen'){
      return {
        type:stroke.type,
        color:stroke.color,
        size:stroke.size,
        points: stroke.points.map(pt=>({x:pt.x, y:pt.y}))
      };
    }
    if(stroke.type==='line'){
      return {
        type:stroke.type,
        color:stroke.color,
        size:stroke.size,
        a:{...stroke.a},
        b:{...stroke.b}
      };
    }
    if(stroke.type==='text'){
      return {...stroke};
    }
    if(stroke.type==='poly'){
      return {
        type:stroke.type,
        color:stroke.color,
        size:stroke.size,
        points: stroke.points ? stroke.points.map(pt=>({x:pt.x,y:pt.y})) : [],
        closed: stroke.closed
      };
    }
    return null;
  }
  function cloneImageState(im){
    if(!im) return null;
    return {x:im.x, y:im.y, w:im.w, h:im.h, meta:im.meta};
  }
  function computeScaledBBox(startBBox, handle, x, y){
    let left = startBBox.x;
    let right = startBBox.x + startBBox.w;
    let top = startBBox.y;
    let bottom = startBBox.y + startBBox.h;
    switch(handle){
      case 0: left = x; top = y; break;
      case 1: top = y; break;
      case 2: right = x; top = y; break;
      case 3: left = x; break;
      case 4: right = x; break;
      case 5: left = x; bottom = y; break;
      case 6: bottom = y; break;
      case 7: right = x; bottom = y; break;
    }
    const moveLeft   = (handle===0||handle===3||handle===5);
    const moveRight  = (handle===2||handle===4||handle===7);
    const moveTop    = (handle===0||handle===1||handle===2);
    const moveBottom = (handle===5||handle===6||handle===7);
    if(right - left < HANDLE_MIN_SIZE){
      if(moveLeft) left = right - HANDLE_MIN_SIZE;
      else if(moveRight) right = left + HANDLE_MIN_SIZE;
    }
    if(bottom - top < HANDLE_MIN_SIZE){
      if(moveTop) top = bottom - HANDLE_MIN_SIZE;
      else if(moveBottom) bottom = top + HANDLE_MIN_SIZE;
    }
    const width = Math.max(HANDLE_MIN_SIZE, right - left);
    const height = Math.max(HANDLE_MIN_SIZE, bottom - top);
    return { x:left, y:top, w:width, h:height };
  }
  function scalePointRelative(pt, startBBox, nextBBox){
    const rx = startBBox.w ? (pt.x - startBBox.x) / startBBox.w : 0;
    const ry = startBBox.h ? (pt.y - startBBox.y) / startBBox.h : 0;
    return {
      x: nextBBox.x + rx * nextBBox.w,
      y: nextBBox.y + ry * nextBBox.h
    };
  }
  function computeScaleFactor(startBBox, nextBBox){
    const vals = [];
    if(startBBox.w) vals.push(Math.abs(nextBBox.w / startBBox.w));
    if(startBBox.h) vals.push(Math.abs(nextBBox.h / startBBox.h));
    if(!vals.length) return 1;
    const avg = vals.reduce((a,b)=>a+b,0) / vals.length;
    return avg || 1;
  }
  function applyScaledSelection(sel, drag, nextBBox, p){
    if(sel.kind==='image'){
      const im = p.state.images[sel.index];
      if(!im) return;
      im.x = nextBBox.x;
      im.y = nextBBox.y;
      im.w = Math.max(1, nextBBox.w);
      im.h = Math.max(1, nextBBox.h);
      return;
    }
    const stroke = p.state.strokes[sel.index];
    const original = drag.original;
    if(!stroke || !original) return;
    if(stroke.type==='pen'){
      stroke.points = original.points.map(pt=>scalePointRelative(pt, drag.startBBox, nextBBox));
    }else if(stroke.type==='line'){
      stroke.a = scalePointRelative(original.a, drag.startBBox, nextBBox);
      stroke.b = scalePointRelative(original.b, drag.startBBox, nextBBox);
    }else if(stroke.type==='text'){
      const mapped = scalePointRelative({x:original.x, y:original.y}, drag.startBBox, nextBBox);
      stroke.x = mapped.x;
      stroke.y = mapped.y;
    }else if(stroke.type==='poly'){
      stroke.points = (original.points||[]).map(pt=>scalePointRelative(pt, drag.startBBox, nextBBox));
    }
    const factor = computeScaleFactor(drag.startBBox, nextBBox);
    if(stroke.type==='pen' || stroke.type==='line'){
      stroke.size = Math.max(0.5, original.size * factor);
    }else if(stroke.type==='text'){
      stroke.size = Math.max(1, original.size * factor);
    }
  }

  /* ---------- GUMKA POD≈öWIETLA ---------- */
  function previewErase(pt, p){
    clearOverlay(p); if(p.state.selection) drawSelection(p);
    const eps = Math.max(6,size*2);
    for(let i=p.state.strokes.length-1;i>=0;i--){
      const s=p.state.strokes[i]; let hit=false;
      if(s.type==='pen') hit=hitPolyline(s.points,pt,eps);
      else if(s.type==='line') hit=distToSegment(pt,s.a,s.b)<=eps;
      else if(s.type==='text'){ const b=bboxStroke(s); hit=(pt.x>=b.x&&pt.x<=b.x+b.w&&pt.y>=b.y&&pt.y<=b.y+b.h); }
      else if(s.type==='poly'){ hit = s.points && hitPolyline(s.points, pt, eps); }
      if(hit){
        p.ovl.save(); p.ovl.lineCap='round'; p.ovl.lineJoin='round';
        if(s.type==='pen'){
          const pts=s.points; if(!pts.length){ p.ovl.restore();return; }
          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2);
          p.ovl.beginPath(); p.ovl.moveTo(pts[0].x, pts[0].y);
          for(let j=1;j<pts.length;j++){ p.ovl.lineTo(pts[j].x, pts[j].y); }
          p.ovl.stroke();
        }else if(s.type==='line'){
          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2);
          p.ovl.beginPath(); p.ovl.moveTo(s.a.x,s.a.y); p.ovl.lineTo(s.b.x,s.b.y); p.ovl.stroke();
        }else if(s.type==='text'){
          const b=bboxStroke(s); p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=2; p.ovl.setLineDash([5,4]);
          p.ovl.strokeRect(b.x,b.y,b.w,b.h); p.ovl.setLineDash([]);
        }else if(s.type==='poly' && s.points && s.points.length){
          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2); p.ovl.setLineDash([5,4]);
          p.ovl.beginPath();
          p.ovl.moveTo(s.points[0].x, s.points[0].y);
          for(let k=1;k<s.points.length;k++){ p.ovl.lineTo(s.points[k].x, s.points[k].y); }
          p.ovl.closePath();
          p.ovl.stroke();
          p.ovl.setLineDash([]);
        }
        p.ovl.restore(); return;
      }
    }
  }
  function eraseAt(pt,p){
    const eps = Math.max(6, size*2);
    let removed=false;
    for(let i=p.state.strokes.length-1;i>=0;i--){
      const s = p.state.strokes[i];
      if(s.type==='pen' && hitPolyline(s.points,pt,eps)){ p.state.strokes.splice(i,1); removed=true; continue; }
      if(s.type==='line' && distToSegment(pt,s.a,s.b)<=eps){ p.state.strokes.splice(i,1); removed=true; continue; }
      if(s.type==='poly' && s.points && hitPolyline(s.points,pt,eps)){ p.state.strokes.splice(i,1); removed=true; continue; }
      if(s.type==='text'){
        const b=bboxStroke(s);
        if(pt.x>=b.x&&pt.x<=b.x+b.w&&pt.y>=b.y&&pt.y<=b.y+b.h){ p.state.strokes.splice(i,1); removed=true; continue; }
      }
    }
    for(let i=p.state.images.length-1;i>=0;i--){
      const im = p.state.images[i];
      if(pt.x>=im.x && pt.x<=im.x+im.w && pt.y>=im.y && pt.y<=im.y+im.h){
        p.state.images.splice(i,1);
        removed=true;
        continue;
      }
    }
    if(removed){ renderAll(p); clearOverlay(p); }
  }

  /* ---------- TEKST INLINE ---------- */
  let activeEditor=null;
  function openTextEditor(x,y,p){
    closeTextEditor(false);
    const ed = document.createElement('textarea'); ed.className='text-editor';
    const r = p.el.getBoundingClientRect();
    ed.style.left = (r.left + x) + 'px';
    ed.style.top  = (r.top  + y) + 'px';
    ed.style.fontSize = Math.max(14, size*6) + 'px';
    ed.placeholder='Wpisz tekst‚Ä¶';
    document.body.appendChild(ed); ed.focus();
    ed.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); closeTextEditor(true,p,x,y); } if(e.key==='Escape'){ e.preventDefault(); closeTextEditor(false); }});
    ed.addEventListener('blur', ()=>{ closeTextEditor(true,p,x,y); });
    activeEditor = {el:ed, color, size};
  }
  function closeTextEditor(commit,p,x,y){
    if(!activeEditor){ return; }
    const {el} = activeEditor; const val=el.value.trim(); el.remove(); activeEditor=null;
    if(commit && p && val){ pushHistory(p); p.state.strokes.push({type:'text', color, size, x, y, text: val}); renderAll(p); }
  }

  /* ---------- COMPOSITE STRONY ---------- */
  async function compositePageCanvas(p){
    const dpr = window.devicePixelRatio || 1;
    const W = p.drawC.width / dpr, H = p.drawC.height / dpr;
    const tmp = document.createElement('canvas'); tmp.width=W; tmp.height=H;
    theContext = tmp.getContext('2d');

    if(gridSize === 'tech'){
      drawTechPattern(theContext, W, H);
    }else if(gridSize){
      theContext.save(); theContext.strokeStyle='#e6edff'; theContext.lineWidth=1;
      for(let x=0;x<=W;x+=gridSize){ theContext.beginPath(); theContext.moveTo(x,0); theContext.lineTo(x,H); theContext.stroke(); }
      for(let y=0;y<=H;y+=gridSize){ theContext.beginPath(); theContext.moveTo(0,y); theContext.lineTo(W,y); theContext.stroke(); }
      theContext.restore();
    }
    await Promise.all(p.state.images.map(im => im.img ? Promise.resolve() : new Promise(res=>{ const el=new Image(); el.onload=()=>{im.img=el; res();}; el.src=im.src; })));
    for(const im of p.state.images){ if(im.img) theContext.drawImage(im.img, im.x, im.y, im.w, im.h); }

    theContext.lineCap='round'; theContext.lineJoin='round';
    for(const s of p.state.strokes){
      if(s.type==='pen'){
        theContext.strokeStyle=s.color; theContext.lineWidth=s.size; const pts=s.points; if(!pts.length) continue;
        theContext.beginPath(); theContext.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length;i++){ theContext.lineTo(pts[i].x, pts[i].y); } theContext.stroke();
      }else if(s.type==='line'){
        theContext.strokeStyle=s.color; theContext.lineWidth=s.size; theContext.beginPath(); theContext.moveTo(s.a.x,s.a.y); theContext.lineTo(s.b.x,s.b.y); theContext.stroke();
      }else if(s.type==='text'){
        theContext.save(); theContext.fillStyle=s.color; theContext.font = `${Math.max(14, s.size*6)}px ui-sans-serif, system-ui, Arial`; theContext.textBaseline='top'; theContext.fillText(s.text, s.x, s.y); theContext.restore();
      }else if(s.type==='poly'){
        const pts=s.points;
        if(!pts || !pts.length) continue;
        theContext.save();
        theContext.strokeStyle=s.color;
        theContext.lineWidth=s.size;
        theContext.lineCap='round';
        theContext.lineJoin='round';
        theContext.beginPath();
        theContext.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){ theContext.lineTo(pts[i].x, pts[i].y); }
        if(s.closed){ theContext.closePath(); }
        theContext.stroke();
        theContext.restore();
      }
    }
    return tmp;
  }

  /* ---------- CROP (wycinanie) ---------- */
  let cropRectEl=null, cropStart=null, cropProcessing=false, cropBusyHintEl=null, cropBusyHintTimer=null;
  function beginCrop(x,y,p){
    cropCancel();
    cropStart = {x,y};
    cropRectEl = document.createElement('div'); cropRectEl.className='crop-rect';
    const r = p.drawC.getBoundingClientRect();
    const docLeft = r.left + window.scrollX;
    const docTop  = r.top  + window.scrollY;
    cropRectEl.style.left = (docLeft + x) + 'px';
    cropRectEl.style.top  = (docTop  + y) + 'px';
    cropRectEl.style.width='0px'; cropRectEl.style.height='0px';
    document.body.appendChild(cropRectEl);
  }
  function updateCrop(x,y,p){
    if(!cropRectEl || !cropStart) return;
    const r = p.drawC.getBoundingClientRect();
    const docLeft = r.left + window.scrollX;
    const docTop  = r.top  + window.scrollY;
    const x0 = Math.min(cropStart.x, x), y0 = Math.min(cropStart.y, y);
    const x1 = Math.max(cropStart.x, x), y1 = Math.max(cropStart.y, y);
    cropRectEl.style.left = (docLeft + x0) + 'px';
    cropRectEl.style.top  = (docTop  + y0) + 'px';
    cropRectEl.style.width  = (x1 - x0) + 'px';
    cropRectEl.style.height = (y1 - y0) + 'px';
  }
  function cropCancel(){ cropStart=null; if(cropRectEl){ cropRectEl.remove(); cropRectEl=null; } }
  async function finalizeCrop(x,y,p){
    if(!cropRectEl || !cropStart){ return; }
    const x0 = Math.min(cropStart.x, x), y0 = Math.min(cropStart.y, y);
    const x1 = Math.max(cropStart.x, x), y1 = Math.max(cropStart.y, y);
    cropCancel();

    if(!selectionHasContent(p, x0, y0, x1, y1)){
      alert('Zaznaczony obszar jest pusty - nic nie zostalo wyciete.');
      return;
    }

    cropProcessing = true;
    try{
      const placement = await askCropPlacement();

      const comp = await compositePageCanvas(p);
      const sx = Math.max(0, Math.floor(x0)), sy = Math.max(0, Math.floor(y0));
      const sw = Math.max(1, Math.floor(x1 - x0)), sh = Math.max(1, Math.floor(y1 - y0));
      const cut = document.createElement('canvas'); cut.width=sw; cut.height=sh;
      const cctx = cut.getContext('2d');
      cctx.drawImage(comp, sx, sy, sw, sh, 0, 0, sw, sh);
      const url = cut.toDataURL('image/png');

      const margin = 24;
      const rect = p.el.getBoundingClientRect();
      const pageW = rect.width, pageH = rect.height;
      const selectionBox = {x:x0, y:y0, w:x1-x0, h:y1-y0};

      const maxW = pageW - margin*2;
      const maxH = pageH - margin*2;
      const scale = Math.min(1, maxW / sw, maxH / sh);
      const w = Math.max(1, Math.floor(sw * scale));
      const h = Math.max(1, Math.floor(sh * scale));

      let targetPage = p;
      let xPos = 0;
      let yPos = 0;
      const placeBelow = placement !== 'adjacent';

      if(placeBelow){
        const bboxBottom = bottomOfTexts(p);
        xPos = Math.floor((pageW - w)/2);
        yPos = bboxBottom + margin;

        if (yPos + h + margin > pageH){
          targetPage = createPage();
          const rect2 = targetPage.el.getBoundingClientRect();
          xPos = Math.floor((rect2.width - w)/2);
          yPos = 24;
        }
      }else{
        const adj = findAdjacentPosition(selectionBox, w, h, pageW, pageH, margin);
        xPos = adj.x;
        yPos = adj.y;
      }
      addImageFromSrc(url, w, h, xPos, yPos, {crop:true}, targetPage);
      targetPage.el.scrollIntoView({behavior:'smooth', block:'center'});
    }finally{
      cropProcessing = false;
    }
  }
  function bottomOfTexts(p){
    let bottom = 0;
    const candidates = p.state.strokes.filter(s=>s.type==='text').map(s=>{ const b=bboxStroke(s); return b.y+b.h; });
    if(candidates.length){ bottom = Math.max(...candidates); }
    else {
      const all = [
        ...p.state.strokes.map(s=>{ const b=bboxStroke(s); return b.y+b.h; }),
        ...p.state.images.map(im=> im.y + im.h)
      ];
      if(all.length) bottom = Math.max(...all);
    }
    return bottom;
  }
  function selectionHasContent(p, x0, y0, x1, y1){
    const left = Math.min(x0,x1), right = Math.max(x0,x1);
    const top = Math.min(y0,y1), bottom = Math.max(y0,y1);
    const rect = {x:left, y:top, w:Math.max(0,right-left), h:Math.max(0,bottom-top)};
    if(rect.w===0 || rect.h===0) return false;
    const overlaps = (box)=> rect.x < box.x + box.w && rect.x + rect.w > box.x && rect.y < box.y + box.h && rect.y + rect.h > box.y;
    for(const s of p.state.strokes){
      if((s.type==='pen' || s.type==='poly') && (!s.points || !s.points.length)) continue;
      const box = bboxStroke(s);
      if(box.w===0 && box.h===0) continue;
      if(overlaps(box)){ return true; }
    }
    for(const im of (p.state.images||[])){
      const box = {x:im.x, y:im.y, w:im.w, h:im.h};
      if(overlaps(box)){ return true; }
    }
    return false;
  }
  function findAdjacentPosition(selection, w, h, pageW, pageH, margin){
    const clamp = (val, min, max)=> Math.min(Math.max(val, min), max);
    const maxX = Math.max(0, pageW - w);
    const maxY = Math.max(0, pageH - h);
    let xPos = selection.x + selection.w + margin;
    if(xPos + w > pageW){
      xPos = selection.x - w - margin;
    }
    xPos = clamp(xPos, 0, maxX);
    let yPos = clamp(selection.y, 0, maxY);
    if(yPos + h > pageH){
      yPos = maxY;
    }
    return {x:xPos, y:yPos};
  }
  function askCropPlacement(){
    return new Promise(resolve=>{
      const overlay=document.createElement('div');
      overlay.className='crop-choice-backdrop';
      const dialog=document.createElement('div');
      dialog.className='crop-choice-dialog';
      const text=document.createElement('p');
      text.textContent='Gdzie umie≈õciƒá skopiowany fragment?';
      const actions=document.createElement('div');
      actions.className='crop-choice-actions';
      const btnBelow=document.createElement('button');
      btnBelow.className='primary';
      btnBelow.textContent='Kopiuj na dole';
      const btnAside=document.createElement('button');
      btnAside.className='secondary';
      btnAside.textContent='Kopiuj obok';

      let cleaned=false;
      function cleanup(choice){
        if(cleaned) return;
        cleaned=true;
        document.removeEventListener('keydown', onOverlayKey);
        overlay.classList.remove('open');
        let removed=false;
        const removeNow=()=>{ if(removed) return; removed=true; overlay.remove(); };
        overlay.addEventListener('transitionend', removeNow, {once:true});
        setTimeout(removeNow, 220);
        resolve(choice || 'below');
      }
      function onOverlayKey(e){
        if(e.key==='Escape'){
          cleanup('below');
        }
      }

      btnBelow.addEventListener('click', ()=> cleanup('below'));
      btnAside.addEventListener('click', ()=> cleanup('adjacent'));
      overlay.addEventListener('click', (e)=>{
        if(e.target===overlay){ cleanup('below'); }
      });
      document.addEventListener('keydown', onOverlayKey);

      actions.appendChild(btnBelow);
      actions.appendChild(btnAside);
      dialog.appendChild(text);
      dialog.appendChild(actions);
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      requestAnimationFrame(()=> overlay.classList.add('open'));
    });
  }
  function showCropBusyHint(){
    if(cropBusyHintEl){
      clearTimeout(cropBusyHintTimer);
      cropBusyHintEl.remove();
      cropBusyHintEl=null;
    }
    const toast=document.createElement('div');
    toast.className='crop-busy-toast';
    toast.textContent='Poczekaj na zako≈Ñczenie kopiowania...';
    document.body.appendChild(toast);
    requestAnimationFrame(()=> toast.classList.add('show'));
    cropBusyHintEl=toast;
    cropBusyHintTimer=setTimeout(()=>{
      toast.classList.remove('show');
      const remove=()=>{
        toast.removeEventListener('transitionend', remove);
        if(cropBusyHintEl===toast){ cropBusyHintEl=null; cropBusyHintTimer=null; }
        toast.remove();
      };
      toast.addEventListener('transitionend', remove);
      setTimeout(remove, 400);
    }, 2000);
  }

  /* ---------- INTERAKCJE (POINTER) ---------- */
const ROTATE_HANDLE = 99;

function rectToPoly(x0,y0,x1,y1){
  const left=Math.min(x0,x1), right=Math.max(x0,x1);
  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
  return [
    {x:left,y:top}, {x:right,y:top}, {x:right,y:bottom}, {x:left,y:bottom}
  ];
  }
  function isoTriangleFromRect(x0,y0,x1,y1){
    const left=Math.min(x0,x1), right=Math.max(x0,x1);
    const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
    const midX = (left+right)/2;
    return [{x:midX,y:top},{x:right,y:bottom},{x:left,y:bottom}];
  }
  function rightTriangleFromRect(x0,y0,x1,y1){
    const left=Math.min(x0,x1), right=Math.max(x0,x1);
    const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
    return [{x:left,y:top},{x:right,y:top},{x:left,y:bottom}];
  }
function hexFromRect(x0,y0,x1,y1){
  const left=Math.min(x0,x1), right=Math.max(x0,x1);
  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
  const w=right-left, h=bottom-top;
  const cx=left+w/2, cy=top+h/2;
  const r = Math.min(w, h)/2;
  const pts=[];
  for(let i=0;i<6;i++){
    const a = Math.PI/6 + i * (Math.PI/3);
    pts.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a)});
  }
  return pts;
}
function circleFromRect(x0,y0,x1,y1){
  const left=Math.min(x0,x1), right=Math.max(x0,x1);
  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
  const w=right-left, h=bottom-top;
  const cx=left+w/2, cy=top+h/2;
  const r = Math.min(w, h)/2;
  const segments = 24;
  const pts=[];
  for(let i=0;i<segments;i++){
    const a = i*(2*Math.PI/segments);
    pts.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a)});
  }
  return pts;
}
function shapeFromDrag(shape, x0,y0,x1,y1){
  if(shape==='rect') return rectToPoly(x0,y0,x1,y1);
  if(shape==='tri_iso') return isoTriangleFromRect(x0,y0,x1,y1);
  if(shape==='tri_right') return rightTriangleFromRect(x0,y0,x1,y1);
  if(shape==='hex') return hexFromRect(x0,y0,x1,y1);
  if(shape==='circle') return circleFromRect(x0,y0,x1,y1);
  return rectToPoly(x0,y0,x1,y1);
}
function rotatePointAround(pt, center, angle){
  const dx = pt.x - center.x;
  const dy = pt.y - center.y;
  return {
    x: center.x + dx * Math.cos(angle) - dy * Math.sin(angle),
    y: center.y + dx * Math.sin(angle) + dy * Math.cos(angle)
  };
}
function rectCorners(x,y,w,h){
  return [
    {x, y},
    {x: x+w, y},
    {x: x+w, y: y+h},
    {x, y: y+h}
  ];
}
function axisAlignedBBox(points){
  const xs = points.map(p=>p.x);
  const ys = points.map(p=>p.y);
  const minx = Math.min(...xs), maxx = Math.max(...xs);
  const miny = Math.min(...ys), maxy = Math.max(...ys);
  return {x:minx, y:miny, w:maxx-minx, h:maxy-miny};
}
function imageBoundingBox(im){
  if(!im) return {x:0,y:0,w:0,h:0};
  if(!im.rotation){
    return {x:im.x, y:im.y, w:im.w, h:im.h};
  }
  const center = {x: im.x + im.w/2, y: im.y + im.h/2};
  const corners = rectCorners(im.x, im.y, im.w, im.h).map(pt=>rotatePointAround(pt, center, im.rotation));
  return axisAlignedBBox(corners);
}
function textDimensions(s){
  const w = (Math.max(14, s.size*6)*0.6)*(s.text?.length||0);
  const h = Math.max(14, s.size*6);
  return {w,h};
}

  function bindPage(p){
    function getXY(evt){
      const r = p.drawC.getBoundingClientRect();
      return { x: evt.clientX - r.left, y: evt.clientY - r.top };
    }
    let drawing=false, startX=0, startY=0, current=null, cropping=false;
    const touchPointers = new Set();   // aktywne pointerId typu touch
    const activePointers = new Set();
    let multiPan=false;                // tryb dwupalczastego scrolla
    let panCentroidY=null;             // poprzedni centroid dotyk√≥w (Y)
    const pointerPosY = new Map();     // pointerId -> ostatni clientY
    let panIdleTimer=null;
    const PAN_IDLE_MS = 350;

    function endMultiPan(reason){
      multiPan=false;
      panCentroidY=null;
      pointerPosY.clear();
      touchPointers.clear();
      activePointers.clear();
      if(panIdleTimer){ clearTimeout(panIdleTimer); panIdleTimer=null; }
    }

    function currentTouchCentroid(){
      let sumY=0, cnt=0;
      touchPointers.forEach(id=>{
        if(pointerPosY.has(id)){
          sumY += pointerPosY.get(id);
          cnt++;
        }
      });
      return cnt>=2 ? sumY / cnt : null;
    }

    function start(x,y){
      if(tool===TOOLS.SELECT){
        const pt={x,y};
        if(p.state.selection){
          const h = hitHandle(pt, p.state.selection.bbox);
          if(h===ROTATE_HANDLE){
            const sel = p.state.selection;
            if(sel.kind==='stroke'){
              const s = p.state.strokes[sel.index];
              if(s.type==='poly'){
                const center = {x: sel.bbox.x + sel.bbox.w/2, y: sel.bbox.y + sel.bbox.h/2};
                p.state.dragging={
                  mode:'rotate',
                  startAngle: Math.atan2(y-center.y, x-center.x),
                  center,
                  original: cloneStrokeState(s)
                };
                pushHistory(p);
                return;
              }
            }
            return;
          }else if(h>=0){
            const sel = p.state.selection;
            const original = sel.kind==='image'
              ? cloneImageState(p.state.images[sel.index])
              : cloneStrokeState(p.state.strokes[sel.index]);
            p.state.dragging={
              mode:'scale',
              handle:h,
              startX:x,
              startY:y,
              startBBox:{...sel.bbox},
              original
            };
            pushHistory(p);
            return;
          }
          const b=p.state.selection.bbox;
          if(x>=b.x&&x<=b.x+b.w&&y>=b.y&&y<=b.y+b.h){ p.state.dragging={mode:'move', startX:x, startY:y}; pushHistory(p); return; }
        }
        p.state.selection = hitTest(pt,p) || null; drawSelection(p); return;
      }
      if(tool===TOOLS.TEXT){ openTextEditor(x,y,p); return; }
      if(tool===TOOLS.CROP){
        if(cropProcessing){ showCropBusyHint(); return; }
        beginCrop(x,y,p); cropping=true; return;
      }
      if(tool===TOOLS.FIGURE){
        drawing=true; startX=x; startY=y; pushHistory(p); clearOverlay(p);
        const pts = shapeFromDrag(currentShape, startX, startY, x, y);
        drawPolyPreview(p, pts);
        return;
      }

      drawing=true; startX=x; startY=y; pushHistory(p);
      if(tool===TOOLS.PEN){
        current={type:'pen', color, size, points:[{x,y}]}; p.state.strokes.push(current); renderAll(p);
      }else if(tool===TOOLS.LINE){
        current={type:'line', color, size, a:{x,y}, b:{x,y}}; clearOverlay(p);
      }else if(tool===TOOLS.ERASER){
        eraseAt({x,y},p);
        current=null;
      }
    }
    function move(x,y){
      if(tool===TOOLS.SELECT){
        const d=p.state.dragging;
        const sel=p.state.selection;
        if(d && sel){
          if(d.mode==='move'){
            const dx=x-d.startX, dy=y-d.startY; d.startX=x; d.startY=y;
            if(sel.kind==='image'){
              const im=p.state.images[sel.index]; im.x+=dx; im.y+=dy; sel.bbox.x+=dx; sel.bbox.y+=dy;
            }else{
              const s=p.state.strokes[sel.index];
              if(s.type==='pen') s.points.forEach(pt=>{pt.x+=dx;pt.y+=dy;});
              if(s.type==='line'){ s.a.x+=dx; s.a.y+=dy; s.b.x+=dx; s.b.y+=dy; }
              if(s.type==='text'){ s.x+=dx; s.y+=dy; }
              if(s.type==='poly' && s.points){ s.points.forEach(pt=>{pt.x+=dx;pt.y+=dy;}); }
              sel.bbox=bboxStroke(s);
            }
          }else if(d.mode==='scale'){
            const nextBBox = computeScaledBBox(d.startBBox, d.handle, x, y);
            applyScaledSelection(sel, d, nextBBox, p);
            sel.bbox = nextBBox;
          }else if(d.mode==='rotate'){
            if(sel.kind==='stroke'){
              const s = p.state.strokes[sel.index];
              if(s && s.type==='poly'){
                const angle = Math.atan2(y-d.center.y, x-d.center.x);
                const delta = angle - d.startAngle;
                s.points = d.original.points.map(pt=>rotatePointAround(pt, d.center, delta));
                sel.bbox = bboxStroke(s);
              }
            }
          }
          renderAll(p); drawSelection(p);
        }
        return;
      }
      if(tool===TOOLS.CROP && cropping){ updateCrop(x,y,p); return; }
      if(tool===TOOLS.ERASER){
        if(drawing){ eraseAt({x,y},p); }
        else{ previewErase({x,y},p); }
        return;
      }
      if(tool===TOOLS.FIGURE){
        if(!drawing) return;
        const pts = shapeFromDrag(currentShape, startX, startY, x, y);
        drawPolyPreview(p, pts);
        return;
      }
      if(!drawing) return;

      if(tool===TOOLS.PEN){ current.points.push({x,y}); renderAll(p); }
      else if(tool===TOOLS.LINE){
        current.b={x,y}; clearOverlay(p);
        p.ovl.lineCap='round'; p.ovl.lineJoin='round'; p.ovl.strokeStyle=color; p.ovl.lineWidth=size;
        p.ovl.beginPath(); p.ovl.moveTo(startX,startY); p.ovl.lineTo(x,y); p.ovl.stroke();
      }
    }
    function end(x,y){
      if(tool===TOOLS.SELECT){ p.state.dragging=null; return; }
      if(tool===TOOLS.CROP && cropping){ cropping=false; finalizeCrop(x,y,p); return; }
      if(tool===TOOLS.ERASER){
        drawing=false;
        clearOverlay(p);
        if(p.state.selection) drawSelection(p);
        return;
      }
      if(tool===TOOLS.FIGURE){
        if(!drawing) return;
        const pts = shapeFromDrag(currentShape, startX, startY, x, y);
        clearOverlay(p);
        p.state.strokes.push({ type:'poly', color, size, points: pts, closed:true });
        renderAll(p);
        drawing=false; current=null;
        return;
      }
      if(!drawing) return;
      if(tool===TOOLS.LINE){ clearOverlay(p); current.b={x,y}; p.state.strokes.push(current); renderAll(p); }
      drawing=false; current=null;
    }

    function trackTouch(e, isDown){
      if(e.pointerType!=='touch') return;
      if(isDown){
        touchPointers.add(e.pointerId);
        pointerPosY.set(e.pointerId, e.clientY);
      }else{
        touchPointers.delete(e.pointerId);
        pointerPosY.delete(e.pointerId);
      }
      const shouldPan = touchPointers.size >= 2;
      if(shouldPan && !multiPan){
        multiPan = true;
        drawing = false;
        activePointers.clear();
        panCentroidY = currentTouchCentroid();
        if(panIdleTimer) clearTimeout(panIdleTimer);
        panIdleTimer = setTimeout(()=>{ endMultiPan('idle-start'); }, PAN_IDLE_MS);
        try{
          touchPointers.forEach(id=>{ try{ p.drawC.releasePointerCapture(id); }catch(_){} });
        }catch(_){}
      }else if(!shouldPan && multiPan){
        endMultiPan('pointer-drop');
      }else if(shouldPan && multiPan){
        const centroid = currentTouchCentroid();
        if(centroid!==null){ panCentroidY = centroid; }
        if(panIdleTimer) clearTimeout(panIdleTimer);
        panIdleTimer = setTimeout(()=>{ endMultiPan('idle-change'); }, PAN_IDLE_MS);
      }
    }

    p.drawC.addEventListener('pointerdown', (e)=>{
      trackTouch(e, true);
      if(multiPan) return;
      e.preventDefault();
      p.drawC.setPointerCapture(e.pointerId);
      pointerPosY.set(e.pointerId, e.clientY);
      const {x,y}=getXY(e);
      start(x,y);
      activePointers.add(e.pointerId);
    }, {passive:false});
    p.drawC.addEventListener('pointermove', (e)=>{
      if(multiPan){
        e.preventDefault();
        if(e.pointerType==='touch'){ pointerPosY.set(e.pointerId, e.clientY); }
        const cy = currentTouchCentroid();
        if(cy!==null){
          if(panCentroidY!==null){
            const dy = cy - panCentroidY;
            wrapEl.scrollTop -= dy;
          }
          panCentroidY = cy;
          if(panIdleTimer) clearTimeout(panIdleTimer);
          panIdleTimer = setTimeout(()=>{ endMultiPan('idle'); }, PAN_IDLE_MS);
        }
        return;
      }
      if(tool!==TOOLS.SELECT || e.buttons) e.preventDefault();
      const {x,y}=getXY(e);
      move(x,y);
    }, {passive:false});
    function handlePointerRelease(e){
      trackTouch(e, false);
      if(multiPan){
        pointerPosY.delete(e.pointerId);
        const cy = currentTouchCentroid();
        if(cy!==null){ panCentroidY = cy; }
        return;
      }
      if(!activePointers.has(e.pointerId)) return;
      activePointers.delete(e.pointerId);
      e.preventDefault();
      const {x,y}=getXY(e);
      end(x,y);
      try{ p.drawC.releasePointerCapture(e.pointerId);}catch(_){}
    }
    p.drawC.addEventListener('pointerup', handlePointerRelease, {passive:false});
    p.drawC.addEventListener('pointercancel', handlePointerRelease, {passive:false});

    function globalTouchCleanup(e, isDown){
      if(e.pointerType && e.pointerType!=='touch') return;
      if(isDown) return;
      if(pointerPosY.has(e.pointerId)) pointerPosY.delete(e.pointerId);
      if(touchPointers.has(e.pointerId)) touchPointers.delete(e.pointerId);
      if(touchPointers.size<2 && multiPan){
        endMultiPan('global-release');
      }
    }
    window.addEventListener('pointerup', (e)=>globalTouchCleanup(e,false), {passive:false});
    window.addEventListener('pointercancel', (e)=>globalTouchCleanup(e,false), {passive:false});
    window.addEventListener('touchend', ()=>{ if(multiPan) endMultiPan('touchend'); }, {passive:false});
    window.addEventListener('touchcancel', ()=>{ if(multiPan) endMultiPan('touchcancel'); }, {passive:false});
    document.addEventListener('visibilitychange', ()=>{ if(document.hidden && multiPan){ endMultiPan('hidden'); } });
  }

  /* ---------- UI OG√ìLNY ---------- */
  function toolLabel(){
    return tool===TOOLS.SELECT?'Kursor':
           tool===TOOLS.PEN?'O≈Ç√≥wek':
           tool===TOOLS.LINE?'Linia':
           tool===TOOLS.ERASER?'Gumka':
           tool===TOOLS.TEXT?'Tekst':
           tool===TOOLS.CROP?'Wycinanie':'Figury';
  }
  function setTool(next){
    tool = next;
    updateState();
    document.querySelectorAll('#tools [data-tool]').forEach(b=>{
      b.classList.toggle('is-active', b.getAttribute('data-tool')===tool);
    });
    if(tool!==TOOLS.FIGURE){ toggleFigurePalette(false); }
    else { ensureFigurePalette(); updateFigurePaletteSelection(); }
    PAGES.forEach(p=>{ clearOverlay(p); drawSelection(p); });
  }
  function updateState(){
    const shapeLabel = tool===TOOLS.FIGURE
      ? ` ‚Ä¢ ${currentShape==='rect'?'Kwadrat':currentShape==='tri_iso'?'Tr√≥jkƒÖt':currentShape==='tri_right'?'Tr√≥jkƒÖt 90¬∞':currentShape==='hex'?'Sze≈õciokƒÖt':'Ko≈Ço'}`
      : '';
    stateEl.textContent = `Tryb: ${toolLabel()} ‚Ä¢ ${size}px ‚Ä¢ ${color}${shapeLabel}`;
    updateFigurePaletteSelection();
  }

  const toolsRow = document.getElementById('tools');
  toolsRow.addEventListener('pointerdown', (e)=>{
    const b = e.target.closest('[data-tool]'); if(!b) return;
    e.preventDefault();
    const toolName = b.getAttribute('data-tool');
    setTool(toolName);
    if(toolName===TOOLS.FIGURE){
      figureBtn = b;
      toggleFigurePalette(true);
    }else{
      toggleFigurePalette(false);
    }
  });
  document.addEventListener('pointerdown', (e)=>{
    const sh = e.target.closest('.figure-palette .shape-btn');
    if(!sh) return;
    e.preventDefault();
    e.stopPropagation();
    currentShape = sh.getAttribute('data-shape') || 'rect';
    updateFigurePaletteSelection();
    toggleFigurePalette(false);
    setTool(TOOLS.FIGURE);
    updateState();
  });
  document.addEventListener('pointerdown', (e)=>{
    if(e.target.closest('[data-tool="figure"]') || (figurePalette && figurePalette.contains(e.target))) return;
    toggleFigurePalette(false);
  });
  document.getElementById('color').addEventListener('input', e=>{ color=e.target.value; updateState(); });
  document.getElementById('size').addEventListener('change', e=>{ size=parseInt(e.target.value,10); updateState(); });

  window.addEventListener('keydown', (e)=>{
    if(e.key==='v'||e.key==='V') setTool(TOOLS.SELECT);
    if(e.key==='p'||e.key==='P') setTool(TOOLS.PEN);
    if(e.key==='l'||e.key==='L') setTool(TOOLS.LINE);
    if(e.key==='e'||e.key==='E') setTool(TOOLS.ERASER);
    if(e.key==='t'||e.key==='T') setTool(TOOLS.TEXT);
    if(e.key==='c'||e.key==='C') setTool(TOOLS.CROP);
    if(e.key==='f'||e.key==='F'){
      setTool(TOOLS.FIGURE);
      figureBtn = document.querySelector('[data-tool="figure"]');
      toggleFigurePalette(true);
    }
  });

  // MENU (po prawej)
  const menuBtn = document.getElementById('menuBtn');
  const dropdown = document.getElementById('dropdown');
  const openBoardModal = document.getElementById('openBoardModal');
  const openBoardBtn = document.getElementById('openBoardBtn');
  const openBoardInput = document.getElementById('openBoardName');
  const openBoardCancel = document.getElementById('openBoardCancel');
  const openBoardCreate = document.getElementById('openBoardCreate');

  function showOpenBoardModal(){
    if(!openBoardModal) return;
    openBoardModal.classList.add('open');
    openBoardModal.removeAttribute('aria-hidden');
    if(openBoardInput){
      openBoardInput.value='';
      setTimeout(()=> openBoardInput.focus(), 50);
    }
  }
  function hideOpenBoardModal(){
    if(!openBoardModal) return;
    openBoardModal.classList.remove('open');
    openBoardModal.setAttribute('aria-hidden','true');
  }
  function handleCreateBoard(){
    resetBoard();
    const page = createPage(true);
    if(openBoardInput){
      const label = openBoardInput.value.trim();
      if(label){ page.el.setAttribute('data-board-name', label); }
    }
    hideOpenBoardModal();
  }

  function toggleMenu(force){
    const open = typeof force==='boolean' ? force : !dropdown.classList.contains('open');
    dropdown.classList.toggle('open', open);
    menuBtn.setAttribute('aria-expanded', String(open));
  }
  menuBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); e.stopPropagation(); toggleMenu(); });
  document.addEventListener('pointerdown', (e)=>{ if(!dropdown.contains(e.target) && e.target!==menuBtn){ toggleMenu(false);} });

  dropdown.querySelectorAll('[data-grid]').forEach(btn=>{
    btn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      const val = btn.getAttribute('data-grid');
      if (val === 'tech'){
        gridSize = 'tech';
        PAGES.forEach(p=> drawTechGrid(p));
      } else {
        gridSize = parseInt(val,10)||0;
        PAGES.forEach(p=> drawGrid(p));
      }
      toggleMenu(false);
    });
  });
  if(openBoardBtn){
    openBoardBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); showOpenBoardModal(); toggleMenu(false); });
  }
  if(openBoardCancel){ openBoardCancel.addEventListener('click', hideOpenBoardModal); }
  if(openBoardCreate){ openBoardCreate.addEventListener('click', handleCreateBoard); }
  if(openBoardModal){
    openBoardModal.addEventListener('click', (e)=>{ if(e.target===openBoardModal){ hideOpenBoardModal(); } });
  }
  if(openBoardInput){
    openBoardInput.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){ e.preventDefault(); handleCreateBoard(); }
      if(e.key==='Escape'){ e.preventDefault(); hideOpenBoardModal(); }
    });
  }
  const saveToggle = document.getElementById('saveToggle');
  const saveRow = document.getElementById('saveRow');
  if(saveToggle && saveRow){
    saveToggle.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      saveRow.style.display = saveRow.style.display==='none' ? 'flex' : 'none';
    });
  }
  const templatesToggle = document.getElementById('templatesToggle');
  const gridToggle = document.getElementById('gridToggle');
  const templatesRow = document.getElementById('templatesRow');
  if(templatesToggle && gridToggle && templatesRow){
    templatesToggle.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      const showGrid = gridToggle.style.display==='none';
      gridToggle.style.display = showGrid ? 'block' : 'none';
      if(!showGrid){
        templatesRow.style.display = 'none';
      }
    });
    gridToggle.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      templatesRow.style.display = templatesRow.style.display==='none' ? 'flex' : 'none';
    });
  }
  const addPageBtn = document.getElementById('addPage');
  if(addPageBtn){ addPageBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); createPage(true); toggleMenu(false); }); }

  // EXPORT (aktualna strona)
  async function exportCurrent(ext){
    const p = currentPage(); if(!p) return;
    const c = await compositePageCanvas(p);
    if(ext==='png'){
      const a=document.createElement('a'); a.href=c.toDataURL('image/png'); a.download=ts('png'); a.click();
    }else if(ext==='jpg'){
      const a=document.createElement('a'); a.href=c.toDataURL('image/jpeg', .92); a.download=ts('jpg'); a.click();
    }else if(ext==='pdf'){
      const lib = window.jspdf?.jsPDF; if(!lib) return alert('PDF nieza≈Çadowany.');
      const dataUrl = c.toDataURL('image/png');
      const pdf = new lib({orientation:'portrait', unit:'pt', format:'a4'});
      const pw = pdf.internal.pageSize.getWidth(), ph = pdf.internal.pageSize.getHeight();
      const img = new Image();
      img.onload = ()=>{ const ratio = Math.min(pw/img.width, ph/img.height); const w = img.width*ratio, h = img.height*ratio; const x = (pw-w)/2, y=(ph-h)/2; pdf.addImage(dataUrl, 'PNG', x, y, w, h); pdf.save(ts('pdf')); };
      img.src = dataUrl;
    }
  }
  function ts(ext){ return `aliboard_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.${ext}`; }
  document.getElementById('savePng').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('png'); toggleMenu(false); });
  document.getElementById('saveJpg').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('jpg'); toggleMenu(false); });
  document.getElementById('savePdf').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('pdf'); toggleMenu(false); });

  // UNDO/REDO/CLEAR (aktualna strona)
  document.getElementById('undo').addEventListener('pointerdown', (e)=>{ e.preventDefault(); const p=currentPage(); if(!p || !p.state.history.length) return; const last = p.state.history.pop(); p.state.redo.push(snapshotState(p)); restoreHistoryState(p, last); });
  document.getElementById('clear').addEventListener('click', (e)=>{
    e.preventDefault();
    const p=currentPage(); if(!p) return;
    pushHistory(p);
    p.state.strokes=[];
    p.state.images=[];
    p.state.selection=null;
    renderAll(p);
    clearOverlay(p);
  });

  // WSTAW OBRAZ/PDF
  document.getElementById('imgInput').addEventListener('change', (e)=>{
    const f=e.target.files[0]; if(!f) return;
    const p=currentPage(); if(!p) return;
    const url = URL.createObjectURL(f);
    const temp = new Image();
    temp.onload = ()=>{ const rect=p.el.getBoundingClientRect(); const ratio = Math.min(rect.width/temp.width, rect.height/temp.height); const w = Math.max(80, temp.width*ratio), h=Math.max(80, temp.height*ratio); const x = (rect.width-w)/2, y=(rect.height-h)/2; addImageFromSrc(url, w, h, x, y, {file:true}, p); };
    temp.src=url; e.target.value='';
  });
  document.getElementById('pdfInput').addEventListener('change', async (e)=>{
    const f=e.target.files[0]; if(!f) return;
    const p=currentPage(); if(!p) return;
    const arrayBuffer = await f.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
    let pageNum = 1; const ask = prompt(`PDF ma ${pdf.numPages} stron. Wpisz numer strony do wstawienia:`, "1");
    if(ask){ const n=parseInt(ask,10); if(!isNaN(n)&&n>=1&&n<=pdf.numPages) pageNum=n; }
    const page = await pdf.getPage(pageNum);
    const viewport = page.getViewport({scale: 2});
    const c = document.createElement('canvas'); c.width=viewport.width; c.height=viewport.height;
    const cctx = c.getContext('2d'); await page.render({canvasContext:cctx, viewport}).promise;
    const url = c.toDataURL('image/png');
    const rect=p.el.getBoundingClientRect();
    const ratio = Math.min(rect.width/c.width, rect.height/c.height);
    theWidth = Math.max(120, c.width*ratio);
    theHeight=Math.max(120, c.height*ratio);
    const x = (rect.width-theWidth)/2, y=(rect.height-theHeight)/2;
    addImageFromSrc(url, theWidth, theHeight, x, y, {pdf:true,page:pageNum}, p);
    e.target.value='';
  });

  // AUTODODAWANIE KARTKI przy przewijaniu
  wrapEl.addEventListener('scroll', ()=>{
    const nearBottom = wrapEl.scrollTop + wrapEl.clientHeight >= wrapEl.scrollHeight - 80;
    if(nearBottom){
      createPage(false);
    }
  }, {passive:true});

  // AUTOSAVE wielostronicowy
  const AUTOSAVE_KEY='aliboard_v25_state';
  function autosave(){
    try{
      const payload = PAGES.map(p=>({ strokes:p.state.strokes, images: p.state.images.map(im=>({x:im.x,y:im.y,w:im.w,h:im.h,src:im.src,meta:im.meta})) }));
      localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(payload));
    }catch(_){}
  }
  setInterval(autosave, 30000);
  function restoreLocal(){
    try{
      const raw = localStorage.getItem(AUTOSAVE_KEY);
      if(!raw) return false;
      const arr = JSON.parse(raw); if(!Array.isArray(arr) || !arr.length) return false;
      arr.forEach((pageData)=>{ const p=createPage(false); p.state.strokes = pageData.strokes||[]; p.state.images  = (pageData.images||[]).map(im=>reviveImage(im,p)); renderAll(p); });
      return true;
    }catch(_){ return false; }
  }

  // [CODEX:BEGIN OVERFLOW_MENU]
  (function setupToolsOverflow(){
    const toolsRow = document.getElementById('tools');
    if(!toolsRow) return;
    console.debug('[ALIBOARD][overflow] init', {
      toolsRowExists: !!document.getElementById('tools'),
      headerExists: !!document.querySelector('header .left'),
    });

    // 1) Utw√≥rz przycisk ‚Äû‚ãØ‚Äù i panel overflow zaraz obok paska narzƒôdzi, je≈õli nie istniejƒÖ
    let moreBtn = document.getElementById('toolsMoreBtn');
    let moreBox = document.getElementById('toolsMorePanel');

    if(!moreBtn){
      moreBtn = document.createElement('button');
      moreBtn.id = 'toolsMoreBtn';
      moreBtn.className = 'btn';
      moreBtn.type = 'button';
      moreBtn.title = 'Wiƒôcej narzƒôdzi';
      moreBtn.textContent = '‚ãØ';
    toolsRow.appendChild(moreBtn);
    }
    if(!moreBox){
      moreBox = document.createElement('div');
      moreBox.id = 'toolsMorePanel';
      moreBox.className = 'dropdown';
      // otwieramy w lewo, obok paska narzƒôdzi
      moreBox.style.left = '0';
      moreBox.style.right = 'auto';
      moreBtn.insertAdjacentElement('afterend', moreBox);
    }

    // 2) Oznacz ‚Äûklejone‚Äù (nigdy nie przenoszone) narzƒôdzia ‚Äì rdze≈Ñ paska
    //    (mo≈ºesz dopasowaƒá listƒô; domy≈õlnie trzymamy: select, pen, line, eraser)
    const stickySelectors = [
      '[data-tool="select"]',
      '[data-tool="pen"]',
      '[data-tool="line"]',
      '[data-tool="eraser"]'
    ];
    const stickySet = new Set(
      stickySelectors
        .map(sel => toolsRow.querySelector(sel))
        .filter(Boolean)
    );

    // 3) Funkcja: przenie≈õ elementy z overflow z powrotem do g≈Ç√≥wnego rzƒôdu
    function restoreFromOverflow(){
      // przywr√≥ƒá wszystko co by≈Ço upchniƒôte
      [...moreBox.children].forEach(node => toolsRow.appendChild(node));
    }

    // 4) Funkcja: wylicz kt√≥re elementy trzeba schowaƒá do ‚Äû‚ãØ‚Äù, a≈º przestanie siƒô przelewaƒá
    function rebalanceTools(){
      if(!toolsRow) return;

      console.debug('[ALIBOARD][overflow] before', {
        clientWidth: toolsRow?.clientWidth,
        scrollWidth: toolsRow?.scrollWidth,
        childCount: toolsRow?.children?.length,
        moreBoxChildren: moreBox?.children?.length
      });

      while (moreBox.firstChild) toolsRow.appendChild(moreBox.firstChild);

      if (toolsRow.scrollWidth <= toolsRow.clientWidth) {
        moreBtn.style.display = 'none';
        moreBox.classList.remove('open');
        console.debug('[ALIBOARD][overflow] after', {
          clientWidth: toolsRow?.clientWidth,
          scrollWidth: toolsRow?.scrollWidth,
          childCount: toolsRow?.children?.length,
          moreBoxChildren: moreBox?.children?.length,
          moreBtnDisplay: moreBtn?.style?.display
        });
        return;
      }

      const essentialSel = [
        '[data-tool="select"]',
        '[data-tool="pen"]',
        '[data-tool="line"]',
        '[data-tool="eraser"]',
        '[data-tool="text"]',
        '[data-tool="crop"]'
      ].join(',');

      const children = [...toolsRow.children];
      const candidates = children
        .filter(el => !el.matches(essentialSel) && el !== moreBtn);

      for (let i = candidates.length - 1; i >= 0 && toolsRow.scrollWidth > toolsRow.clientWidth; i--){
        const el = candidates[i];
        moreBox.appendChild(el);
      }

      moreBtn.style.display = moreBox.children.length ? 'inline-flex' : 'none';

      console.debug('[ALIBOARD][overflow] after', {
        clientWidth: toolsRow?.clientWidth,
        scrollWidth: toolsRow?.scrollWidth,
        childCount: toolsRow?.children?.length,
        moreBoxChildren: moreBox?.children?.length,
        moreBtnDisplay: moreBtn?.style?.display
      });

      console.debug('[ALIBOARD][overflow] rebalanced', {
        clientWidth: toolsRow.clientWidth,
        scrollWidth: toolsRow.scrollWidth,
        moved: moreBox.children.length
      });
    }

    // 5) Toggling panelu overflow
    moreBtn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      moreBox.classList.toggle('open');
    });
    document.addEventListener('pointerdown', (e)=>{
      if(!moreBox.contains(e.target) && e.target !== moreBtn){
        moreBox.classList.remove('open');
      }
    });

    // 6) Rebalans po za≈Çadowaniu i na resize
    window.addEventListener('load', rebalanceTools, { once: true });
    window.addEventListener('resize', rebalanceTools);

    // 7) Obs≈Çuga ‚Äûtap‚Äù na elementach przeniesionych do overflow:
    //    delegujemy klikniƒôcia, ≈ºeby zachowa≈Çy siƒô identycznie jak w g≈Ç√≥wnym rzƒôdzie
    moreBox.addEventListener('pointerdown', (e)=>{
      const btn = e.target.closest('button, label');
      if(!btn) return;
      const toolTarget = btn.closest('[data-tool]');
      if(toolTarget){
        e.preventDefault();
        e.stopPropagation();
        const toolName = toolTarget.getAttribute('data-tool');
        setTool(toolName);
        if(toolName===TOOLS.FIGURE){
          figureBtn = toolTarget;
          toggleFigurePalette(true);
        }else{
          toggleFigurePalette(false);
        }
      }
      setTimeout(()=> moreBox.classList.remove('open'), 0);
    });

    // 8) Publiczny hook: gdyby co≈õ dynamicznie doda≈Ço narzƒôdzie ‚Äî spr√≥buj zbalansowaƒá ponownie
    const ro = new ResizeObserver(rebalanceTools);
    ro.observe(toolsRow);
    setTimeout(rebalanceTools, 250);
    setTimeout(rebalanceTools, 800);

  })();
  // [CODEX:END OVERFLOW_MENU]

  // START
  if(!restoreLocal()){ createPage(false); }
  setTool(TOOLS.SELECT);
})();
</script>
</body>
</html>
