{% load static %}
<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aliboard 2.5 — PolubiszTo.pl (test)</title>

<!-- PDF render -->
<link rel="preload" as="script" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js">
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<!-- PDF export (klient) -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>

<style>
  :root{
    --brand:#0b74ff; --ink:#0b1320; --muted:#5b6777; --line:#e6edff;
    --bg:#f7f9fe; --radius:16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{
    position:sticky; top:0; z-index:20; background:#fff; border-bottom:1px solid var(--line);
    display:flex; align-items:stretch; gap:12px; padding:10px 12px;
  }
  .left{ display:flex; flex-direction:column; gap:8px; min-width:260px; }
  .brand{display:flex;align-items:center;gap:10px}
  .brand .mark{width:40px;height:40px;border-radius:10px;display:grid;place-items:center;flex:0 0 auto;overflow:hidden}
  .brand .mark img{width:100%;height:100%;object-fit:contain}
  .state{font-size:12px;color:var(--muted)}
  .toolrow{
    display:flex;
    gap:8px;
    flex-wrap:nowrap;
    overflow:hidden !important;
    white-space:nowrap;
    align-items:center;
    padding-bottom:4px;
    position:relative;
  }
  .btn,.seg{border:1px solid var(--line);background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer;font-weight:700}
  .btn.primary{background:var(--brand);color:#fff;border-color:transparent}
  .btn.is-active{ outline:2px solid var(--brand); outline-offset:2px }
  .btn.is-disabled{ opacity:0.4; pointer-events:none; }
  .toolrow .btn[data-tool]{position:relative;font-size:0;}
  .toolrow .btn[data-tool]::before{
    content:'';
    font-size:18px;
    line-height:1;
    display:inline-block;
  }
  .toolrow .btn[data-tool="select"]::before{ content:"🖱️"; }
  .toolrow .btn[data-tool="pen"]::before{ content:"✏️"; }
  .toolrow .btn[data-tool="line"]::before{ content:"📏"; }
  .toolrow .btn[data-tool="eraser"]::before{ content:"🧽"; }
  .toolrow .btn[data-tool="text"]{font-size:16px;}
  .toolrow .btn[data-tool="text"]::before{ content:"T"; font-size:16px; font-weight:700; }
  .toolrow .btn[data-tool="crop"]::before{ content:"✂️"; }
  .toolrow .btn[data-tool="figure"]::before{ content:"⬛"; }
  .right{margin-left:auto; display:flex; align-items:flex-start;}
  .menu-wrap{position:relative}
  .menu-btn{display:inline-flex; align-items:center; gap:8px}
  .dropdown{
    position:absolute; right:0; top:calc(100% + 8px); min-width:240px;
    background:#fff; border:1px solid var(--line); border-radius:12px;
    box-shadow:0 12px 40px rgba(11,116,255,.12); padding:8px; display:none; z-index:30;
  }
  .dropdown.open{display:block}
  .drop-group{padding:6px 6px}
  .drop-title{font-size:12px; color:var(--muted); margin:4px 6px 6px}
  .drop-item{width:100%; text-align:left; background:#fff; border:1px solid var(--line);
    border-radius:10px; padding:8px 10px; cursor:pointer; margin:4px 0}
  .drop-row{display:flex; gap:6px; flex-wrap:wrap}
  .drop-item.primary{background:var(--brand);color:#fff;border-color:transparent}

  #toolsMoreBtn{
    display:none;
    align-items:center;
    justify-content:center;
    height:36px;
    padding:6px 10px;
    background:var(--brand);
    color:#fff;
    border:none;
    border-radius:10px;
    margin-left:8px;
  }

  #toolsMorePanel.dropdown{
    top:42px;
    right:0;
    left:auto;
    min-width:180px;
    z-index:50;
  }

  /* Obszar kartek */
  .wrap{
    height:calc(100% - 64px);
    overflow:auto;
    padding:16px;
    overscroll-behavior:contain;
    overflow-anchor:none;
    -webkit-overflow-scrolling:touch;
  }
  .pages{
    display:flex; flex-direction:column; align-items:center; gap:24px;
    overflow-anchor:none;
  }
  .page{
    position:relative; background:#fff; border:1px solid var(--line);
    border-radius:12px; box-shadow:0 8px 30px rgba(11,116,255,.10);
    width:min(1200px, 96vw); aspect-ratio: 1 / 1.4142; /* A4 portret */
    overflow:hidden;
  }
  .page canvas{ position:absolute; inset:0; width:100%; height:100%; }
  .page .grid, .page .overlay{ pointer-events:none; }
  .page .board{ touch-action:none; } /* blok gestów przy rysowaniu */

  /* edytor tekstu inline */
  .text-editor{
    position:absolute; z-index:50; min-width:60px;
    border:1px solid var(--line); border-radius:8px; padding:6px 8px; background:#fff;
    font: 16px ui-sans-serif, system-ui, Arial; color: var(--ink);
    outline: none; box-shadow:0 6px 20px rgba(15,23,42,.15);
  }

  /* ramka cropa */
  .crop-rect{
    position:absolute; z-index:40; border:2px dashed #0b74ff; background:rgba(11,116,255,.06); pointer-events:none;
  }
  .crop-choice-backdrop{
    position:fixed; inset:0; background:rgba(15,23,42,.45); display:flex; align-items:center; justify-content:center;
    z-index:70; opacity:0; transition:opacity .15s ease;
  }
  .crop-choice-backdrop.open{ opacity:1; }
  .crop-choice-dialog{
    background:#fff; border-radius:16px; padding:20px 24px; max-width:90vw; box-shadow:0 18px 55px rgba(15,23,42,.25);
    display:flex; flex-direction:column; gap:16px; min-width:280px;
  }
  .crop-choice-dialog p{ margin:0; font-size:15px; color:#0b1320; }
  .crop-choice-actions{ display:flex; gap:12px; flex-wrap:wrap; }
  .crop-choice-actions button{
    flex:1 1 120px; border:none; border-radius:10px; font-weight:600; padding:10px 14px; cursor:pointer;
  }
  .crop-choice-actions button.primary{ background:var(--brand); color:#fff; }
  .crop-choice-actions button.secondary{ background:#eef3ff; color:#0b1320; }
  .crop-busy-toast{
    position:fixed; top:16px; left:50%; transform:translate(-50%, -10px);
    background:#0b1320; color:#fff; padding:8px 16px; border-radius:999px;
    font-size:14px; box-shadow:0 10px 30px rgba(11,19,32,.35);
    z-index:80; pointer-events:none; opacity:0; transition:opacity .2s ease, transform .2s ease;
  }
  .crop-busy-toast.show{ opacity:1; transform:translate(-50%,0); }
  .modal-backdrop{
    position:fixed; inset:0; background:rgba(2,15,46,.55); display:none;
    align-items:center; justify-content:center; z-index:90;
  }
  .modal-backdrop.open{ display:flex; }
  .modal{
    background:#fff; border-radius:18px; padding:24px; width:min(420px, 92vw);
    box-shadow:0 25px 80px rgba(2,15,46,.35); display:flex; flex-direction:column; gap:16px;
  }
  .modal h3{ margin:0; font-size:20px; }
  .modal p{ margin:0; color:var(--muted); }
  .modal label{ display:flex; flex-direction:column; gap:6px; font-weight:600; }
  .modal input[type="text"]{
    border:1px solid var(--line); border-radius:10px; padding:10px 12px; font-size:15px;
  }
  .modal-actions{ display:flex; justify-content:flex-end; gap:12px; flex-wrap:wrap; }
  .modal-actions .btn{
    border:none; border-radius:10px; padding:10px 16px; font-weight:600; cursor:pointer;
  }
  .modal-actions .btn.secondary{ background:#eef3ff; color:#0b1320; }
  .modal-actions .btn.primary{ background:var(--brand); color:#fff; }

  .footer{ position:fixed; right:12px; bottom:12px; display:flex; gap:8px; flex-wrap:wrap; z-index:25; }

  /* mobile tap UX */
  .toolrow .btn { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

  /* === PATCH: delikatne, małe narzędzia bez “grubej ramki” === */
.toolrow .btn,
.toolrow label.btn{
  border:0 !important;
  box-shadow:none !important;
  background:transparent !important;
  padding:4px 6px !important;
  border-radius:8px !important;
}

.toolrow .btn:hover{
  background:rgba(11,116,255,0.08) !important;
}

.toolrow .btn.is-active{
  background:rgba(11,116,255,0.18) !important;
  color:var(--ink) !important;
  outline:none !important;
}

.toolrow .btn:focus-visible{
  outline:1px solid var(--brand) !important;
  outline-offset:2px !important;
}

.toolrow .btn input[type="color"],
.toolrow .btn select{
  border:0 !important;
  background:transparent !important;
  box-shadow:none !important;
}
.text-font-btn{ display:none; }
.text-font-btn.is-visible{ display:inline-flex; }

/* === ALIBOARD: Ikona wielkości czcionki (estetyczna) === */
#textFontBtn{
  font-size:20px !important;
  padding:4px 6px !important;
  line-height:1;
}

/* ciaśniejszy pasek narzędzi na telefonie */
@media (max-width: 900px){
  .toolrow{
    gap:4px;
  }
  .toolrow .btn{
    padding:4px 4px !important;
  }
}

/* Mini-paleta figur */
.figure-palette{
  position:absolute; z-index:26; background:#fff; border:1px solid var(--line);
  border-radius:12px; box-shadow:0 12px 40px rgba(11,116,255,.12); padding:8px; display:none;
}
.figure-palette.open{ display:block; }
.figure-palette .shape-btn{
  display:inline-flex; align-items:center; justify-content:center;
  width:44px; height:36px; margin:4px; border:1px solid var(--line);
  border-radius:10px; background:#fff; cursor:pointer; font-weight:700;
}
.figure-palette .shape-btn.is-active{
  outline:2px solid var(--brand); outline-offset:2px;
}
@media (max-width:900px){
  .figure-palette{ transform:translateY(6px); }
}

/* === FIX: przywrócenie widoczności ikon narzędzi Aliboard === */
.toolrow .btn[data-tool]{
  font-size:18px !important;
  line-height:1;
}
.toolrow .btn[data-tool]::before{
  content:none !important;
}

/* 🔹 Aliboard Chat – bazowe zmienne */
:root{
  --aliboard-chat-bg: rgba(9, 18, 40, 0.96);
  --aliboard-chat-accent: #0b74ff;
  --aliboard-chat-accent-soft: rgba(11, 116, 255, 0.25);
  --aliboard-chat-border: rgba(255, 255, 255, 0.12);
  --aliboard-chat-text: #f9fbff;
  --aliboard-chat-muted: #a5b3d1;
}
.aliboard-chat-root{
  position:fixed;
  right:16px;
  bottom:16px;
  z-index:9999;
}
.aliboard-chat-bubble{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:46px;
  height:46px;
  position:relative;
  border-radius:999px;
  border:none;
  cursor:pointer;
  background:transparent;
  box-shadow:none;
  font-size:24px;
  transition:transform 0.15s ease-out, box-shadow 0.15s ease-out, opacity 0.15s ease-out;
  color:#fff;
}
.aliboard-chat-bubble:hover{
  transform:translateY(-1px) scale(1.03);
  box-shadow:none;
}
.aliboard-chat-bubble:active{
  transform:translateY(0) scale(0.97);
  box-shadow:none;
}
.aliboard-chat-panel{
  position:fixed;
  right:16px;
  bottom:76px;
  width:320px;
  max-height:60vh;
  display:flex;
  flex-direction:column;
  background:var(--aliboard-chat-bg);
  border-radius:18px;
  border:1px solid var(--aliboard-chat-border);
  box-shadow:0 18px 50px rgba(0,0,0,0.6);
  overflow:hidden;
  opacity:0;
  transform:translateY(12px) scale(0.96);
  pointer-events:none;
  transition:opacity 0.16s ease-out, transform 0.16s ease-out;
}
.aliboard-chat-panel.is-open{
  opacity:1;
  transform:translateY(0) scale(1);
  pointer-events:auto;
}
.aliboard-chat-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 12px 8px;
  background:linear-gradient(135deg, rgba(11,116,255,0.28), rgba(11,116,255,0.02));
  border-bottom:1px solid var(--aliboard-chat-border);
}
.aliboard-chat-title{
  display:flex;
  flex-direction:column;
}
.aliboard-chat-title-main{
  font-size:13px;
  font-weight:600;
  color:var(--aliboard-chat-text);
}
.aliboard-chat-title-sub{
  font-size:11px;
  color:var(--aliboard-chat-muted);
}
.aliboard-chat-actions{
  display:inline-flex;
  align-items:center;
  gap:4px;
}
.aliboard-chat-icon-btn{
  border:none;
  background:transparent;
  color:var(--aliboard-chat-text);
  cursor:pointer;
  border-radius:999px;
  width:28px;
  height:28px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-size:14px;
  transition:background 0.12s ease-out, transform 0.08s ease-out;
}
.aliboard-chat-icon-btn:hover{
  background:rgba(255,255,255,0.09);
}
.aliboard-chat-icon-btn:active{
  transform:scale(0.92);
}
.aliboard-chat-messages,
#aliboard-chat-messages{
  flex:1;
  padding:8px 8px 6px;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  gap:4px;
  overflow-y:auto;
  scrollbar-width:thin;
  scrollbar-color:rgba(255,255,255,0.22) transparent;
}
.aliboard-chat-messages::-webkit-scrollbar{
  width:6px;
}
.aliboard-chat-messages::-webkit-scrollbar-track{
  background:transparent;
}
.aliboard-chat-messages::-webkit-scrollbar-thumb{
  background:rgba(255,255,255,0.22);
  border-radius:999px;
}
.aliboard-chat-message{
  max-width:80%;
  padding:6px 10px;
  border-radius:12px;
  font-size:13px;
  line-height:1.35;
  display:inline-block;
  align-self:flex-start;
  word-wrap:break-word;
  white-space:pre-wrap;
}
/* JA -> po PRAWEJ */
.aliboard-chat-message.me{
  align-self:flex-end;
  background:#0b74ff;
  color:#fff;
}
/* DRUGA OSOBA -> po LEWEJ */
.aliboard-chat-message.other{
  align-self:flex-start;
  background:rgba(15,23,42,0.85);
  color:#fff;
  border:1px solid #344155;
}
.aliboard-chat-meta{
  display:block;
  margin-top:2px;
  font-size:10px;
  color:var(--aliboard-chat-muted);
}
.aliboard-chat-input-row{
  display:flex;
  align-items:center;
  gap:6px;
  padding:6px 8px 8px;
  border-top:1px solid var(--aliboard-chat-border);
  background:rgba(7,12,25,0.98);
}
.aliboard-chat-input{
  flex:1;
  border-radius:999px;
  border:1px solid rgba(148,163,184,0.6);
  padding:6px 10px;
  font-size:12px;
  background:rgba(15,23,42,0.7);
  color:var(--aliboard-chat-text);
  outline:none;
}
.aliboard-chat-input::placeholder{
  color:var(--aliboard-chat-muted);
}
.aliboard-chat-input:focus{
  border-color:var(--aliboard-chat-accent);
  box-shadow:0 0 0 1px var(--aliboard-chat-accent-soft);
}
.aliboard-chat-send-btn{
  border:none;
  border-radius:999px;
  padding:6px 10px;
  font-size:11px;
  font-weight:500;
  background:var(--aliboard-chat-accent);
  color:#fff;
  cursor:pointer;
  transition:transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.08s ease-out;
  white-space:nowrap;
}
.aliboard-chat-send-btn:hover{
  box-shadow:0 8px 20px rgba(0,0,0,0.45);
}
.aliboard-chat-send-btn:active{
  transform:scale(0.94);
  box-shadow:none;
}
.aliboard-call-banner{
  padding:6px 10px;
  font-size:12px;
  background:rgba(34,197,94,0.16);
  color:#bbf7d0;
  border-bottom:1px solid rgba(34,197,94,0.5);
  display:flex;
  align-items:center;
  gap:8px;
}
.aliboard-call-actions{
  margin-left:auto;
  display:flex;
  align-items:center;
  gap:4px;
}
.aliboard-call-accept-btn,
.aliboard-call-end-btn{
  padding:4px 8px;
  border-radius:6px;
  border:1px solid transparent;
  font-size:11px;
  cursor:pointer;
  transition:background 0.15s ease-out, transform 0.1s ease-out;
}
.aliboard-call-accept-btn{
  background:rgba(34,197,94,0.3);
  border-color:rgba(34,197,94,0.6);
  color:#bbf7d0;
}
.aliboard-call-accept-btn:hover{
  background:rgba(34,197,94,0.5);
}
.aliboard-call-end-btn{
  background:rgba(239,68,68,0.25);
  border-color:rgba(239,68,68,0.5);
  color:#fecaca;
}
.aliboard-call-end-btn:hover{
  background:rgba(239,68,68,0.4);
}
.aliboard-call-accept-btn:active,
.aliboard-call-end-btn:active{
  transform:scale(0.95);
}
.aliboard-chat-badge{
  position:absolute;
  top:-4px;
  right:-4px;
  min-width:16px;
  height:16px;
  padding:0 4px;
  border-radius:999px;
  background:#ef4444;
  color:#fff;
  font-size:10px;
  font-weight:600;
  display:flex;
  align-items:center;
  justify-content:center;
}
.aliboard-chat-badge-hidden{
  display:none;
}
.aliboard-chat-icon-btn.is-muted{
  background:rgba(239,68,68,0.2);
  color:#fecaca;
}
@media (max-width:768px){
  .aliboard-chat-root{
    right:10px;
    bottom:10px;
  }
  .aliboard-chat-panel{
    right:0;
    left:0;
    bottom:0;
    margin:0 auto;
    width:100%;
    max-width:100%;
    max-height:60vh;
    border-radius:18px 18px 0 0;
  }
}

/* === ALIBOARD: wyraźne podświetlenie aktywnego narzędzia === */
.toolrow .btn[data-tool].is-active{
  background: rgba(11,116,255,0.14) !important;
  color: #0b1320 !important;
  outline: none !important;
  border-radius: 10px;
  box-shadow: 0 0 0 2px var(--brand);
}

/* nieaktywne ikony delikatnie przygaszone, żeby aktywne się wyróżniało */
.toolrow .btn[data-tool]:not(.is-active){
  opacity: 0.8;
}
.toolrow .btn[data-tool]:not(.is-active):hover{
  opacity: 1;
}

/* === ALIBOARD: układ nagłówka + narzędzi na telefonie === */
@media (max-width: 768px){

  /* nagłówek nadal w jednym rzędzie:
     [logo+Aliboard] po lewej, [Menu] po prawej */
  header{
    flex-direction: row;
    align-items: flex-start;
    gap: 8px;
  }

  /* lewa część (logo + pasek narzędzi) może się ścisnąć */
  .left{
    flex: 1 1 auto;
    min-width: 0;
  }

  /* prawa część – menu przy logo po prawej */
  .right{
    margin-left: 8px;
    flex: 0 0 auto;
  }

  .menu-wrap{
    flex-shrink: 0;
  }

  .menu-btn{
    padding: 6px 10px;
    font-size: 13px;
  }

  /* pasek narzędzi POD logo, może zejść w 2 rzędy */
  .toolrow{
    flex-wrap: wrap;
    overflow: visible !important;
    justify-content: flex-start;
    margin-top: 4px;
    gap: 4px;
  }

  /* wszystkie narzędzia mają być widoczne – wyłączamy „⋯” na telefonie */
  #toolsMoreBtn,
  #toolsMorePanel{
    display: none !important;
  }

  /* ciaśniejsze przyciski, żeby wszystko się mieściło */
  .toolrow .btn,
  .toolrow label.btn{
    padding: 4px 6px;
    font-size: 16px;
  }

  /* select z grubością – trochę węższy */
  .toolrow label.btn select{
    max-width: 72px;
  }
}

/* === ALIBOARD: Ikona przycisku Usuń (zaznaczony element) === */
#deleteSelection{
  font-size:18px !important;
  padding:4px 6px !important;
  line-height:1;
}

/* === ALIBOARD: przycisk "Grubość linii" – tylko ikona ↕️, select ukryty === */
.toolrow label[title="Grubość linii"]{
  position:relative;
  padding:6px 8px;
}
.toolrow label[title="Grubość linii"] select{
  position:absolute !important;
  inset:0;
  opacity:0;
  width:100% !important;
  height:100% !important;
  margin:0 !important;
  padding:0 !important;
  border:0 !important;
  background:transparent !important;
  box-shadow:none !important;
  pointer-events:auto;
}

/* Ikony obrazkowe w pasku narzędzi */
.icon-img{
  width:26px;
  height:26px;
  object-fit:contain;
  display:block;
  pointer-events:none;
}
.aliboard-chat-bubble .icon-img{
  width:78px;
  height:78px;
}

</style>
</head>
<body id="aliboard-root" data-room-id="{{ room_id|default:'local-test' }}" data-user-id="{{ request.user.id }}" data-user-role="{{ user_role|default:'unknown' }}">
<header>
  <!-- LEWA: brand + narzędzia -->
  <div class="left">
    <div class="brand">
      <div class="mark">
        <!-- Sama głowa loga -->
        <img src="{% static 'img/brand/logo_head.png' %}" alt="PolubiszTo.pl" />
      </div>
      <div>
        <div style="font-weight:800">Aliboard</div>
        <div class="state" id="state">Tryb: Kursor • 3px • #0b74ff</div>
      </div>
    </div>

    <div class="toolrow" id="tools">
      <button class="btn" type="button" data-tool="select" title="Kursor (V)">
        <img src="{% static 'img/icons/cursor_ai.png' %}" class="icon-img" alt="Kursor">
      </button>
      <button class="btn" type="button" data-tool="pen"    title="Ołówek (P)">
        <img src="{% static 'img/icons/pen_ai.png' %}" class="icon-img" alt="Ołówek">
      </button>
      <button class="btn" type="button" data-tool="line"   title="Linia (L)">
        <img src="{% static 'img/icons/line_ai.png' %}" class="icon-img" alt="Linia">
      </button>
      <button class="btn" type="button" data-tool="eraser" title="Gumka (E)">
        <img src="{% static 'img/icons/eraser_ai.png' %}" class="icon-img" alt="Gumka">
      </button>
      <button class="btn" type="button" data-tool="text"   title="Tekst (T)">
        <img src="{% static 'img/icons/text_ai.png' %}" class="icon-img" alt="Tekst">
      </button>
      <button class="btn text-font-btn" type="button" id="textFontBtn" title="Wielkość czcionki" data-overflow="1">
        <img src="{% static 'img/icons/font_size_ai.png' %}" class="icon-img" alt="Wielkość czcionki">
      </button>
      <button class="btn" type="button" data-tool="crop"   title="Kopiuj (C)">
        <img src="{% static 'img/icons/copy_ai.png' %}" class="icon-img" alt="Kopiuj">
      </button>
      <button class="btn" type="button" data-tool="figure" title="Figury (F)" data-overflow="1">
        <img src="{% static 'img/icons/figure_ai.png' %}" class="icon-img" alt="Figury">
      </button>

      <label class="btn" title="Kolor pisaka">
        <img src="{% static 'img/icons/color_ai.png' %}" class="icon-img" alt="Kolor">
        <input type="color" id="color" value="#0b74ff" style="display:none;">
      </label>
      <label class="btn" title="Grubość linii">
        <img src="{% static 'img/icons/size_ai.png' %}" class="icon-img" alt="Grubość linii">
        <select id="size" style="display:none;">
          <option value="1">1px</option>
          <option value="3" selected>3px</option>
          <option value="5">5px</option>
          <option value="8">8px</option>
        </select>
      </label>

      <!-- Ikony: obraz + pdf -->
      <label class="btn" title="Wstaw obraz">
        <img src="{% static 'img/icons/image_ai.png' %}" class="icon-img" alt="Wstaw obraz">
        <input id="imgInput" type="file" accept="image/*" style="display:none">
      </label>
      <label class="btn" title="Wstaw PDF">
        <img src="{% static 'img/icons/pdf_ai.png' %}" class="icon-img" alt="Wstaw PDF">
        <input id="pdfInput" type="file" accept="application/pdf" style="display:none">
      </label>

      <button class="btn is-disabled" type="button" id="deleteSelection" title="Usuń zaznaczony obiekt" disabled>
        ❌
      </button>
    </div>
  </div>

  <!-- PRAWA: MENU -->
  <div class="right">
    <div class="menu-wrap">
      <button class="btn primary menu-btn" type="button" id="menuBtn" aria-expanded="false" aria-controls="dropdown">☰ Menu</button>
      <div class="dropdown" id="dropdown" role="menu" aria-labelledby="menuBtn">
        <div class="drop-group">
          <a href="{% url 'aliboard_new_room' %}" target="_blank" class="drop-item primary btn-aliboard" id="openBoardBtn">
            Nowa Tablica
          </a>
        </div>
        <div class="drop-group">
          <button class="drop-item" type="button" id="undo" title="Cofnij (Ctrl+Z)">Cofnij</button>
        </div>
        <div class="drop-group">
          <button class="drop-item primary" type="button" id="saveToggle">Zapisz</button>
          <div class="drop-row" id="saveRow" style="display:none">
            <button class="drop-item" type="button" id="savePng">💾 PNG</button>
            <button class="drop-item" type="button" id="saveJpg">🖼️ JPG</button>
            <button class="drop-item" type="button" id="savePdf">📄 PDF</button>
          </div>
        </div>
        <div class="drop-group">
          <button class="drop-item" type="button" id="templatesToggle">Szablony</button>
          <button class="drop-item" type="button" id="gridToggle" style="display:none">Siatka</button>
          <div class="drop-row" id="templatesRow" style="display:none">
            <button class="drop-item" type="button" data-grid="0">Brak</button>
            <button class="drop-item" type="button" data-grid="16">Mała</button>
            <button class="drop-item" type="button" data-grid="24">Średnia</button>
            <button class="drop-item" type="button" data-grid="32">Duża</button>
            <button class="drop-item" type="button" data-grid="tech">Papier milimetrowy</button>
          </div>
        </div>
        <div class="drop-group">
          <div class="drop-title">Nowa tablica</div>
          <div class="drop-row">
            <button class="drop-item" type="button" id="addPage">➕ Dodaj kartkę A4</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="wrap" id="wrap">
  <div class="pages" id="pages"></div>
</div>

<!-- 🔹 Aliboard Chat Module -->
<div class="aliboard-chat-root">
  <button class="aliboard-chat-bubble" id="aliboard-chat-bubble" type="button" aria-label="Otwórz czat">
    <img src="{% static 'img/icons/chat_ai.png' %}" class="icon-img" alt="Czat">
  </button>

  <section class="aliboard-chat-panel" id="aliboard-chat-panel" aria-hidden="true">
    <header class="aliboard-chat-header">
      <div class="aliboard-chat-title">
        <span class="aliboard-chat-title-main">Czat zajęć</span>
        <span class="aliboard-chat-title-sub">Aliboard</span>
      </div>
      <div class="aliboard-chat-actions">
        <button type="button" class="aliboard-chat-icon-btn" id="aliboard-chat-ping" title="Zaczep">
          🔔
        </button>
        <button type="button" class="aliboard-chat-icon-btn" id="aliboard-chat-call" title="Rozmowa głosowa">
          📞
        </button>
        <button type="button" class="aliboard-chat-icon-btn" id="aliboard-chat-mic" title="Wycisz/odcisz mikrofon">
          🎙️
        </button>
        <button type="button" class="aliboard-chat-icon-btn" id="aliboard-chat-close" title="Zamknij czat">
          ✕
        </button>
      </div>
    </header>

    <!-- 🔹 Audio remote dla WebRTC -->
    <audio id="aliboard-remote-audio" autoplay playsinline style="display:none;"></audio>

    <div class="aliboard-chat-messages" id="aliboard-chat-messages" aria-live="polite"></div>

    <form class="aliboard-chat-input-row" id="aliboard-chat-form" autocomplete="off">
      <input
        type="text"
        id="aliboard-chat-input"
        class="aliboard-chat-input"
        placeholder="Napisz wiadomość…"
        maxlength="500"
      />
      <button type="submit" class="aliboard-chat-send-btn">
        Wyślij
      </button>
    </form>
  </section>
</div>
<!-- 🔹 koniec: Aliboard Chat Module -->

<div class="footer">
  <a href="{% url 'pokoj_testowy' %}" class="btn">← Powrót do Pokoju Testowego</a>
  <span class="btn" id="roomInfo" title="Room ID z query string">room_id: {{ room_id|default:'local-test' }}</span>
</div>

<div class="modal-backdrop" id="openBoardModal" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="openBoardTitle">
    <h3 id="openBoardTitle">Otwórz nową tablicę</h3>
    <p>Utwórz pustą tablicę. Aktualne karty zostaną zamknięte.</p>
    <label>
      Nazwa tablicy (opcjonalnie)
      <input type="text" id="openBoardName" placeholder="np. Matematyka - lekcja 3">
    </label>
    <div class="modal-actions">
      <button type="button" class="btn secondary" id="openBoardCancel">Anuluj</button>
      <button type="button" class="btn primary" id="openBoardCreate">Utwórz</button>
    </div>
  </div>
</div>

<script>
(function(){
  /* === PATCH: wstrzyknięcie delikatnego CSS dla paska narzędzi (bez kapsli) === */
  const __css = `
  .toolrow .btn, .toolrow label.btn{border:0 !important;background:transparent !important;box-shadow:none !important}
  .toolrow .btn.is-active{background:transparent !important;color:var(--ink) !important;outline:2px solid var(--brand);outline-offset:2px;border-radius:10px}
  .toolrow .btn:focus-visible{outline:2px solid var(--brand);outline-offset:2px}
  .toolrow .btn input[type="color"], .toolrow .btn select{border:0 !important;background:transparent !important;box-shadow:none !important}
  @media (max-width: 900px){ .toolrow{gap:4px} .toolrow .btn{padding:6px 8px} }`;
  const styleEl = document.createElement('style'); styleEl.textContent = __css; document.head.appendChild(styleEl);

  /* ---------- STAN GLOBALNY ---------- */
  const wrapEl  = document.getElementById('wrap');
  const pagesEl = document.getElementById('pages');
  const stateEl = document.getElementById('state');
  let figureBtn = document.querySelector('[data-tool="figure"]');
  let figurePalette = null;
  let selectionRotateEnabled = false;
  const textFontBtn = document.getElementById('textFontBtn');
  const deleteSelectionBtn = document.getElementById('deleteSelection');
  let textFontPanel = null;
  let textFontRange = null;
  let textFontValueEl = null;
  const TEXT_FONT_MIN = 14;
  const TEXT_FONT_MAX = 96;
  const TEXT_FONT_STEP = 2;

  function ensureFigurePalette(){
    if(figurePalette) return;
    figurePalette = document.createElement('div');
    figurePalette.className = 'figure-palette';
    figurePalette.innerHTML = `
      <button class="shape-btn" data-shape="rect" title="Kwadrat / Prostokąt">▭</button>
      <button class="shape-btn" data-shape="tri_iso" title="Trójkąt (równoramienny)">▵</button>
      <button class="shape-btn" data-shape="tri_right" title="Trójkąt prostokątny">◺</button>
      <button class="shape-btn" data-shape="hex" title="Sześciokąt">⬡</button>
      <button class="shape-btn" data-shape="circle" title="Koło">◯</button>
    `;
    document.body.appendChild(figurePalette);
    updateFigurePaletteSelection();
  }

  function positionFigurePalette(){
    const btn = document.querySelector('[data-tool="figure"]');
    if(btn) figureBtn = btn;
    if(!figureBtn || !figurePalette) return;
    const r = figureBtn.getBoundingClientRect();
    figurePalette.style.left = r.left + 'px';
    figurePalette.style.top  = (r.bottom + 8) + 'px';
  }

  function updateFigurePaletteSelection(){
    if(!figurePalette) return;
    figurePalette.querySelectorAll('.shape-btn').forEach(b=>{
      b.classList.toggle('is-active', b.getAttribute('data-shape')===currentShape);
    });
  }

  function toggleFigurePalette(forceOpen){
    const open = (typeof forceOpen==='boolean') ? forceOpen : !figurePalette?.classList.contains('open');
    if(open){
      ensureFigurePalette();
      positionFigurePalette();
      figurePalette.classList.add('open');
    }else if(figurePalette){
      figurePalette.classList.remove('open');
    }
  }

  const TOOLS = { SELECT:'select', PEN:'pen', LINE:'line', ERASER:'eraser', TEXT:'text', CROP:'crop', FIGURE:'figure' };
  let tool = TOOLS.SELECT, color = '#0b74ff', size = 3, gridSize = 0;
  let textFontSizePx = Math.max(TEXT_FONT_MIN, size*6);
  let lastBrushSize = size;
  let currentShape = 'rect';

  /* ---------- TEKST: ROZMIAR CZCIONKI ---------- */
  function clampTextFont(px){
    return Math.max(TEXT_FONT_MIN, Math.min(TEXT_FONT_MAX, px));
  }
  function updateTextFontUI(){
    if(textFontValueEl){ textFontValueEl.textContent = `${Math.round(textFontSizePx)} px`; }
    if(textFontRange){ textFontRange.value = Math.round(textFontSizePx); }
  }
  function ensureTextFontPanel(){
    if(textFontPanel) return;
    textFontPanel = document.createElement('div');
    textFontPanel.className = 'text-font-panel';
    textFontPanel.innerHTML = `
      <div class="text-font-panel__header">Wielkość czcionki</div>
      <div class="text-font-panel__value" data-font-display>24 px</div>
      <input type="range" class="text-font-panel__range" min="${TEXT_FONT_MIN}" max="${TEXT_FONT_MAX}" step="${TEXT_FONT_STEP}">
      <div class="text-font-panel__actions">
        <button type="button" data-step="-${TEXT_FONT_STEP}">–</button>
        <button type="button" data-step="${TEXT_FONT_STEP}">+</button>
      </div>
    `;
    document.body.appendChild(textFontPanel);
    textFontRange = textFontPanel.querySelector('.text-font-panel__range');
    textFontValueEl = textFontPanel.querySelector('[data-font-display]');
    if(textFontRange){
      textFontRange.addEventListener('input', ()=>{ setTextFontPx(parseInt(textFontRange.value,10)); });
    }
    textFontPanel.querySelectorAll('[data-step]').forEach(btn=>{
      btn.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        const delta = parseInt(btn.getAttribute('data-step'),10) || 0;
        setTextFontPx(textFontSizePx + delta);
      });
    });
    updateTextFontUI();
  }
  function positionTextFontPanel(){
    if(!textFontBtn || !textFontPanel) return;
    const r = textFontBtn.getBoundingClientRect();
    textFontPanel.style.left = `${r.left}px`;
    textFontPanel.style.top = `${r.bottom + 8}px`;
  }
  function toggleTextFontPanel(force){
    if(!textFontBtn) return;
    ensureTextFontPanel();
    const open = typeof force==='boolean' ? force : !textFontPanel.classList.contains('open');
    if(open && tool===TOOLS.TEXT){
      positionTextFontPanel();
      updateTextFontUI();
      textFontPanel.classList.add('open');
    }else if(textFontPanel){
      textFontPanel.classList.remove('open');
      if(textFontBtn){ textFontBtn.classList.remove('is-active'); }
    }
  }
  function setTextFontPx(px){
    textFontSizePx = clampTextFont(px);
    if(tool===TOOLS.TEXT){
      size = Math.max(1, textFontSizePx / 6);
    }
    updateTextFontUI();
    updateState();
  }
  function handleTextToolToggle(previousTool){
    const isText = tool===TOOLS.TEXT;
    if(textFontBtn){
      textFontBtn.classList.toggle('is-visible', isText);
      if(!isText){
        textFontBtn.classList.remove('is-active');
      }
    }
    if(isText){
      if(previousTool!==TOOLS.TEXT){
        lastBrushSize = size;
        size = Math.max(1, textFontSizePx / 6);
      }
      updateTextFontUI();
    }else if(previousTool===TOOLS.TEXT){
      textFontSizePx = clampTextFont(textFontSizePx);
      size = lastBrushSize;
      toggleTextFontPanel(false);
    }
  }
  function updateDeleteButtonState(pageOverride){
    if(!deleteSelectionBtn) return;
    const target = pageOverride || currentPage();
    const hasSelection = Boolean(target && target.state.selection);
    deleteSelectionBtn.disabled = !hasSelection;
    deleteSelectionBtn.classList.toggle('is-disabled', !hasSelection);
  }
  function deleteCurrentSelection(){
    const p = currentPage();
    if(!p || !p.state.selection) return;
    const sel = p.state.selection;
    pushHistory(p);
    if(sel.kind==='image' && p.state.images[sel.index]){
      const removedImage = p.state.images.splice(sel.index,1)[0];
      if(removedImage?.id){ emitElementRemove(removedImage.id); }
    }else if(sel.kind==='stroke' && p.state.strokes[sel.index]){
      const removed = p.state.strokes.splice(sel.index,1)[0];
      if(removed?.id){ emitElementRemove(removed.id); }
    }
    p.state.selection = null;
    renderAll(p);
    clearOverlay(p);
    updateDeleteButtonState(p);
  }

  /* ---------- SYNC (WebSocket) ---------- */
  function ensurePageForPatch(index){
    if(typeof index!=='number' || index<0){
      return currentPage();
    }
    while(PAGES.length <= index){
      createPage(false);
    }
    return PAGES[index];
  }

  function resetBoardForSnapshot(){
    while(PAGES.length){ PAGES.pop(); }
    pagesEl.innerHTML = '';
    createPage(false);
    setTool(TOOLS.SELECT);
    updateDeleteButtonState();
  }
  window.aliboardResetBoardForSnapshot = resetBoardForSnapshot;

  function getPageRef(pageIndex){
    if(typeof pageIndex==='number' && pageIndex>=0){
      return PAGES[pageIndex];
    }
    return currentPage();
  }

  function getPageDimensions(page){
    const rect = page?.el?.getBoundingClientRect();
    let width = rect?.width;
    let height = rect?.height;
    if(!Number.isFinite(width) || width<=0){ width = page?.el?.offsetWidth || page?.drawC?.clientWidth || 1; }
    if(!Number.isFinite(height) || height<=0){ height = page?.el?.offsetHeight || page?.drawC?.clientHeight || 1; }
    return { width, height };
  }

  function toRelativePoint(pt, dims){
    if(!pt || !dims) return null;
    const x = Number(pt.x ?? pt[0]);
    const y = Number(pt.y ?? pt[1]);
    if(!Number.isFinite(x) || !Number.isFinite(y)) return null;
    return {
      x: dims.width ? x / dims.width : 0,
      y: dims.height ? y / dims.height : 0
    };
  }

  function fromRelativePoint(pt, dims){
    if(!pt || !dims) return null;
    const x = Number(pt.x ?? pt[0]);
    const y = Number(pt.y ?? pt[1]);
    if(!Number.isFinite(x) || !Number.isFinite(y)) return null;
    return {
      x: x * dims.width,
      y: y * dims.height
    };
  }

  function newElementId(){
    if(window.crypto?.randomUUID){ return window.crypto.randomUUID(); }
    return 'el_' + Date.now().toString(36) + Math.random().toString(36).slice(2,10);
  }

  function getPageRef(pageIndex){
    if(typeof pageIndex==='number' && pageIndex>=0){
      return PAGES[pageIndex];
    }
    return currentPage();
  }

  function getPageDimensions(page){
    const rect = page?.el?.getBoundingClientRect();
    let width = rect?.width;
    let height = rect?.height;
    if(!Number.isFinite(width) || width<=0){ width = page?.drawC?.width || 1; }
    if(!Number.isFinite(height) || height<=0){ height = page?.drawC?.height || 1; }
    return { width, height };
  }

  function toRelativePoint(pt, dims){
    if(!pt || !dims) return null;
    const x = Number(pt.x ?? pt[0]);
    const y = Number(pt.y ?? pt[1]);
    if(!Number.isFinite(x) || !Number.isFinite(y)) return null;
    return {
      x: dims.width ? x / dims.width : 0,
      y: dims.height ? y / dims.height : 0
    };
  }

  function fromRelativePoint(pt, dims){
    if(!pt || !dims) return null;
    const x = Number(pt.x ?? pt[0]);
    const y = Number(pt.y ?? pt[1]);
    if(!Number.isFinite(x) || !Number.isFinite(y)) return null;
    return {
      x: x * dims.width,
      y: y * dims.height
    };
  }

  function serializeStrokeElement(stroke, pageIndex){
    if(!stroke) return null;
    const page = getPageRef(pageIndex);
    if(!page) return null;
    const dims = getPageDimensions(page);
    const tool = stroke.type || stroke.tool || 'pen';
    const base = {
      id: stroke.id || newElementId(),
      tool,
      pageIndex,
      color: stroke.color || '#0b74ff',
      size: stroke.size || stroke.width || 3
    };
    if(tool==='pen'){
      const pts = (stroke.points || []).map(pt=>toRelativePoint(pt, dims)).filter(Boolean);
      if(pts.length<2) return null;
      base.points = pts;
    }else if(tool==='line'){
      if(!stroke.a || !stroke.b) return null;
      const relA = toRelativePoint(stroke.a, dims);
      const relB = toRelativePoint(stroke.b, dims);
      if(!relA || !relB) return null;
      base.a = relA;
      base.b = relB;
    }else if(tool==='poly'){
      const pts = (stroke.points || []).map(pt=>toRelativePoint(pt, dims)).filter(Boolean);
      if(pts.length<2) return null;
      base.points = pts;
      if(stroke.closed) base.closed = true;
    }else if(tool==='text'){
      const rel = toRelativePoint({x: stroke.x, y: stroke.y}, dims);
      if(!rel) return null;
      base.text = stroke.text || '';
      base.x = rel.x;
      base.y = rel.y;
    }else{
      return null;
    }
    stroke.id = base.id;
    return base;
  }

  function serializeImageElement(image, pageIndex){
    if(!image) return null;
    const page = getPageRef(pageIndex);
    if(!page) return null;
    const dims = getPageDimensions(page);
    return {
      id: image.id || newElementId(),
      tool: 'image',
      pageIndex,
      x: dims.width ? (image.x || 0) / dims.width : 0,
      y: dims.height ? (image.y || 0) / dims.height : 0,
      w: dims.width ? (image.w || 0) / dims.width : 0,
      h: dims.height ? (image.h || 0) / dims.height : 0,
      src: image.src,
      meta: image.meta || null
    };
  }

  function applyElementAddPayload(element){
    if(!element || !element.id) return;
    const tool = element.tool || element.type || 'pen';
    const page = ensurePageForPatch(element.pageIndex) || currentPage();
    if(!page) return;
    const dims = getPageDimensions(page);
    if(tool==='pen'){
      const mapped = (element.points || []).map(pt=>fromRelativePoint(pt, dims)).filter(Boolean);
      if(mapped.length<2) return;
      page.state.strokes.push({
        id: element.id,
        type:'pen',
        color: element.color || '#0b74ff',
        size: element.size || 3,
        points: mapped
      });
    }else if(tool==='line'){
      const a = fromRelativePoint(element.a, dims);
      const b = fromRelativePoint(element.b, dims);
      if(!a || !b) return;
      page.state.strokes.push({
        id: element.id,
        type:'line',
        color: element.color || '#0b74ff',
        size: element.size || 3,
        a,
        b
      });
    }else if(tool==='poly'){
      const mapped = (element.points || []).map(pt=>fromRelativePoint(pt, dims)).filter(Boolean);
      if(mapped.length<2) return;
      page.state.strokes.push({
        id: element.id,
        type:'poly',
        color: element.color || '#0b74ff',
        size: element.size || 3,
        points: mapped,
        closed: Boolean(element.closed)
      });
    }else if(tool==='text'){
      const rel = fromRelativePoint({x: element.x, y: element.y}, dims);
      if(!rel) return;
      page.state.strokes.push({
        id: element.id,
        type:'text',
        color: element.color || '#0b74ff',
        size: element.size || 3,
        x: rel.x,
        y: rel.y,
        text: element.text || ''
      });
    }else if(tool==='image'){
      const relPos = fromRelativePoint({x: element.x, y: element.y}, dims);
      const relSize = fromRelativePoint({x: element.w, y: element.h}, dims);
      const revived = reviveImage({
        id: element.id,
        src: element.src,
        w: relSize?.x ?? 0,
        h: relSize?.y ?? 0,
        x: relPos?.x ?? 0,
        y: relPos?.y ?? 0,
        meta: element.meta
      }, page);
      page.state.images.push(revived);
    }else{
      return;
    }
    renderAll(page);
    if(page.state.selection){ drawSelection(page); }
  }

  function applySnapshotElements(elements){
    resetBoardForSnapshot();
    if(Array.isArray(elements) && elements.length){
      elements.forEach(applyElementAddPayload);
    }else if(boardHasElements()){
      syncBoardStateToServer();
    }
  }

  function boardHasElements(){
    return PAGES.some(page => (page.state.strokes && page.state.strokes.length) || (page.state.images && page.state.images.length));
  }

  function removeElementById(id){
    if(!id) return;
    PAGES.forEach((page)=>{
      const beforeStrokes = page.state.strokes.length;
      page.state.strokes = page.state.strokes.filter(st=>st.id!==id);
      const beforeImages = page.state.images.length;
      page.state.images = page.state.images.filter(im=>im.id!==id);
      if(page.state.strokes.length!==beforeStrokes || page.state.images.length!==beforeImages){
        renderAll(page);
        if(page.state.selection){ drawSelection(page); }
      }
    });
  }

  function emitElementAddFromStroke(stroke, pageIndex){
    const realtime = window.AliboardRealtime;
    if(!realtime || typeof realtime.broadcastElementAdd!=='function') return;
    const payload = serializeStrokeElement(stroke, pageIndex);
    if(!payload) return;
    realtime.broadcastElementAdd(payload);
  }

  function emitElementRemove(id){
    if(!id) return;
    const realtime = window.AliboardRealtime;
    if(!realtime || typeof realtime.broadcastElementRemove!=='function') return;
    realtime.broadcastElementRemove(id);
  }

  function emitImageElementAdd(image, pageIndex){
    if(!image) return;
    const realtime = window.AliboardRealtime;
    if(!realtime || typeof realtime.broadcastElementAdd!=='function') return;
    const payload = serializeImageElement(image, pageIndex);
    if(!payload) return;
    image.id = payload.id;
    realtime.broadcastElementAdd(payload);
  }

  function syncBoardStateToServer(){
    const realtime = window.AliboardRealtime;
    if(!realtime) return;
    PAGES.forEach((page, pageIndex)=>{
      (page.state.strokes||[]).forEach(st=>{
        const payload = serializeStrokeElement(st, pageIndex);
        if(payload){
          if(typeof realtime.broadcastElementUpdate === 'function'){
            realtime.broadcastElementUpdate(payload);
          }else{
            realtime.broadcastElementAdd(payload);
          }
        }
      });
      (page.state.images||[]).forEach(im=>{
        const payload = serializeImageElement(im, pageIndex);
        if(payload){
          if(typeof realtime.broadcastElementUpdate === 'function'){
            realtime.broadcastElementUpdate(payload);
          }else{
            realtime.broadcastElementAdd(payload);
          }
        }
      });
    });
  }

  function initRealtimeBridge(){
    const realtime = window.AliboardRealtime;
    if(!realtime || typeof realtime.on!=='function'){
      setTimeout(initRealtimeBridge, 600);
      return;
    }
    realtime.on('snapshot', applySnapshotElements);
    realtime.on('open', ()=>{
      if(boardHasElements()){
        syncBoardStateToServer();
      }
    });
    realtime.on('element_add', applyElementAddPayload);
    realtime.on('element_update', (element)=>{
      if(!element || !element.id) return;
      removeElementById(element.id);
      applyElementAddPayload(element);
    });
    realtime.on('element_remove', (payload)=>{
      const id = typeof payload === 'string' ? payload : payload?.id;
      removeElementById(id);
    });
    realtime.on('cursor', (cursor)=>{
      if(cursor && cursor.id !== realtime.clientId){
        window.aliboardUpdateRemoteCursor(cursor);
      }
    });
  }

  window.aliboardUpdateRemoteCursor = (function(){
    const layer = document.createElement('div');
    layer.id = 'aliboardCursorLayer';
    layer.style.position = 'fixed';
    layer.style.left = '0';
    layer.style.top = '0';
    layer.style.width = '100%';
    layer.style.height = '100%';
    layer.style.pointerEvents = 'none';
    layer.style.zIndex = '80';
    document.body.appendChild(layer);

    const cursorMap = new Map();
    const ttlMap = new Map();

    function removeCursor(id){
      const el = cursorMap.get(id);
      if(el){
        el.remove();
        cursorMap.delete(id);
      }
      if(ttlMap.has(id)){
        clearTimeout(ttlMap.get(id));
        ttlMap.delete(id);
      }
    }

    function scheduleRemoval(id){
      if(ttlMap.has(id)){
        clearTimeout(ttlMap.get(id));
      }
      ttlMap.set(id, setTimeout(()=> removeCursor(id), 5000));
    }

    function createCursorEl(color, label){
      const wrapper = document.createElement('div');
      wrapper.className = 'cursor-ghost';
      wrapper.style.position = 'absolute';
      wrapper.style.transform = 'translate(-50%, -50%)';
      wrapper.style.pointerEvents = 'none';

      const dot = document.createElement('div');
      dot.style.width = '10px';
      dot.style.height = '10px';
      dot.style.borderRadius = '50%';
      dot.style.background = color || '#3b82f6';
      dot.style.border = '2px solid #fff';
      dot.style.boxShadow = '0 2px 6px rgba(0,0,0,.25)';

      const tag = document.createElement('div');
      tag.textContent = label || 'Uczestnik';
      tag.style.background = color || '#3b82f6';
      tag.style.color = '#fff';
      tag.style.fontSize = '11px';
      tag.style.padding = '2px 6px';
      tag.style.borderRadius = '999px';
      tag.style.marginTop = '6px';
      tag.style.whiteSpace = 'nowrap';
      tag.style.boxShadow = '0 2px 6px rgba(0,0,0,.2)';

      wrapper.appendChild(dot);
      wrapper.appendChild(tag);
      layer.appendChild(wrapper);
      return wrapper;
    }

    return function updateCursor(cursor){
      if(!cursor) return;
      const pageIdx = typeof cursor.pageIndex === 'number' ? cursor.pageIndex : -1;
      const targetPage = pageIdx >=0 ? PAGES[pageIdx] : currentPage();
      if(!targetPage){
        removeCursor(cursor.id);
        return;
      }
      const rect = targetPage.el.getBoundingClientRect();
      const relX = Number(cursor.x ?? 0);
      const relY = Number(cursor.y ?? 0);
      const posX = rect.left + Math.max(0, Math.min(1, relX)) * rect.width;
      const posY = rect.top + Math.max(0, Math.min(1, relY)) * rect.height;

      let el = cursorMap.get(cursor.id);
      if(!el){
        el = createCursorEl(cursor.color, cursor.label);
        cursorMap.set(cursor.id, el);
      }else{
        el.querySelector('div:last-child').textContent = cursor.label || 'Uczestnik';
        el.querySelector('div:first-child').style.background = cursor.color || '#3b82f6';
        el.querySelector('div:last-child').style.background = cursor.color || '#3b82f6';
      }
      el.style.left = `${posX}px`;
      el.style.top = `${posY}px`;
      scheduleRemoval(cursor.id);
    };
  })();

  pagesEl.addEventListener('pointermove', (e)=>{
    const realtime = window.AliboardRealtime;
    if(!realtime || typeof realtime.sendCursor !== 'function') return;
    const boardCanvas = e.target.closest('.board');
    if(!boardCanvas) return;
    const pageEl = boardCanvas.closest('.page');
    if(!pageEl) return;
    const pageIndex = PAGES.findIndex(pg=>pg.el===pageEl);
    if(pageIndex<0) return;
    const rect = pageEl.getBoundingClientRect();
    const relX = (e.clientX - rect.left) / rect.width;
    const relY = (e.clientY - rect.top) / rect.height;
    realtime.sendCursor({
      pageIndex,
      x: Math.max(0, Math.min(1, relX)),
      y: Math.max(0, Math.min(1, relY))
    });
  });
  initRealtimeBridge();

  // ---- USTALENIE roomId (wspólne z realtime) ----
  let roomId = null;

  // 1) jeśli już ktoś ustawił globalnie (np. inny skrypt / Django):
  if (window.ALIBOARD_ROOM_ID) {
    roomId = window.ALIBOARD_ROOM_ID;
  }

  // 2) jeśli nie ma – spróbuj odczytać z data-room-id na kontenerze tablicy
  if (!roomId) {
    const rootEl =
      document.getElementById('aliboard-root') ||
      document.querySelector('[data-room-id]');
    if (rootEl && rootEl.dataset.roomId) {
      roomId = rootEl.dataset.roomId;
    }
  }

  // 3) jeśli nadal brak – spróbuj z query stringa (?room= / ?room_id=)
  if (!roomId) {
    const qs = new URLSearchParams(location.search);
    roomId = qs.get('room') || qs.get('room_id') || 'local-test';
  }

  // 4) zapisz globalnie (dla aliboard_realtime.js i innych)
  window.ALIBOARD_ROOM_ID = roomId;

  // info w stopce
  const roomInfoEl = document.getElementById('roomInfo');
  if (roomInfoEl) roomInfoEl.textContent = 'room_id: ' + roomId;

  console.log('[Aliboard] roomId =', roomId);

  /* ---------- MODEL STRONY ---------- */
  function makeEmptyPageState(){
    return { strokes: [], images: [], history: [], redo: [], selection: null, dragging: null };
  }
  const PAGES = [];
  function currentPage(){ return PAGES[PAGES.length-1] || null; }

  /* ---------- TWORZENIE STRONY ---------- */
  function createPage(scrollTo=true){
    const page = document.createElement('div');
    page.className = 'page';

    const gridC = document.createElement('canvas'); gridC.className='grid';
    const drawC = document.createElement('canvas'); drawC.className='board';
    const ovlC  = document.createElement('canvas'); ovlC.className='overlay';

    page.appendChild(gridC); page.appendChild(drawC); page.appendChild(ovlC);
    pagesEl.appendChild(page);

    const g   = gridC.getContext('2d');
    const ctx = drawC.getContext('2d');
    const ovl = ovlC.getContext('2d');

    const p = { el:page, gridC, drawC, ovlC, g, ctx, ovl, state: makeEmptyPageState() };
    PAGES.push(p);
    resizePage(p);
    refreshGrid(p);
    renderAll(p);
    bindPage(p);
    if(scrollTo) page.scrollIntoView({behavior:'smooth', block:'center'});
    return p;
  }

  /* ---------- ROZMIAR I SIATKA ---------- */
  function resizePage(p){
    const rect = p.el.getBoundingClientRect();
    const dpr  = window.devicePixelRatio || 1;
    [p.gridC, p.drawC, p.ovlC].forEach(c=>{
      c.width  = Math.floor(rect.width * dpr);
      c.height = Math.floor(rect.height * dpr);
      c.style.width  = rect.width + 'px';
      c.style.height = rect.height + 'px';
      const c2d = c.getContext('2d');
      c2d.setTransform(dpr,0,0,dpr,0,0);
    });
  }
  function drawGrid(p){
    const dpr = window.devicePixelRatio || 1;
    const w = p.gridC.width / dpr, h = p.gridC.height / dpr;
    p.g.clearRect(0,0,w,h);
    if(!gridSize) return;
    p.g.save(); p.g.strokeStyle='#e6edff'; p.g.lineWidth=1;
    for(let x=0;x<=w;x+=gridSize){ p.g.beginPath(); p.g.moveTo(x,0); p.g.lineTo(x,h); p.g.stroke(); }
    for(let y=0;y<=h;y+=gridSize){ p.g.beginPath(); p.g.moveTo(0,y); p.g.lineTo(w,y); p.g.stroke(); }
    p.g.restore();
  }

  // --- SYNC GRID: handler dla realtime (wywoływany z AliboardRealtime) ---
  window.aliboardApplyGridState = function(newGridState){
    const isObj = newGridState && typeof newGridState === 'object';
    const kind = isObj ? newGridState.kind : null;
    const valRaw = isObj ? (newGridState.gridSize ?? newGridState.size) : newGridState;
    const isTech = kind === 'tech';
    const parsedSize = isTech
      ? 'tech'
      : (typeof valRaw === 'number' ? valRaw : parseInt(valRaw,10) || 0);
    gridSize = parsedSize;
    PAGES.forEach(p => {
      if(isTech){ drawTechGrid(p); }
      else { drawGrid(p); }
    });
  };
  function drawTechGrid(p){
    const dpr = window.devicePixelRatio || 1;
    const w = p.gridC.width / dpr, h = p.gridC.height / dpr;
    drawTechPattern(p.g, w, h);
  }
  function drawTechPattern(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    ctx.save();
    const thin = '#e0e6f0';
    const mid  = '#b5c0d4';
    const bold = '#7f8ba1';
    const step = 8;
    ctx.strokeStyle = thin;
    ctx.lineWidth = 0.5;
    for (let x = 0; x <= w; x += step/2){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y <= h; y += step/2){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
    ctx.strokeStyle = mid;
    ctx.lineWidth = 1;
    for (let x = 0; x <= w; x += step*5){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y <= h; y += step*5){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
    ctx.strokeStyle = bold;
    ctx.lineWidth = 1.2;
    for (let x = 0; x <= w; x += step*10){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y <= h; y += step*10){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
    ctx.restore();
  }
  function refreshGrid(p){
    if(gridSize==='tech'){ drawTechGrid(p); }
    else{ drawGrid(p); }
  }
  function resetBoard(){
    PAGES.forEach(p=> p.el.remove());
    PAGES.length = 0;
    pagesEl.innerHTML = '';
  }
  window.addEventListener('resize', ()=>{
    PAGES.forEach(p=>{ resizePage(p); refreshGrid(p); renderAll(p); drawSelection(p); });
    if(textFontPanel?.classList.contains('open')){ positionTextFontPanel(); }
  });

  /* ---------- RENDER ---------- */
  function renderAll(p){
    const dpr = window.devicePixelRatio || 1;
    const w = p.drawC.width / dpr, h = p.drawC.height / dpr;
    p.ctx.clearRect(0,0,w,h);

    for(const im of p.state.images){ if(im.img) p.ctx.drawImage(im.img, im.x, im.y, im.w, im.h); }

    p.ctx.lineCap='round'; p.ctx.lineJoin='round';
    for(const s of p.state.strokes){
      if(s.type==='pen'){
        p.ctx.strokeStyle=s.color; p.ctx.lineWidth=s.size;
        const pts=s.points; if(!pts.length) continue;
        p.ctx.beginPath(); p.ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){ p.ctx.lineTo(pts[i].x, pts[i].y); }
        p.ctx.stroke();
      }else if(s.type==='line'){
        p.ctx.strokeStyle=s.color; p.ctx.lineWidth=s.size;
        p.ctx.beginPath(); p.ctx.moveTo(s.a.x,s.a.y); p.ctx.lineTo(s.b.x,s.b.y); p.ctx.stroke();
      }else if(s.type==='text'){
        p.ctx.save(); p.ctx.fillStyle=s.color;
        p.ctx.font = `${Math.max(14, s.size*6)}px ui-sans-serif, system-ui, Arial`;
        p.ctx.textBaseline='top'; p.ctx.fillText(s.text, s.x, s.y); p.ctx.restore();
      }else if(s.type==='poly'){
        p.ctx.save();
        p.ctx.strokeStyle = s.color;
        p.ctx.lineWidth   = s.size;
        p.ctx.lineCap = 'round';
        p.ctx.lineJoin = 'round';
        if(s.points && s.points.length){
          p.ctx.beginPath();
          p.ctx.moveTo(s.points[0].x, s.points[0].y);
          for(let i=1;i<s.points.length;i++){
            p.ctx.lineTo(s.points[i].x, s.points[i].y);
          }
          if(s.closed){ p.ctx.closePath(); }
          p.ctx.stroke();
        }
        p.ctx.restore();
      }
    }
  }

  /* ---------- OBRAZY ---------- */
  function reviveImage(im, p){
    const obj = {id: im.id || newElementId(), x:im.x,y:im.y,w:im.w,h:im.h,src:im.src,meta:im.meta, img:null};
    const el = new Image();
    el.onload = ()=>{ obj.img = el; renderAll(p); };
    el.src = im.src;
    return obj;
  }
  function addImageFromSrc(src, w, h, x, y, meta, p, opts){
    pushHistory(p);
    const options = opts || {};
    const im = reviveImage({id: options.id, src,w,h,x,y,meta}, p);
    p.state.images.push(im);
    renderAll(p);
    if(!options.silent){
      emitImageElementAdd(im, PAGES.indexOf(p));
    }
  }

  /* ---------- HISTORIA ---------- */
  function snapshotState(p){
    return JSON.stringify({
      strokes: p.state.strokes,
      images: p.state.images.map(im=>({id: im.id, x:im.x,y:im.y,w:im.w,h:im.h,src:im.src,meta:im.meta}))
    });
  }
  function ensureStrokeIds(p){
    (p.state.strokes || []).forEach(st=>{ if(!st.id) st.id = newElementId(); });
  }
  function pushHistory(p){ p.state.redo=[]; try{ p.state.history.push(snapshotState(p)); if(p.state.history.length>100) p.state.history.shift(); }catch(_){} }
  function restoreHistoryState(p, json){
    try{
      const s = JSON.parse(json);
      p.state.strokes = s.strokes||[];
      ensureStrokeIds(p);
      p.state.images  = (s.images||[]).map(im=>reviveImage(im, p));
      renderAll(p); drawSelection(p);
    }catch(_){}
  }

  /* ---------- SELEKCJA I TRANSFORMACJE ---------- */
  const HANDLE_SIZE=10;
  function clearOverlay(p){ p.ovl.clearRect(0,0, p.ovlC.width, p.ovlC.height); }
  function drawPolyPreview(p, pts){
    clearOverlay(p);
    if(p.state.selection) drawSelection(p);
    if(!pts || pts.length<2) return;
    p.ovl.save();
    p.ovl.strokeStyle = color;
    p.ovl.lineWidth = Math.max(1, size);
    p.ovl.setLineDash([6,4]);
    p.ovl.beginPath();
    p.ovl.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length;i++){ p.ovl.lineTo(pts[i].x, pts[i].y); }
    p.ovl.closePath();
    p.ovl.stroke();
    p.ovl.restore();
  }
  function bboxStroke(s){
    if(s.type==='pen'){
      const xs=s.points.map(p=>p.x), ys=s.points.map(p=>p.y);
      const minx=Math.min(...xs), maxx=Math.max(...xs), miny=Math.min(...ys), maxy=Math.max(...ys);
      return {x:minx,y:miny,w:maxx-minx,h:maxy-miny};
    }else if(s.type==='line'){
      const minx=Math.min(s.a.x,s.b.x), maxx=Math.max(s.a.x,s.b.x);
      const miny=Math.min(s.a.y,s.b.y), maxy=Math.max(s.a.y,s.b.y);
      return {x:minx,y:miny,w:maxx-minx,h:maxy-miny};
    }else if(s.type==='text'){
      const w = (Math.max(14, s.size*6)*0.6)*(s.text?.length||0);
      const h = Math.max(14, s.size*6);
      return {x:s.x, y:s.y, w, h};
    }else if(s.type==='poly'){
      if(!s.points || !s.points.length) return {x:0,y:0,w:0,h:0};
      const xs = s.points.map(pt=>pt.x);
      const ys = s.points.map(pt=>pt.y);
      const minx = Math.min(...xs), maxx = Math.max(...xs);
      const miny = Math.min(...ys), maxy = Math.max(...ys);
      return {x:minx, y:miny, w:maxx-minx, h:maxy-miny};
    }
    return {x:0,y:0,w:0,h:0};
  }
  function drawSelection(p){
    clearOverlay(p);
    const sel = p.state.selection;
    updateDeleteButtonState(p);
    selectionRotateEnabled = false;
    if(!sel) return;
    const b = sel.bbox;
    const canRotate = sel.kind==='stroke' && p.state.strokes[sel.index]?.type==='poly';
    selectionRotateEnabled = canRotate;
    p.ovl.save();
    p.ovl.strokeStyle = '#0b74ff'; p.ovl.lineWidth = 1.5;
    p.ovl.setLineDash([6,4]); p.ovl.strokeRect(b.x, b.y, b.w, b.h); p.ovl.setLineDash([]);
    const hs = HANDLE_SIZE, pts = handlePoints(b);
    p.ovl.fillStyle='#fff'; p.ovl.strokeStyle='#0b74ff'; p.ovl.lineWidth=2;
    for(const h of pts){ p.ovl.beginPath(); p.ovl.rect(h.x-hs/2, h.y-hs/2, hs, hs); p.ovl.fill(); p.ovl.stroke(); }
    if(canRotate){
      const rotate={x:b.x+b.w/2,y:b.y-30};
      p.ovl.beginPath();
      p.ovl.moveTo(b.x+b.w/2,b.y);
      p.ovl.lineTo(rotate.x, rotate.y);
      p.ovl.stroke();
      p.ovl.beginPath();
      p.ovl.arc(rotate.x, rotate.y, hs/1.5, 0, Math.PI*2);
      p.ovl.fill();
      p.ovl.stroke();
    }
    p.ovl.restore();
  }
  function handlePoints(b){
    const cx=b.x+b.w/2, cy=b.y+b.h/2;
    return [
      {x:b.x, y:b.y}, {x:cx, y:b.y}, {x:b.x+b.w, y:b.y},
      {x:b.x, y:cy},                 {x:b.x+b.w, y:cy},
      {x:b.x, y:b.y+b.h}, {x:cx, y:b.y+b.h}, {x:b.x+b.w, y:b.y+b.h},
    ];
  }
  function hitHandle(pxy, b){
    const hs=HANDLE_SIZE, pts=handlePoints(b);
    for(let i=0;i<pts.length;i++){
      if(Math.abs(pxy.x-pts[i].x)<=hs && Math.abs(pxy.y-pts[i].y)<=hs) return i;
    }
    if(selectionRotateEnabled){
      const rotate = {x:b.x+b.w/2, y:b.y-30};
      if(Math.hypot(pxy.x-rotate.x, pxy.y-rotate.y)<=hs) return ROTATE_HANDLE;
    }
    return -1;
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function distToSegment(p, a, b){
    const ABx=b.x-a.x, ABy=b.y-a.y, APx=p.x-a.x, APy=p.y-a.y;
    const ab2=ABx*ABx+ABy*ABy; const t=ab2?Math.max(0,Math.min(1,(APx*ABx+APy*ABy)/ab2)):0;
    const proj={x:a.x+t*ABx,y:a.y+t*ABy}; return dist(p,proj);
  }
  function hitPolyline(pts, pxy, eps){ for(let i=1;i<pts.length;i++){ if(distToSegment(pxy, pts[i-1], pts[i])<=eps) return true;} return false; }
  function hitTest(pxy, p){
    for(let i=p.state.images.length-1;i>=0;i--){
      const im=p.state.images[i];
      if(pxy.x>=im.x && pxy.x<=im.x+im.w && pxy.y>=im.y && pxy.y<=im.y+im.h){
        return {kind:'image', index:i, bbox:{x:im.x,y:im.y,w:im.w,h:im.h}};
      }
    }
    const eps = Math.max(6, size*2);
    for(let i=p.state.strokes.length-1;i>=0;i--){
      const s=p.state.strokes[i];
      if(s.type==='pen'){ if(hitPolyline(s.points,pxy,eps)) return {kind:'stroke',index:i,bbox:bboxStroke(s)}; }
      else if(s.type==='line'){ if(distToSegment(pxy,s.a,s.b)<=eps) return {kind:'stroke',index:i,bbox:bboxStroke(s)}; }
      else if(s.type==='text'){
        const b=bboxStroke(s);
        if(pxy.x>=b.x&&pxy.x<=b.x+b.w&&pxy.y>=b.y&&pxy.y<=b.y+b.h) return {kind:'stroke',index:i,bbox:b};
      }else if(s.type==='poly'){
        if(s.points && hitPolyline(s.points, pxy, eps)){
          return {kind:'stroke', index:i, bbox:bboxStroke(s)};
        }
      }
    }
    return null;
  }

  const HANDLE_MIN_SIZE = 12;
  function cloneStrokeState(stroke){
    if(!stroke) return null;
    if(stroke.type==='pen'){
      return {
        type:stroke.type,
        color:stroke.color,
        size:stroke.size,
        points: stroke.points.map(pt=>({x:pt.x, y:pt.y}))
      };
    }
    if(stroke.type==='line'){
      return {
        type:stroke.type,
        color:stroke.color,
        size:stroke.size,
        a:{...stroke.a},
        b:{...stroke.b}
      };
    }
    if(stroke.type==='text'){
      return {...stroke};
    }
    if(stroke.type==='poly'){
      return {
        type:stroke.type,
        color:stroke.color,
        size:stroke.size,
        points: stroke.points ? stroke.points.map(pt=>({x:pt.x,y:pt.y})) : [],
        closed: stroke.closed
      };
    }
    return null;
  }
  function cloneImageState(im){
    if(!im) return null;
    return {x:im.x, y:im.y, w:im.w, h:im.h, meta:im.meta};
  }
  function computeScaledBBox(startBBox, handle, x, y){
    let left = startBBox.x;
    let right = startBBox.x + startBBox.w;
    let top = startBBox.y;
    let bottom = startBBox.y + startBBox.h;
    switch(handle){
      case 0: left = x; top = y; break;
      case 1: top = y; break;
      case 2: right = x; top = y; break;
      case 3: left = x; break;
      case 4: right = x; break;
      case 5: left = x; bottom = y; break;
      case 6: bottom = y; break;
      case 7: right = x; bottom = y; break;
    }
    const moveLeft   = (handle===0||handle===3||handle===5);
    const moveRight  = (handle===2||handle===4||handle===7);
    const moveTop    = (handle===0||handle===1||handle===2);
    const moveBottom = (handle===5||handle===6||handle===7);
    if(right - left < HANDLE_MIN_SIZE){
      if(moveLeft) left = right - HANDLE_MIN_SIZE;
      else if(moveRight) right = left + HANDLE_MIN_SIZE;
    }
    if(bottom - top < HANDLE_MIN_SIZE){
      if(moveTop) top = bottom - HANDLE_MIN_SIZE;
      else if(moveBottom) bottom = top + HANDLE_MIN_SIZE;
    }
    const width = Math.max(HANDLE_MIN_SIZE, right - left);
    const height = Math.max(HANDLE_MIN_SIZE, bottom - top);
    return { x:left, y:top, w:width, h:height };
  }
  function scalePointRelative(pt, startBBox, nextBBox){
    const rx = startBBox.w ? (pt.x - startBBox.x) / startBBox.w : 0;
    const ry = startBBox.h ? (pt.y - startBBox.y) / startBBox.h : 0;
    return {
      x: nextBBox.x + rx * nextBBox.w,
      y: nextBBox.y + ry * nextBBox.h
    };
  }
  function computeScaleFactor(startBBox, nextBBox){
    const vals = [];
    if(startBBox.w) vals.push(Math.abs(nextBBox.w / startBBox.w));
    if(startBBox.h) vals.push(Math.abs(nextBBox.h / startBBox.h));
    if(!vals.length) return 1;
    const avg = vals.reduce((a,b)=>a+b,0) / vals.length;
    return avg || 1;
  }
  function applyScaledSelection(sel, drag, nextBBox, p){
    if(sel.kind==='image'){
      const im = p.state.images[sel.index];
      if(!im) return;
      im.x = nextBBox.x;
      im.y = nextBBox.y;
      im.w = Math.max(1, nextBBox.w);
      im.h = Math.max(1, nextBBox.h);
      return;
    }
    const stroke = p.state.strokes[sel.index];
    const original = drag.original;
    if(!stroke || !original) return;
    if(stroke.type==='pen'){
      stroke.points = original.points.map(pt=>scalePointRelative(pt, drag.startBBox, nextBBox));
    }else if(stroke.type==='line'){
      stroke.a = scalePointRelative(original.a, drag.startBBox, nextBBox);
      stroke.b = scalePointRelative(original.b, drag.startBBox, nextBBox);
    }else if(stroke.type==='text'){
      const mapped = scalePointRelative({x:original.x, y:original.y}, drag.startBBox, nextBBox);
      stroke.x = mapped.x;
      stroke.y = mapped.y;
    }else if(stroke.type==='poly'){
      stroke.points = (original.points||[]).map(pt=>scalePointRelative(pt, drag.startBBox, nextBBox));
    }
    const factor = computeScaleFactor(drag.startBBox, nextBBox);
    if(stroke.type==='pen' || stroke.type==='line'){
      stroke.size = Math.max(0.5, original.size * factor);
    }else if(stroke.type==='text'){
      stroke.size = Math.max(1, original.size * factor);
    }
  }

  /* ---------- GUMKA PODŚWIETLA ---------- */
  function previewErase(pt, p){
    clearOverlay(p); if(p.state.selection) drawSelection(p);
    const eps = Math.max(6,size*2);
    for(let i=p.state.strokes.length-1;i>=0;i--){
      const s=p.state.strokes[i]; let hit=false;
      if(s.type==='pen') hit=hitPolyline(s.points,pt,eps);
      else if(s.type==='line') hit=distToSegment(pt,s.a,s.b)<=eps;
      else if(s.type==='text'){ const b=bboxStroke(s); hit=(pt.x>=b.x&&pt.x<=b.x+b.w&&pt.y>=b.y&&pt.y<=b.y+b.h); }
      else if(s.type==='poly'){ hit = s.points && hitPolyline(s.points, pt, eps); }
      if(hit){
        p.ovl.save(); p.ovl.lineCap='round'; p.ovl.lineJoin='round';
        if(s.type==='pen'){
          const pts=s.points; if(!pts.length){ p.ovl.restore();return; }
          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2);
          p.ovl.beginPath(); p.ovl.moveTo(pts[0].x, pts[0].y);
          for(let j=1;j<pts.length;j++){ p.ovl.lineTo(pts[j].x, pts[j].y); }
          p.ovl.stroke();
        }else if(s.type==='line'){
          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2);
          p.ovl.beginPath(); p.ovl.moveTo(s.a.x,s.a.y); p.ovl.lineTo(s.b.x,s.b.y); p.ovl.stroke();
        }else if(s.type==='text'){
          const b=bboxStroke(s); p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=2; p.ovl.setLineDash([5,4]);
          p.ovl.strokeRect(b.x,b.y,b.w,b.h); p.ovl.setLineDash([]);
        }else if(s.type==='poly' && s.points && s.points.length){
          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2); p.ovl.setLineDash([5,4]);
          p.ovl.beginPath();
          p.ovl.moveTo(s.points[0].x, s.points[0].y);
          for(let k=1;k<s.points.length;k++){ p.ovl.lineTo(s.points[k].x, s.points[k].y); }
          p.ovl.closePath();
          p.ovl.stroke();
          p.ovl.setLineDash([]);
        }
        p.ovl.restore(); return;
      }
    }
  }
  function eraseAt(pt,p){
    const eps = Math.max(6, size*2);
    let removed=false;
    const removedIds=[];
    const removedImageIds=[];
    for(let i=p.state.strokes.length-1;i>=0;i--){
      const s = p.state.strokes[i];
      let hit=false;
      if(s.type==='pen' && hitPolyline(s.points,pt,eps)){ hit=true; }
      else if(s.type==='line' && distToSegment(pt,s.a,s.b)<=eps){ hit=true; }
      else if(s.type==='poly' && s.points && hitPolyline(s.points,pt,eps)){ hit=true; }
      else if(s.type==='text'){
        const b=bboxStroke(s);
        if(pt.x>=b.x&&pt.x<=b.x+b.w&&pt.y>=b.y&&pt.y<=b.y+b.h){ hit=true; }
      }
      if(hit){
        if(s.id) removedIds.push(s.id);
        p.state.strokes.splice(i,1);
        removed=true;
      }
    }
    for(let i=p.state.images.length-1;i>=0;i--){
      const im = p.state.images[i];
      if(pt.x>=im.x && pt.x<=im.x+im.w && pt.y>=im.y && pt.y<=im.y+im.h){
        p.state.images.splice(i,1);
        if(im.id) removedImageIds.push(im.id);
        removed=true;
        continue;
      }
    }
    if(removed){
      renderAll(p);
      clearOverlay(p);
      [...removedIds, ...removedImageIds].forEach(id=>emitElementRemove(id));
    }
  }

  /* ---------- TEKST INLINE ---------- */
  let activeEditor=null;
  function openTextEditor(x,y,p){
    closeTextEditor(false);
    const ed = document.createElement('textarea'); ed.className='text-editor';
    const r = p.el.getBoundingClientRect();
    ed.style.left = (r.left + x) + 'px';
    ed.style.top  = (r.top  + y) + 'px';
    ed.style.fontSize = Math.max(14, size*6) + 'px';
    ed.placeholder='Wpisz tekst…';
    document.body.appendChild(ed); ed.focus();
    ed.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); closeTextEditor(true,p,x,y); } if(e.key==='Escape'){ e.preventDefault(); closeTextEditor(false); }});
    ed.addEventListener('blur', ()=>{ closeTextEditor(true,p,x,y); });
    activeEditor = {el:ed, color, size};
  }
  function closeTextEditor(commit,p,x,y){
    if(!activeEditor){ return; }
    const {el} = activeEditor; const val=el.value.trim(); el.remove(); activeEditor=null;
    if(commit && p && val){
      pushHistory(p);
      const textStroke = { id:newElementId(), type:'text', color, size, x, y, text: val };
      p.state.strokes.push(textStroke);
      renderAll(p);
      emitElementAddFromStroke(textStroke, PAGES.indexOf(p));
    }
  }

  /* ---------- COMPOSITE STRONY ---------- */
  async function compositePageCanvas(p){
    const dpr = window.devicePixelRatio || 1;
    const cssW = p.drawC.width / dpr, cssH = p.drawC.height / dpr;
    const tmp = document.createElement('canvas');
    tmp.width = Math.ceil(cssW * dpr);
    tmp.height = Math.ceil(cssH * dpr);
    theContext = tmp.getContext('2d');
    theContext.scale(dpr, dpr);

    if(gridSize === 'tech'){
      drawTechPattern(theContext, cssW, cssH);
    }else if(gridSize){
      theContext.save(); theContext.strokeStyle='#e6edff'; theContext.lineWidth=1;
      for(let x=0;x<=cssW;x+=gridSize){ theContext.beginPath(); theContext.moveTo(x,0); theContext.lineTo(x,cssH); theContext.stroke(); }
      for(let y=0;y<=cssH;y+=gridSize){ theContext.beginPath(); theContext.moveTo(0,y); theContext.lineTo(cssW,y); theContext.stroke(); }
      theContext.restore();
    }
    await Promise.all(p.state.images.map(im => im.img ? Promise.resolve() : new Promise(res=>{ const el=new Image(); el.onload=()=>{im.img=el; res();}; el.src=im.src; })));
    for(const im of p.state.images){ if(im.img) theContext.drawImage(im.img, im.x, im.y, im.w, im.h); }

    theContext.lineCap='round'; theContext.lineJoin='round';
    for(const s of p.state.strokes){
      if(s.type==='pen'){
        theContext.strokeStyle=s.color; theContext.lineWidth=s.size; const pts=s.points; if(!pts.length) continue;
        theContext.beginPath(); theContext.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length;i++){ theContext.lineTo(pts[i].x, pts[i].y); } theContext.stroke();
      }else if(s.type==='line'){
        theContext.strokeStyle=s.color; theContext.lineWidth=s.size; theContext.beginPath(); theContext.moveTo(s.a.x,s.a.y); theContext.lineTo(s.b.x,s.b.y); theContext.stroke();
      }else if(s.type==='text'){
        theContext.save(); theContext.fillStyle=s.color; theContext.font = `${Math.max(14, s.size*6)}px ui-sans-serif, system-ui, Arial`; theContext.textBaseline='top'; theContext.fillText(s.text, s.x, s.y); theContext.restore();
      }else if(s.type==='poly'){
        const pts=s.points;
        if(!pts || !pts.length) continue;
        theContext.save();
        theContext.strokeStyle=s.color;
        theContext.lineWidth=s.size;
        theContext.lineCap='round';
        theContext.lineJoin='round';
        theContext.beginPath();
        theContext.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){ theContext.lineTo(pts[i].x, pts[i].y); }
        if(s.closed){ theContext.closePath(); }
        theContext.stroke();
        theContext.restore();
      }
    }
    return tmp;
  }

  /* ---------- CROP (wycinanie) ---------- */
  let cropRectEl=null, cropStart=null, cropProcessing=false, cropBusyHintEl=null, cropBusyHintTimer=null;
  function beginCrop(x,y,p){
    cropCancel();
    cropStart = {x,y};
    cropRectEl = document.createElement('div'); cropRectEl.className='crop-rect';
    const r = p.drawC.getBoundingClientRect();
    const docLeft = r.left + window.scrollX;
    const docTop  = r.top  + window.scrollY;
    cropRectEl.style.left = (docLeft + x) + 'px';
    cropRectEl.style.top  = (docTop  + y) + 'px';
    cropRectEl.style.width='0px'; cropRectEl.style.height='0px';
    document.body.appendChild(cropRectEl);
  }
  function updateCrop(x,y,p){
    if(!cropRectEl || !cropStart) return;
    const r = p.drawC.getBoundingClientRect();
    const docLeft = r.left + window.scrollX;
    const docTop  = r.top  + window.scrollY;
    const x0 = Math.min(cropStart.x, x), y0 = Math.min(cropStart.y, y);
    const x1 = Math.max(cropStart.x, x), y1 = Math.max(cropStart.y, y);
    cropRectEl.style.left = (docLeft + x0) + 'px';
    cropRectEl.style.top  = (docTop  + y0) + 'px';
    cropRectEl.style.width  = (x1 - x0) + 'px';
    cropRectEl.style.height = (y1 - y0) + 'px';
  }
  function cropCancel(){ cropStart=null; if(cropRectEl){ cropRectEl.remove(); cropRectEl=null; } }
  async function finalizeCrop(x,y,p){
    if(!cropRectEl || !cropStart){ return; }
    const x0 = Math.min(cropStart.x, x), y0 = Math.min(cropStart.y, y);
    const x1 = Math.max(cropStart.x, x), y1 = Math.max(cropStart.y, y);
    cropCancel();

    if(!selectionHasContent(p, x0, y0, x1, y1)){
      return;
    }

    cropProcessing = true;
    try{
      const placement = await askCropPlacement();

      const comp = await compositePageCanvas(p);
      const dpr = window.devicePixelRatio || 1;
      const cssWidth = Math.max(1, Math.round(x1 - x0));
      const cssHeight = Math.max(1, Math.round(y1 - y0));
      const pxWidth = Math.max(1, Math.round(cssWidth * dpr));
      const pxHeight = Math.max(1, Math.round(cssHeight * dpr));
      const sx = Math.max(0, Math.floor(x0 * dpr)), sy = Math.max(0, Math.floor(y0 * dpr));
      const cut = document.createElement('canvas'); cut.width=pxWidth; cut.height=pxHeight;
      const cctx = cut.getContext('2d');
      cctx.drawImage(comp, sx, sy, pxWidth, pxHeight, 0, 0, pxWidth, pxHeight);
      cctx.imageSmoothingEnabled = false;
      const url = cut.toDataURL('image/png');

      const margin = 24;
      const rect = p.el.getBoundingClientRect();
      const pageW = rect.width, pageH = rect.height;
      const selectionBox = {x:x0, y:y0, w:x1-x0, h:y1-y0};

      const maxW = pageW - margin*2;
      const maxH = pageH - margin*2;
      const scale = Math.min(1, maxW / cssWidth, maxH / cssHeight);
      const w = Math.max(1, Math.floor(cssWidth * scale));
      const h = Math.max(1, Math.floor(cssHeight * scale));

      let targetPage = p;
      let xPos = 0;
      let yPos = 0;
      const placeBelow = placement !== 'adjacent';

      if(placeBelow){
        const bboxBottom = bottomOfTexts(p);
        xPos = Math.floor((pageW - w)/2);
        yPos = bboxBottom + margin;

        if (yPos + h + margin > pageH){
          targetPage = createPage();
          const rect2 = targetPage.el.getBoundingClientRect();
          xPos = Math.floor((rect2.width - w)/2);
          yPos = 24;
        }
      }else{
        const adj = findAdjacentPosition(selectionBox, w, h, pageW, pageH, margin);
        xPos = adj.x;
        yPos = adj.y;
      }
      addImageFromSrc(url, w, h, xPos, yPos, {crop:true}, targetPage);
      targetPage.el.scrollIntoView({behavior:'smooth', block:'center'});
    }finally{
      cropProcessing = false;
    }
  }
  function bottomOfTexts(p){
    let bottom = 0;
    const candidates = p.state.strokes.filter(s=>s.type==='text').map(s=>{ const b=bboxStroke(s); return b.y+b.h; });
    if(candidates.length){ bottom = Math.max(...candidates); }
    else {
      const all = [
        ...p.state.strokes.map(s=>{ const b=bboxStroke(s); return b.y+b.h; }),
        ...p.state.images.map(im=> im.y + im.h)
      ];
      if(all.length) bottom = Math.max(...all);
    }
    return bottom;
  }
  function selectionHasContent(p, x0, y0, x1, y1){
    const left = Math.min(x0,x1), right = Math.max(x0,x1);
    const top = Math.min(y0,y1), bottom = Math.max(y0,y1);
    const rect = {x:left, y:top, w:Math.max(0,right-left), h:Math.max(0,bottom-top)};
    if(rect.w===0 || rect.h===0) return false;
    const overlaps = (box)=> rect.x < box.x + box.w && rect.x + rect.w > box.x && rect.y < box.y + box.h && rect.y + rect.h > box.y;
    for(const s of p.state.strokes){
      if((s.type==='pen' || s.type==='poly') && (!s.points || !s.points.length)) continue;
      const box = bboxStroke(s);
      if(box.w===0 && box.h===0) continue;
      if(overlaps(box)){ return true; }
    }
    for(const im of (p.state.images||[])){
      const box = {x:im.x, y:im.y, w:im.w, h:im.h};
      if(overlaps(box)){ return true; }
    }
    return false;
  }
  function findAdjacentPosition(selection, w, h, pageW, pageH, margin){
    const clamp = (val, min, max)=> Math.min(Math.max(val, min), max);
    const maxX = Math.max(0, pageW - w);
    const maxY = Math.max(0, pageH - h);
    let xPos = selection.x + selection.w + margin;
    if(xPos + w > pageW){
      xPos = selection.x - w - margin;
    }
    xPos = clamp(xPos, 0, maxX);
    let yPos = clamp(selection.y, 0, maxY);
    if(yPos + h > pageH){
      yPos = maxY;
    }
    return {x:xPos, y:yPos};
  }
  function askCropPlacement(){
    return new Promise(resolve=>{
      const overlay=document.createElement('div');
      overlay.className='crop-choice-backdrop';
      const dialog=document.createElement('div');
      dialog.className='crop-choice-dialog';
      const text=document.createElement('p');
      text.textContent='Gdzie umieścić skopiowany fragment?';
      const actions=document.createElement('div');
      actions.className='crop-choice-actions';
      const btnBelow=document.createElement('button');
      btnBelow.className='primary';
      btnBelow.textContent='Kopiuj na dole';
      const btnAside=document.createElement('button');
      btnAside.className='secondary';
      btnAside.textContent='Kopiuj obok';

      let cleaned=false;
      function cleanup(choice){
        if(cleaned) return;
        cleaned=true;
        document.removeEventListener('keydown', onOverlayKey);
        overlay.classList.remove('open');
        let removed=false;
        const removeNow=()=>{ if(removed) return; removed=true; overlay.remove(); };
        overlay.addEventListener('transitionend', removeNow, {once:true});
        setTimeout(removeNow, 220);
        resolve(choice || 'below');
      }
      function onOverlayKey(e){
        if(e.key==='Escape'){
          cleanup('below');
        }
      }

      btnBelow.addEventListener('click', ()=> cleanup('below'));
      btnAside.addEventListener('click', ()=> cleanup('adjacent'));
      overlay.addEventListener('click', (e)=>{
        if(e.target===overlay){ cleanup('below'); }
      });
      document.addEventListener('keydown', onOverlayKey);

      actions.appendChild(btnBelow);
      actions.appendChild(btnAside);
      dialog.appendChild(text);
      dialog.appendChild(actions);
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      requestAnimationFrame(()=> overlay.classList.add('open'));
    });
  }
  function showCropBusyHint(){
    if(cropBusyHintEl){
      clearTimeout(cropBusyHintTimer);
      cropBusyHintEl.remove();
      cropBusyHintEl=null;
    }
    const toast=document.createElement('div');
    toast.className='crop-busy-toast';
    toast.textContent='Poczekaj na zakończenie kopiowania...';
    document.body.appendChild(toast);
    requestAnimationFrame(()=> toast.classList.add('show'));
    cropBusyHintEl=toast;
    cropBusyHintTimer=setTimeout(()=>{
      toast.classList.remove('show');
      const remove=()=>{
        toast.removeEventListener('transitionend', remove);
        if(cropBusyHintEl===toast){ cropBusyHintEl=null; cropBusyHintTimer=null; }
        toast.remove();
      };
      toast.addEventListener('transitionend', remove);
      setTimeout(remove, 400);
    }, 2000);
  }

  /* ---------- INTERAKCJE (POINTER) ---------- */
const ROTATE_HANDLE = 99;

function rectToPoly(x0,y0,x1,y1){
  const left=Math.min(x0,x1), right=Math.max(x0,x1);
  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
  return [
    {x:left,y:top}, {x:right,y:top}, {x:right,y:bottom}, {x:left,y:bottom}
  ];
  }
  function isoTriangleFromRect(x0,y0,x1,y1){
    const left=Math.min(x0,x1), right=Math.max(x0,x1);
    const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
    const midX = (left+right)/2;
    return [{x:midX,y:top},{x:right,y:bottom},{x:left,y:bottom}];
  }
  function rightTriangleFromRect(x0,y0,x1,y1){
    const left=Math.min(x0,x1), right=Math.max(x0,x1);
    const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
    return [{x:left,y:top},{x:right,y:top},{x:left,y:bottom}];
  }
function hexFromRect(x0,y0,x1,y1){
  const left=Math.min(x0,x1), right=Math.max(x0,x1);
  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
  const w=right-left, h=bottom-top;
  const cx=left+w/2, cy=top+h/2;
  const r = Math.min(w, h)/2;
  const pts=[];
  for(let i=0;i<6;i++){
    const a = Math.PI/6 + i * (Math.PI/3);
    pts.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a)});
  }
  return pts;
}
function circleFromRect(x0,y0,x1,y1){
  const left=Math.min(x0,x1), right=Math.max(x0,x1);
  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);
  const w=right-left, h=bottom-top;
  const cx=left+w/2, cy=top+h/2;
  const r = Math.min(w, h)/2;
  const segments = 24;
  const pts=[];
  for(let i=0;i<segments;i++){
    const a = i*(2*Math.PI/segments);
    pts.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a)});
  }
  return pts;
}
function shapeFromDrag(shape, x0,y0,x1,y1){
  if(shape==='rect') return rectToPoly(x0,y0,x1,y1);
  if(shape==='tri_iso') return isoTriangleFromRect(x0,y0,x1,y1);
  if(shape==='tri_right') return rightTriangleFromRect(x0,y0,x1,y1);
  if(shape==='hex') return hexFromRect(x0,y0,x1,y1);
  if(shape==='circle') return circleFromRect(x0,y0,x1,y1);
  return rectToPoly(x0,y0,x1,y1);
}
function rotatePointAround(pt, center, angle){
  const dx = pt.x - center.x;
  const dy = pt.y - center.y;
  return {
    x: center.x + dx * Math.cos(angle) - dy * Math.sin(angle),
    y: center.y + dx * Math.sin(angle) + dy * Math.cos(angle)
  };
}
function rectCorners(x,y,w,h){
  return [
    {x, y},
    {x: x+w, y},
    {x: x+w, y: y+h},
    {x, y: y+h}
  ];
}
function axisAlignedBBox(points){
  const xs = points.map(p=>p.x);
  const ys = points.map(p=>p.y);
  const minx = Math.min(...xs), maxx = Math.max(...xs);
  const miny = Math.min(...ys), maxy = Math.max(...ys);
  return {x:minx, y:miny, w:maxx-minx, h:maxy-miny};
}
function imageBoundingBox(im){
  if(!im) return {x:0,y:0,w:0,h:0};
  if(!im.rotation){
    return {x:im.x, y:im.y, w:im.w, h:im.h};
  }
  const center = {x: im.x + im.w/2, y: im.y + im.h/2};
  const corners = rectCorners(im.x, im.y, im.w, im.h).map(pt=>rotatePointAround(pt, center, im.rotation));
  return axisAlignedBBox(corners);
}
function textDimensions(s){
  const w = (Math.max(14, s.size*6)*0.6)*(s.text?.length||0);
  const h = Math.max(14, s.size*6);
  return {w,h};
}

  function bindPage(p){
    function getXY(evt){
      const r = p.drawC.getBoundingClientRect();
      return { x: evt.clientX - r.left, y: evt.clientY - r.top };
    }
    let drawing=false, startX=0, startY=0, current=null, cropping=false;
    const touchPointers = new Set();   // aktywne pointerId typu touch
    const activePointers = new Set();
    let multiPan=false;                // tryb dwupalczastego scrolla
    let panCentroidY=null;             // poprzedni centroid dotyków (Y)
    const pointerPosY = new Map();     // pointerId -> ostatni clientY
    let panIdleTimer=null;
    const PAN_IDLE_MS = 350;

    function endMultiPan(reason){
      multiPan=false;
      panCentroidY=null;
      pointerPosY.clear();
      touchPointers.clear();
      activePointers.clear();
      if(panIdleTimer){ clearTimeout(panIdleTimer); panIdleTimer=null; }
    }

    function currentTouchCentroid(){
      let sumY=0, cnt=0;
      touchPointers.forEach(id=>{
        if(pointerPosY.has(id)){
          sumY += pointerPosY.get(id);
          cnt++;
        }
      });
      return cnt>=2 ? sumY / cnt : null;
    }

    function start(x,y){
      if(tool===TOOLS.SELECT){
        const pt={x,y};
        if(p.state.selection){
          const h = hitHandle(pt, p.state.selection.bbox);
          if(h===ROTATE_HANDLE){
            const sel = p.state.selection;
            if(sel.kind==='stroke'){
              const s = p.state.strokes[sel.index];
              if(s.type==='poly'){
                const center = {x: sel.bbox.x + sel.bbox.w/2, y: sel.bbox.y + sel.bbox.h/2};
                p.state.dragging={
                  mode:'rotate',
                  startAngle: Math.atan2(y-center.y, x-center.x),
                  center,
                  original: cloneStrokeState(s)
                };
                pushHistory(p);
                return;
              }
            }
            return;
          }else if(h>=0){
            const sel = p.state.selection;
            const original = sel.kind==='image'
              ? cloneImageState(p.state.images[sel.index])
              : cloneStrokeState(p.state.strokes[sel.index]);
            p.state.dragging={
              mode:'scale',
              handle:h,
              startX:x,
              startY:y,
              startBBox:{...sel.bbox},
              original
            };
            pushHistory(p);
            return;
          }
          const b=p.state.selection.bbox;
          if(x>=b.x&&x<=b.x+b.w&&y>=b.y&&y<=b.y+b.h){ p.state.dragging={mode:'move', startX:x, startY:y}; pushHistory(p); return; }
        }
        p.state.selection = hitTest(pt,p) || null; drawSelection(p); return;
      }
      if(tool===TOOLS.TEXT){ openTextEditor(x,y,p); return; }
      if(tool===TOOLS.CROP){
        if(cropProcessing){ showCropBusyHint(); return; }
        beginCrop(x,y,p); cropping=true; return;
      }
      if(tool===TOOLS.FIGURE){
        drawing=true; startX=x; startY=y; pushHistory(p); clearOverlay(p);
        const pts = shapeFromDrag(currentShape, startX, startY, x, y);
        drawPolyPreview(p, pts);
        return;
      }

      drawing=true; startX=x; startY=y; pushHistory(p);
      if(tool===TOOLS.PEN){
        current={id:newElementId(), type:'pen', color, size, points:[{x,y}]}; p.state.strokes.push(current); renderAll(p);
      }else if(tool===TOOLS.LINE){
        current={id:newElementId(), type:'line', color, size, a:{x,y}, b:{x,y}}; clearOverlay(p);
      }else if(tool===TOOLS.ERASER){
        eraseAt({x,y},p);
        current=null;
      }
    }
    function move(x,y){
      if(tool===TOOLS.SELECT){
        const d=p.state.dragging;
        const sel=p.state.selection;
        if(d && sel){
          if(d.mode==='move'){
            const dx=x-d.startX, dy=y-d.startY; d.startX=x; d.startY=y;
            if(sel.kind==='image'){
              const im=p.state.images[sel.index]; im.x+=dx; im.y+=dy; sel.bbox.x+=dx; sel.bbox.y+=dy;
            }else{
              const s=p.state.strokes[sel.index];
              if(s.type==='pen') s.points.forEach(pt=>{pt.x+=dx;pt.y+=dy;});
              if(s.type==='line'){ s.a.x+=dx; s.a.y+=dy; s.b.x+=dx; s.b.y+=dy; }
              if(s.type==='text'){ s.x+=dx; s.y+=dy; }
              if(s.type==='poly' && s.points){ s.points.forEach(pt=>{pt.x+=dx;pt.y+=dy;}); }
              sel.bbox=bboxStroke(s);
            }
          }else if(d.mode==='scale'){
            const nextBBox = computeScaledBBox(d.startBBox, d.handle, x, y);
            applyScaledSelection(sel, d, nextBBox, p);
            sel.bbox = nextBBox;
          }else if(d.mode==='rotate'){
            if(sel.kind==='stroke'){
              const s = p.state.strokes[sel.index];
              if(s && s.type==='poly'){
                const angle = Math.atan2(y-d.center.y, x-d.center.x);
                const delta = angle - d.startAngle;
                s.points = d.original.points.map(pt=>rotatePointAround(pt, d.center, delta));
                sel.bbox = bboxStroke(s);
              }
            }
          }
          renderAll(p); drawSelection(p);
        }
        return;
      }
      if(tool===TOOLS.CROP && cropping){ updateCrop(x,y,p); return; }
      if(tool===TOOLS.ERASER){
        if(drawing){ eraseAt({x,y},p); }
        else{ previewErase({x,y},p); }
        return;
      }
      if(tool===TOOLS.FIGURE){
        if(!drawing) return;
        const pts = shapeFromDrag(currentShape, startX, startY, x, y);
        drawPolyPreview(p, pts);
        return;
      }
      if(!drawing) return;

      if(tool===TOOLS.PEN){ current.points.push({x,y}); renderAll(p); }
      else if(tool===TOOLS.LINE){
        current.b={x,y}; clearOverlay(p);
        p.ovl.lineCap='round'; p.ovl.lineJoin='round'; p.ovl.strokeStyle=color; p.ovl.lineWidth=size;
        p.ovl.beginPath(); p.ovl.moveTo(startX,startY); p.ovl.lineTo(x,y); p.ovl.stroke();
      }
    }
    function end(x,y){
      let strokeToSync = null;
      if(tool===TOOLS.SELECT){ p.state.dragging=null; return; }
      if(tool===TOOLS.CROP && cropping){ cropping=false; finalizeCrop(x,y,p); return; }
      if(tool===TOOLS.ERASER){
        drawing=false;
        clearOverlay(p);
        if(p.state.selection) drawSelection(p);
        return;
      }
      if(tool===TOOLS.FIGURE){
        if(!drawing) return;
        const pts = shapeFromDrag(currentShape, startX, startY, x, y);
        clearOverlay(p);
        const polyStroke = { id:newElementId(), type:'poly', color, size, points: pts, closed:true };
        p.state.strokes.push(polyStroke);
        renderAll(p);
        strokeToSync = polyStroke;
        drawing=false;
        current=null;
      }else{
        if(!drawing) return;
        if(tool===TOOLS.LINE){
          clearOverlay(p);
          current.b={x,y};
          p.state.strokes.push(current);
          renderAll(p);
          strokeToSync = current;
        }
        if(tool===TOOLS.PEN){
          strokeToSync = current;
        }
        drawing=false;
      }
      if(strokeToSync){
        emitElementAddFromStroke(strokeToSync, PAGES.indexOf(p));
      }
      current=null;
    }

    function trackTouch(e, isDown){
      if(e.pointerType!=='touch') return;
      if(isDown){
        touchPointers.add(e.pointerId);
        pointerPosY.set(e.pointerId, e.clientY);
      }else{
        touchPointers.delete(e.pointerId);
        pointerPosY.delete(e.pointerId);
      }
      const shouldPan = touchPointers.size >= 2;
      if(shouldPan && !multiPan){
        multiPan = true;
        drawing = false;
        activePointers.clear();
        panCentroidY = currentTouchCentroid();
        if(panIdleTimer) clearTimeout(panIdleTimer);
        panIdleTimer = setTimeout(()=>{ endMultiPan('idle-start'); }, PAN_IDLE_MS);
        try{
          touchPointers.forEach(id=>{ try{ p.drawC.releasePointerCapture(id); }catch(_){} });
        }catch(_){}
      }else if(!shouldPan && multiPan){
        endMultiPan('pointer-drop');
      }else if(shouldPan && multiPan){
        const centroid = currentTouchCentroid();
        if(centroid!==null){ panCentroidY = centroid; }
        if(panIdleTimer) clearTimeout(panIdleTimer);
        panIdleTimer = setTimeout(()=>{ endMultiPan('idle-change'); }, PAN_IDLE_MS);
      }
    }

    p.drawC.addEventListener('pointerdown', (e)=>{
      trackTouch(e, true);
      if(multiPan) return;
      e.preventDefault();
      p.drawC.setPointerCapture(e.pointerId);
      pointerPosY.set(e.pointerId, e.clientY);
      const {x,y}=getXY(e);
      start(x,y);
      activePointers.add(e.pointerId);
    }, {passive:false});
    p.drawC.addEventListener('pointermove', (e)=>{
      if(multiPan){
        e.preventDefault();
        if(e.pointerType==='touch'){ pointerPosY.set(e.pointerId, e.clientY); }
        const cy = currentTouchCentroid();
        if(cy!==null){
          if(panCentroidY!==null){
            const dy = cy - panCentroidY;
            wrapEl.scrollTop -= dy;
          }
          panCentroidY = cy;
          if(panIdleTimer) clearTimeout(panIdleTimer);
          panIdleTimer = setTimeout(()=>{ endMultiPan('idle'); }, PAN_IDLE_MS);
        }
        return;
      }
      if(tool!==TOOLS.SELECT || e.buttons) e.preventDefault();
      const {x,y}=getXY(e);
      move(x,y);
    }, {passive:false});
    function handlePointerRelease(e){
      trackTouch(e, false);
      if(multiPan){
        pointerPosY.delete(e.pointerId);
        const cy = currentTouchCentroid();
        if(cy!==null){ panCentroidY = cy; }
        return;
      }
      if(!activePointers.has(e.pointerId)) return;
      activePointers.delete(e.pointerId);
      e.preventDefault();
      const {x,y}=getXY(e);
      end(x,y);
      try{ p.drawC.releasePointerCapture(e.pointerId);}catch(_){}
    }
    p.drawC.addEventListener('pointerup', handlePointerRelease, {passive:false});
    p.drawC.addEventListener('pointercancel', handlePointerRelease, {passive:false});

    function globalTouchCleanup(e, isDown){
      if(e.pointerType && e.pointerType!=='touch') return;
      if(isDown) return;
      if(pointerPosY.has(e.pointerId)) pointerPosY.delete(e.pointerId);
      if(touchPointers.has(e.pointerId)) touchPointers.delete(e.pointerId);
      if(touchPointers.size<2 && multiPan){
        endMultiPan('global-release');
      }
    }
    window.addEventListener('pointerup', (e)=>globalTouchCleanup(e,false), {passive:false});
    window.addEventListener('pointercancel', (e)=>globalTouchCleanup(e,false), {passive:false});
    window.addEventListener('touchend', ()=>{ if(multiPan) endMultiPan('touchend'); }, {passive:false});
    window.addEventListener('touchcancel', ()=>{ if(multiPan) endMultiPan('touchcancel'); }, {passive:false});
    document.addEventListener('visibilitychange', ()=>{ if(document.hidden && multiPan){ endMultiPan('hidden'); } });
  }

  /* ---------- UI OGÓLNY ---------- */
  function toolLabel(){
    return tool===TOOLS.SELECT?'Kursor':
           tool===TOOLS.PEN?'Ołówek':
           tool===TOOLS.LINE?'Linia':
           tool===TOOLS.ERASER?'Gumka':
           tool===TOOLS.TEXT?'Tekst':
           tool===TOOLS.CROP?'Wycinanie':'Figury';
  }
  function setTool(next){
    const prevTool = tool;
    tool = next;
    handleTextToolToggle(prevTool);
    updateState();
    document.querySelectorAll('#tools [data-tool]').forEach(b=>{
      b.classList.toggle('is-active', b.getAttribute('data-tool')===tool);
    });
    if(tool!==TOOLS.FIGURE){ toggleFigurePalette(false); }
    else { ensureFigurePalette(); updateFigurePaletteSelection(); }
    PAGES.forEach(p=>{ clearOverlay(p); drawSelection(p); });
  }
  function updateState(){
    const shapeLabel = tool===TOOLS.FIGURE
      ? ` • ${currentShape==='rect'?'Kwadrat':currentShape==='tri_iso'?'Trójkąt':currentShape==='tri_right'?'Trójkąt 90°':currentShape==='hex'?'Sześciokąt':'Koło'}`
      : '';
    const sizeLabel = tool===TOOLS.TEXT ? `${Math.round(textFontSizePx)}px` : `${size}px`;
    stateEl.textContent = `Tryb: ${toolLabel()} • ${sizeLabel} • ${color}${shapeLabel}`;
    updateFigurePaletteSelection();
  }

  const toolsRow = document.getElementById('tools');
  toolsRow.addEventListener('pointerdown', (e)=>{
    const b = e.target.closest('[data-tool]'); if(!b) return;
    e.preventDefault();
    const toolName = b.getAttribute('data-tool');
    setTool(toolName);
    if(toolName===TOOLS.FIGURE){
      figureBtn = b;
      toggleFigurePalette(true);
    }else{
      toggleFigurePalette(false);
    }
  });
  document.addEventListener('pointerdown', (e)=>{
    const sh = e.target.closest('.figure-palette .shape-btn');
    if(!sh) return;
    e.preventDefault();
    e.stopPropagation();
    currentShape = sh.getAttribute('data-shape') || 'rect';
    updateFigurePaletteSelection();
    toggleFigurePalette(false);
    setTool(TOOLS.FIGURE);
    updateState();
  });
  document.addEventListener('pointerdown', (e)=>{
    if(e.target.closest('[data-tool="figure"]') || (figurePalette && figurePalette.contains(e.target))) return;
    toggleFigurePalette(false);
  });
  if(textFontBtn){
    textFontBtn.addEventListener('pointerdown', (e)=>{
      if(tool!==TOOLS.TEXT) return;
      e.preventDefault();
      e.stopPropagation();
      const isOpen = textFontPanel?.classList.contains('open');
      toggleTextFontPanel(!isOpen);
      textFontBtn.classList.toggle('is-active', !isOpen);
    });
  }
  document.addEventListener('pointerdown', (e)=>{
    if(!textFontPanel || !textFontPanel.classList.contains('open')) return;
    if((textFontBtn && textFontBtn.contains(e.target)) || textFontPanel.contains(e.target)) return;
    toggleTextFontPanel(false);
  });
  document.addEventListener('keydown', (e)=>{
    if(e.key==='Escape' && textFontPanel && textFontPanel.classList.contains('open')){
      toggleTextFontPanel(false);
    }
  });
  document.getElementById('color').addEventListener('input', e=>{ color=e.target.value; updateState(); });
  const sizeSelect = document.getElementById('size');
  if(sizeSelect){
    sizeSelect.addEventListener('change', e=>{
      const nextSize = parseInt(e.target.value,10);
      if(Number.isNaN(nextSize)) return;
      size = nextSize;
      if(tool===TOOLS.TEXT){
        setTextFontPx(nextSize * 6);
      }else{
        lastBrushSize = size;
        updateState();
      }
    });
  }
  if(deleteSelectionBtn){
    deleteSelectionBtn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      deleteCurrentSelection();
    });
  }
  updateDeleteButtonState();

  window.addEventListener('keydown', (e)=>{
    if(e.key==='v'||e.key==='V') setTool(TOOLS.SELECT);
    if(e.key==='p'||e.key==='P') setTool(TOOLS.PEN);
    if(e.key==='l'||e.key==='L') setTool(TOOLS.LINE);
    if(e.key==='e'||e.key==='E') setTool(TOOLS.ERASER);
    if(e.key==='t'||e.key==='T') setTool(TOOLS.TEXT);
    if(e.key==='c'||e.key==='C') setTool(TOOLS.CROP);
    if(e.key==='f'||e.key==='F'){
      setTool(TOOLS.FIGURE);
      figureBtn = document.querySelector('[data-tool="figure"]');
      toggleFigurePalette(true);
    }
  });

  // MENU (po prawej)
  const menuBtn = document.getElementById('menuBtn');
  const dropdown = document.getElementById('dropdown');
  const openBoardModal = document.getElementById('openBoardModal');
  const openBoardBtn = document.getElementById('openBoardBtn');
  const openBoardInput = document.getElementById('openBoardName');
  const openBoardCancel = document.getElementById('openBoardCancel');
  const openBoardCreate = document.getElementById('openBoardCreate');

  function showOpenBoardModal(){
    if(!openBoardModal) return;
    openBoardModal.classList.add('open');
    openBoardModal.removeAttribute('aria-hidden');
    if(openBoardInput){
      openBoardInput.value='';
      setTimeout(()=> openBoardInput.focus(), 50);
    }
  }
  function hideOpenBoardModal(){
    if(!openBoardModal) return;
    openBoardModal.classList.remove('open');
    openBoardModal.setAttribute('aria-hidden','true');
  }
  function handleCreateBoard(){
    resetBoard();
    const page = createPage(true);
    if(openBoardInput){
      const label = openBoardInput.value.trim();
      if(label){ page.el.setAttribute('data-board-name', label); }
    }
    hideOpenBoardModal();
  }

  function toggleMenu(force){
    const open = typeof force==='boolean' ? force : !dropdown.classList.contains('open');
    dropdown.classList.toggle('open', open);
    menuBtn.setAttribute('aria-expanded', String(open));
  }
  menuBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); e.stopPropagation(); toggleMenu(); });
  document.addEventListener('pointerdown', (e)=>{ if(!dropdown.contains(e.target) && e.target!==menuBtn){ toggleMenu(false);} });

  dropdown.querySelectorAll('[data-grid]').forEach(btn=>{
    btn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      const val = btn.getAttribute('data-grid');
      const newSize = val === 'tech' ? 'tech' : parseInt(val,10) || 0;
      gridSize = newSize;

      if (val === 'tech'){
        PAGES.forEach(p=> drawTechGrid(p));
      } else {
        PAGES.forEach(p=> drawGrid(p));
      }

      // realtime broadcast – jeśli dostępny
      if (window.AliboardRealtime && typeof window.AliboardRealtime.sendGridState === 'function') {
        const payload = val === 'tech'
          ? { gridSize: 0, kind: 'tech' }
          : { gridSize: newSize, kind: 'grid' };
        window.AliboardRealtime.sendGridState(payload);
      }

      toggleMenu(false);
    });
  });
  if(openBoardBtn && openBoardBtn.tagName === 'BUTTON'){
    openBoardBtn.addEventListener('click', (e)=>{ e.preventDefault(); showOpenBoardModal(); toggleMenu(false); });
  }
  if(openBoardCancel){ openBoardCancel.addEventListener('click', hideOpenBoardModal); }
  if(openBoardCreate){ openBoardCreate.addEventListener('click', handleCreateBoard); }
  if(openBoardModal){
    openBoardModal.addEventListener('click', (e)=>{ if(e.target===openBoardModal){ hideOpenBoardModal(); } });
  }
  if(openBoardInput){
    openBoardInput.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){ e.preventDefault(); handleCreateBoard(); }
      if(e.key==='Escape'){ e.preventDefault(); hideOpenBoardModal(); }
    });
  }
  const saveToggle = document.getElementById('saveToggle');
  const saveRow = document.getElementById('saveRow');
  if(saveToggle && saveRow){
    saveToggle.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      saveRow.style.display = saveRow.style.display==='none' ? 'flex' : 'none';
    });
  }
  const templatesToggle = document.getElementById('templatesToggle');
  const gridToggle = document.getElementById('gridToggle');
  const templatesRow = document.getElementById('templatesRow');
  if(templatesToggle && gridToggle && templatesRow){
    templatesToggle.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      const showGrid = gridToggle.style.display==='none';
      gridToggle.style.display = showGrid ? 'block' : 'none';
      if(!showGrid){
        templatesRow.style.display = 'none';
      }
    });
    gridToggle.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      templatesRow.style.display = templatesRow.style.display==='none' ? 'flex' : 'none';
    });
  }
  const addPageBtn = document.getElementById('addPage');
  if(addPageBtn){ addPageBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); createPage(true); toggleMenu(false); }); }

  // EXPORT (aktualna strona)
  async function exportCurrent(ext){
    const p = currentPage(); if(!p) return;
    const c = await compositePageCanvas(p);
    if(ext==='png'){
      const a=document.createElement('a'); a.href=c.toDataURL('image/png'); a.download=ts('png'); a.click();
    }else if(ext==='jpg'){
      const a=document.createElement('a'); a.href=c.toDataURL('image/jpeg', .92); a.download=ts('jpg'); a.click();
    }else if(ext==='pdf'){
      const lib = window.jspdf?.jsPDF; if(!lib) return alert('PDF niezaładowany.');
      const dataUrl = c.toDataURL('image/png');
      const pdf = new lib({orientation:'portrait', unit:'pt', format:'a4'});
      const pw = pdf.internal.pageSize.getWidth(), ph = pdf.internal.pageSize.getHeight();
      const img = new Image();
      img.onload = ()=>{ const ratio = Math.min(pw/img.width, ph/img.height); const w = img.width*ratio, h = img.height*ratio; const x = (pw-w)/2, y=(ph-h)/2; pdf.addImage(dataUrl, 'PNG', x, y, w, h); pdf.save(ts('pdf')); };
      img.src = dataUrl;
    }
  }
  function ts(ext){ return `aliboard_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.${ext}`; }
  document.getElementById('savePng').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('png'); toggleMenu(false); });
  document.getElementById('saveJpg').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('jpg'); toggleMenu(false); });
  document.getElementById('savePdf').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('pdf'); toggleMenu(false); });

  // UNDO (aktualna strona)
  document.getElementById('undo').addEventListener('pointerdown', (e)=>{ e.preventDefault(); const p=currentPage(); if(!p || !p.state.history.length) return; const last = p.state.history.pop(); p.state.redo.push(snapshotState(p)); restoreHistoryState(p, last); });

  // WSTAW OBRAZ/PDF
  document.getElementById('imgInput').addEventListener('change', (e)=>{
    const f=e.target.files[0]; if(!f) return;
    const p=currentPage(); if(!p) return;
    const url = URL.createObjectURL(f);
    const temp = new Image();
    temp.onload = ()=>{ const rect=p.el.getBoundingClientRect(); const ratio = Math.min(rect.width/temp.width, rect.height/temp.height); const w = Math.max(80, temp.width*ratio), h=Math.max(80, temp.height*ratio); const x = (rect.width-w)/2, y=(rect.height-h)/2; addImageFromSrc(url, w, h, x, y, {file:true}, p); };
    temp.src=url; e.target.value='';
  });
  document.getElementById('pdfInput').addEventListener('change', async (e)=>{
    const f=e.target.files[0]; if(!f) return;
    const p=currentPage(); if(!p) return;
    const arrayBuffer = await f.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
    let pageNum = 1; const ask = prompt(`PDF ma ${pdf.numPages} stron. Wpisz numer strony do wstawienia:`, "1");
    if(ask){ const n=parseInt(ask,10); if(!isNaN(n)&&n>=1&&n<=pdf.numPages) pageNum=n; }
    const page = await pdf.getPage(pageNum);
    const viewport = page.getViewport({scale: 2});
    const c = document.createElement('canvas'); c.width=viewport.width; c.height=viewport.height;
    const cctx = c.getContext('2d'); await page.render({canvasContext:cctx, viewport}).promise;
    const url = c.toDataURL('image/png');
    const rect=p.el.getBoundingClientRect();
    const ratio = Math.min(rect.width/c.width, rect.height/c.height);
    const theWidth = Math.max(120, c.width*ratio);
    const theHeight=Math.max(120, c.height*ratio);
    const x = (rect.width-theWidth)/2, y=(rect.height-theHeight)/2;
    addImageFromSrc(url, theWidth, theHeight, x, y, {pdf:true,page:pageNum}, p);
    e.target.value='';
  });

  // AUTODODAWANIE KARTKI przy przewijaniu
  wrapEl.addEventListener('scroll', ()=>{
    const nearBottom = wrapEl.scrollTop + wrapEl.clientHeight >= wrapEl.scrollHeight - 80;
    if(nearBottom){
      createPage(false);
    }
  }, {passive:true});

  // AUTOSAVE wielostronicowy – osobny klucz na każdy room_id
  const AUTOSAVE_KEY = `aliboard_v25_state_${roomId}`;

  // (opcjonalnie) wyczyść stary globalny klucz z czasów "local-test"
  try {
    if (roomId !== 'local-test') {
      localStorage.removeItem('aliboard_v25_state');
    }
  } catch (_) {}

  function autosave(){
    try{
      PAGES.forEach(ensureStrokeIds);
      const payload = PAGES.map(p=>({
        strokes:p.state.strokes,
        images: p.state.images.map(im=>({id: im.id, x:im.x,y:im.y,w:im.w,h:im.h,src:im.src,meta:im.meta}))
      }));
      localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(payload));
    }catch(_){}
  }
  setInterval(autosave, 30000);
  function restoreLocal(){
    try{
      const raw = localStorage.getItem(AUTOSAVE_KEY);
      if(!raw) return false;
      const arr = JSON.parse(raw); if(!Array.isArray(arr) || !arr.length) return false;
      arr.forEach((pageData)=>{ const p=createPage(false); p.state.strokes = pageData.strokes||[]; ensureStrokeIds(p); p.state.images  = (pageData.images||[]).map(im=>reviveImage(im,p)); renderAll(p); });
      return true;
    }catch(_){ return false; }
  }

  // [CODEX:BEGIN OVERFLOW_MENU]
  (function setupToolsOverflow(){
    const toolsRow = document.getElementById('tools');
    if(!toolsRow) return;
    console.debug('[ALIBOARD][overflow] init', {
      toolsRowExists: !!document.getElementById('tools'),
      headerExists: !!document.querySelector('header .left'),
    });

    // 1) Utwórz przycisk „⋯” i panel overflow zaraz obok paska narzędzi, jeśli nie istnieją
    let moreBtn = document.getElementById('toolsMoreBtn');
    let moreBox = document.getElementById('toolsMorePanel');

    if(!moreBtn){
      moreBtn = document.createElement('button');
      moreBtn.id = 'toolsMoreBtn';
      moreBtn.className = 'btn';
      moreBtn.type = 'button';
      moreBtn.title = 'Więcej narzędzi';
      moreBtn.textContent = '⋯';
    toolsRow.appendChild(moreBtn);
    }
    if(!moreBox){
      moreBox = document.createElement('div');
      moreBox.id = 'toolsMorePanel';
      moreBox.className = 'dropdown';
      // otwieramy w lewo, obok paska narzędzi
      moreBox.style.left = '0';
      moreBox.style.right = 'auto';
      moreBtn.insertAdjacentElement('afterend', moreBox);
    }

    // 2) Oznacz „klejone” (nigdy nie przenoszone) narzędzia – rdzeń paska
    //    (możesz dopasować listę; domyślnie trzymamy: select, pen, line, eraser)
    const stickySelectors = [
      '[data-tool="select"]',
      '[data-tool="pen"]',
      '[data-tool="line"]',
      '[data-tool="eraser"]'
    ];
    const stickySet = new Set(
      stickySelectors
        .map(sel => toolsRow.querySelector(sel))
        .filter(Boolean)
    );

    // 3) Funkcja: przenieś elementy z overflow z powrotem do głównego rzędu
    function restoreFromOverflow(){
      // przywróć wszystko co było upchnięte
      [...moreBox.children].forEach(node => toolsRow.appendChild(node));
    }

    // 4) Funkcja: wylicz które elementy trzeba schować do „⋯”, aż przestanie się przelewać
    function rebalanceTools(){
      if(!toolsRow) return;

      console.debug('[ALIBOARD][overflow] before', {
        clientWidth: toolsRow?.clientWidth,
        scrollWidth: toolsRow?.scrollWidth,
        childCount: toolsRow?.children?.length,
        moreBoxChildren: moreBox?.children?.length
      });

      while (moreBox.firstChild) toolsRow.appendChild(moreBox.firstChild);

      if (toolsRow.scrollWidth <= toolsRow.clientWidth) {
        moreBtn.style.display = 'none';
        moreBox.classList.remove('open');
        console.debug('[ALIBOARD][overflow] after', {
          clientWidth: toolsRow?.clientWidth,
          scrollWidth: toolsRow?.scrollWidth,
          childCount: toolsRow?.children?.length,
          moreBoxChildren: moreBox?.children?.length,
          moreBtnDisplay: moreBtn?.style?.display
        });
        return;
      }

      const essentialSel = [
        '[data-tool="select"]',
        '[data-tool="pen"]',
        '[data-tool="line"]',
        '[data-tool="eraser"]',
        '[data-tool="text"]',
        '[data-tool="crop"]'
      ].join(',');

      const children = [...toolsRow.children];
      const candidates = children
        .filter(el => !el.matches(essentialSel) && el !== moreBtn);

      for (let i = candidates.length - 1; i >= 0 && toolsRow.scrollWidth > toolsRow.clientWidth; i--){
        const el = candidates[i];
        moreBox.appendChild(el);
      }

      moreBtn.style.display = moreBox.children.length ? 'inline-flex' : 'none';

      console.debug('[ALIBOARD][overflow] after', {
        clientWidth: toolsRow?.clientWidth,
        scrollWidth: toolsRow?.scrollWidth,
        childCount: toolsRow?.children?.length,
        moreBoxChildren: moreBox?.children?.length,
        moreBtnDisplay: moreBtn?.style?.display
      });

      console.debug('[ALIBOARD][overflow] rebalanced', {
        clientWidth: toolsRow.clientWidth,
        scrollWidth: toolsRow.scrollWidth,
        moved: moreBox.children.length
      });
    }

    // 5) Toggling panelu overflow
    moreBtn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      moreBox.classList.toggle('open');
    });
    document.addEventListener('pointerdown', (e)=>{
      if(!moreBox.contains(e.target) && e.target !== moreBtn){
        moreBox.classList.remove('open');
      }
    });

    // 6) Rebalans po załadowaniu i na resize
    window.addEventListener('load', rebalanceTools, { once: true });
    window.addEventListener('resize', rebalanceTools);

    // 7) Obsługa „tap” na elementach przeniesionych do overflow:
    //    delegujemy kliknięcia, żeby zachowały się identycznie jak w głównym rzędzie
    moreBox.addEventListener('pointerdown', (e)=>{
      const btn = e.target.closest('button, label');
      if(!btn) return;
      const toolTarget = btn.closest('[data-tool]');
      if(toolTarget){
        e.preventDefault();
        e.stopPropagation();
        const toolName = toolTarget.getAttribute('data-tool');
        setTool(toolName);
        if(toolName===TOOLS.FIGURE){
          figureBtn = toolTarget;
          toggleFigurePalette(true);
        }else{
          toggleFigurePalette(false);
        }
      }
      setTimeout(()=> moreBox.classList.remove('open'), 0);
    });

    // 8) Publiczny hook: gdyby coś dynamicznie dodało narzędzie — spróbuj zbalansować ponownie
    const ro = new ResizeObserver(rebalanceTools);
    ro.observe(toolsRow);
    setTimeout(rebalanceTools, 250);
    setTimeout(rebalanceTools, 800);

  })();
  // [CODEX:END OVERFLOW_MENU]

  // 🔹 Aliboard Chat Module – logika czatu
  (function initAliboardChatModule(){
    const bubble = document.getElementById('aliboard-chat-bubble');
    const panel = document.getElementById('aliboard-chat-panel');
    const closeBtn = document.getElementById('aliboard-chat-close');
    const form = document.getElementById('aliboard-chat-form');
    const input = document.getElementById('aliboard-chat-input');
    const messagesEl = document.getElementById('aliboard-chat-messages');
    const pingBtn = document.getElementById('aliboard-chat-ping');
    const micBtn = document.getElementById('aliboard-chat-mic');
    const callBtn = document.getElementById('aliboard-chat-call');

    if(!bubble || !panel || !form || !input || !messagesEl){
      return;
    }

    window.aliboardChat = window.aliboardChat || {};
    window.aliboardChat.sendToServer = window.aliboardChat.sendToServer || null;
    window.aliboardChat.sendPing = window.aliboardChat.sendPing || null;
    window.aliboardChat.toggleMic = window.aliboardChat.toggleMic || null;
    window.aliboardChat.sendCallSignal = window.aliboardChat.sendCallSignal || null;

    const CHAT_OPEN_KEY = 'aliboard_chat_is_open';
    let isMicMuted = false;
    let incomingCallBanner = null;
    let ringIntervalId = null;
    let isPanelOpen = false;
    let unreadCount = 0;
    let unreadBadgeEl = null;

    function ensureUnreadBadge(){
      if(!bubble) return;
      if(unreadBadgeEl) return;
      unreadBadgeEl = document.createElement('span');
      unreadBadgeEl.className = 'aliboard-chat-badge aliboard-chat-badge-hidden';
      unreadBadgeEl.textContent = '';
      bubble.appendChild(unreadBadgeEl);
    }

    function playCallBeepOnce(){
      try{
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 880;
        gain.gain.setValueAtTime(0.15, ctx.currentTime);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.25);
      }catch(_){
        // AudioContext niedostepny - ignorujemy
      }
    }

    function startRingTone(){
      if(ringIntervalId !== null) return;
      playCallBeepOnce();
      ringIntervalId = window.setInterval(playCallBeepOnce, 1500);
    }

    function stopRingTone(){
      if(ringIntervalId !== null){
        window.clearInterval(ringIntervalId);
        ringIntervalId = null;
      }
    }

    function playMessageBeep(){
      try{
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = 600;
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.15);
      }catch(_){
        // brak dzwieku - ignorujemy
      }
    }

    function showIncomingCallBanner(fromRole){
      if(!panel) return;
      if(incomingCallBanner && incomingCallBanner.parentNode){
        incomingCallBanner.parentNode.removeChild(incomingCallBanner);
      }
      const banner = document.createElement('div');
      banner.className = 'aliboard-call-banner';
      banner.innerHTML = `
        <span>🔊 Połączenie głosowe z: <strong>${fromRole === 'teacher' ? 'Nauczyciel' : 'Uczeń'}</strong></span>
        <div class="aliboard-call-actions">
          <button class="aliboard-call-accept-btn" id="aliboard-accept-call-btn">Dołącz</button>
          <button class="aliboard-call-end-btn" id="aliboard-end-call-btn">Rozłącz</button>
        </div>
      `;
      panel.insertBefore(banner, panel.firstChild);
      incomingCallBanner = banner;
      startRingTone();

      const acceptBtn = document.getElementById('aliboard-accept-call-btn');
      const endBtn = document.getElementById('aliboard-end-call-btn');

      if(acceptBtn){
        acceptBtn.addEventListener('click', ()=>{
          stopRingTone();
          if(window.aliboardVoice && typeof window.aliboardVoice.acceptIncomingCall === 'function'){
            window.aliboardVoice.acceptIncomingCall()
              .catch((err)=>{
                console.error('[AliboardVoice] acceptIncomingCall error', err);
                if(window.aliboardVoice && typeof window.aliboardVoice.hangupCall === 'function'){
                  window.aliboardVoice.hangupCall(false);
                }
              });
          }
        });
      }

      if(endBtn){
        endBtn.addEventListener('click', ()=>{
          stopRingTone();
          if(window.aliboardChat && typeof window.aliboardChat.sendCallSignal === 'function'){
            window.aliboardChat.sendCallSignal('end');
          }
          if(window.aliboardVoice && typeof window.aliboardVoice.hangupCall === 'function'){
            window.aliboardVoice.hangupCall(false);
          }
        });
      }
    }

    function setPanelOpen(isOpen){
      isPanelOpen = !!isOpen;
      if(isOpen){
        panel.classList.add('is-open');
        panel.setAttribute('aria-hidden', 'false');
        try{ localStorage.setItem(CHAT_OPEN_KEY, '1'); }catch(_){}
        setTimeout(()=> input.focus(), 20);
        unreadCount = 0;
        if(unreadBadgeEl){
          unreadBadgeEl.textContent = '';
          unreadBadgeEl.classList.add('aliboard-chat-badge-hidden');
        }
      }else{
        panel.classList.remove('is-open');
        panel.setAttribute('aria-hidden', 'true');
        try{ localStorage.setItem(CHAT_OPEN_KEY, '0'); }catch(_){}
      }
    }

    try{
      if(localStorage.getItem(CHAT_OPEN_KEY)==='1'){
        setPanelOpen(true);
      }
    }catch(_){}

    bubble.addEventListener('click', ()=>{
      const shouldOpen = !panel.classList.contains('is-open');
      setPanelOpen(shouldOpen);
    });
    if(closeBtn){
      closeBtn.addEventListener('click', ()=> setPanelOpen(false));
    }

    function appendMessage(opts){
      if(!opts || !opts.text) return;
      const author = opts.author === 'other' ? 'other' : 'me';
      const msgEl = document.createElement('div');
      msgEl.className = `aliboard-chat-message ${author}`;
      const contentSpan = document.createElement('span');
      contentSpan.textContent = opts.text.toString();
      msgEl.appendChild(contentSpan);
      if(opts.timeString){
        const meta = document.createElement('span');
        meta.className = 'aliboard-chat-meta';
        meta.textContent = opts.timeString;
        msgEl.appendChild(meta);
      }
      messagesEl.appendChild(msgEl);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function getTimeString(){
      try{
        const d = new Date();
        return d.toLocaleTimeString(undefined, { hour:'2-digit', minute:'2-digit' });
      }catch(_){
        return '';
      }
    }

    function sendChatMessage(text) {
      if (!text.trim()) return;
      const trimmed = text.trim().slice(0, 500);

      // ❗ tylko wysyłamy na serwer, bez lokalnego dopisywania
      if (window.aliboardChat && typeof window.aliboardChat.sendToServer === "function") {
        window.aliboardChat.sendToServer(trimmed);
      }

      input.value = "";
    }

    form.addEventListener('submit', (e)=>{
      e.preventDefault();
      sendChatMessage(input.value);
    });

    if(pingBtn){
      pingBtn.addEventListener('click', ()=>{
        appendMessage({
          text: '🔔 Wysłałeś zaczepienie (ping).',
          author: 'me',
          timeString: getTimeString()
        });
        if(typeof window.aliboardChat.sendPing === 'function'){
          window.aliboardChat.sendPing();
        }
      });
    }

        if(micBtn){
      micBtn.addEventListener('click', ()=>{
        isMicMuted = !isMicMuted;
        micBtn.classList.toggle('is-muted', isMicMuted);
        if(typeof window.aliboardChat.toggleMic === 'function'){
          window.aliboardChat.toggleMic(isMicMuted);
        }
      });
    }

    window.aliboardChat.onServerMessage = function (text, authorId) {
      const myId = window.ALIBOARD_USER_ID;
      const serverId = (authorId !== null && authorId !== undefined) ? Number(authorId) : null;
      const isMe = (myId !== null && myId !== undefined && serverId !== null && serverId === Number(myId));

      appendMessage({
        text: text,
        author: isMe ? "me" : "other",
        timeString: getTimeString(),
      });

      if(!isPanelOpen && !isMe){
        ensureUnreadBadge();
        unreadCount += 1;
        unreadBadgeEl.textContent = unreadCount.toString();
        unreadBadgeEl.classList.remove('aliboard-chat-badge-hidden');
        playMessageBeep();
      }
    };

    window.aliboardChat.onCallSignal = function(payload){
      if(!payload) return;
      const fromId = payload.from_id;
      const fromRole = payload.from_role || 'unknown';
      const action = payload.action;
      const myId = window.ALIBOARD_USER_ID;

      if(fromId != null && myId != null && Number(fromId) === Number(myId)){
        return;
      }

      if(action === 'ring'){
        setPanelOpen(true);
        showIncomingCallBanner(fromRole);
        return;
      }

      if(action === 'end'){
        stopRingTone();
        if(incomingCallBanner && incomingCallBanner.parentNode){
          incomingCallBanner.parentNode.removeChild(incomingCallBanner);
          incomingCallBanner = null;
        }
        if(window.aliboardVoice && typeof window.aliboardVoice.hangupCall === 'function'){
          window.aliboardVoice.hangupCall(false);
        }
        appendMessage({
          text: '🔴 Połączenie zostało zakończone',
          author: 'other',
          timeString: getTimeString(),
        });
      }
    };

    // 🔹 WebRTC Voice Module
    window.aliboardVoice = window.aliboardVoice || {};
    window.aliboardVoice.sendSignal = window.aliboardVoice.sendSignal || function(){};

    let voicePc = null;
    let localStream = null;
    let isCallActive = false;
    let isCaller = false;
    let pendingOffer = null;

    const remoteAudio = document.getElementById('aliboard-remote-audio');
    const rtcConfig = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
    };

    async function ensureLocalStream(){
      if(localStream) return localStream;
      try{
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      }catch(err){
        console.error('[AliboardVoice] getUserMedia error', err);
        throw err;
      }
      return localStream;
    }

    function createPeerConnection(){
      if(voicePc) return voicePc;
      voicePc = new RTCPeerConnection(rtcConfig);
      voicePc.onicecandidate = (event)=>{
        if(event.candidate){
          window.aliboardVoice.sendSignal({
            type: 'webrtc_ice_candidate',
            candidate: event.candidate,
          });
        }
      };
      voicePc.ontrack = (event)=>{
        if(remoteAudio){
          remoteAudio.srcObject = event.streams[0];
        }
      };
      voicePc.onconnectionstatechange = ()=>{
        if(!voicePc) return;
        if(['failed','disconnected','closed'].includes(voicePc.connectionState)){
          window.aliboardVoice.hangupCall(false);
        }
      };
      return voicePc;
    }

    async function addLocalTracks(pc){
      const stream = await ensureLocalStream();
      stream.getTracks().forEach((track)=>{
        pc.addTrack(track, stream);
      });
    }

    async function processOffer(data){
      pendingOffer = null;
      const desc = new RTCSessionDescription(data.sdp);
      const pc = createPeerConnection();
      await pc.setRemoteDescription(desc);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      window.aliboardVoice.sendSignal({
        type: 'webrtc_answer',
        sdp: pc.localDescription,
      });
    }

    window.aliboardVoice.startOutgoingCall = async function(){
      if(isCallActive) return;
      isCaller = true;
      isCallActive = true;
      pendingOffer = null;
      const pc = createPeerConnection();
      await addLocalTracks(pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      window.aliboardVoice.sendSignal({
        type: 'webrtc_offer',
        sdp: pc.localDescription,
      });
    };

    window.aliboardVoice.acceptIncomingCall = async function(){
      if(isCallActive) return;
      isCaller = false;
      isCallActive = true;
      const pc = createPeerConnection();
      await addLocalTracks(pc);
      if(pendingOffer){
        try{
          await processOffer(pendingOffer);
        }catch(err){
          console.error('[AliboardVoice] processOffer error', err);
          window.aliboardVoice.hangupCall(false);
          throw err;
        }
      }
    };

    window.aliboardVoice.onOffer = async function(data){
      const fromId = data.from_id;
      if(fromId != null && window.ALIBOARD_USER_ID != null && Number(fromId) === Number(window.ALIBOARD_USER_ID)){
        return;
      }
      pendingOffer = data;
      if(isCallActive){
        try{
          await processOffer(data);
        }catch(err){
          console.error('[AliboardVoice] processOffer error', err);
          window.aliboardVoice.hangupCall(false);
        }
      }
    };

    window.aliboardVoice.onAnswer = async function(data){
      const fromId = data.from_id;
      if(fromId != null && window.ALIBOARD_USER_ID != null && Number(fromId) === Number(window.ALIBOARD_USER_ID)){
        return;
      }
      if(!voicePc) return;
      try{
        const desc = new RTCSessionDescription(data.sdp);
        await voicePc.setRemoteDescription(desc);
      }catch(err){
        console.error('[AliboardVoice] setRemoteDescription error', err);
        window.aliboardVoice.hangupCall(false);
      }
    };

    window.aliboardVoice.onIceCandidate = async function(data){
      const fromId = data.from_id;
      if(fromId != null && window.ALIBOARD_USER_ID != null && Number(fromId) === Number(window.ALIBOARD_USER_ID)){
        return;
      }
      if(!voicePc) return;
      try{
        await voicePc.addIceCandidate(new RTCIceCandidate(data.candidate));
      }catch(err){
        console.error('[AliboardVoice] ICE add error', err);
      }
    };

    window.aliboardVoice.hangupCall = function(sendSignal = true){
      isCallActive = false;
      isCaller = false;
      pendingOffer = null;
      stopRingTone();
      if(voicePc){
        voicePc.ontrack = null;
        voicePc.onicecandidate = null;
        voicePc.close();
        voicePc = null;
      }
      if(localStream){
        localStream.getTracks().forEach((track)=> track.stop());
        localStream = null;
      }
      if(remoteAudio){
        remoteAudio.srcObject = null;
      }
      if(incomingCallBanner && incomingCallBanner.parentNode){
        incomingCallBanner.parentNode.removeChild(incomingCallBanner);
        incomingCallBanner = null;
      }
      if(sendSignal && window.aliboardChat && typeof window.aliboardChat.sendCallSignal === 'function'){
        window.aliboardChat.sendCallSignal('end');
      }
    };

    if(callBtn){
      callBtn.addEventListener('click', ()=>{
        setPanelOpen(true);
        appendMessage({
          text: '📞 Próba rozpoczęcia rozmowy głosowej…',
          author: 'me',
          timeString: getTimeString(),
        });
        if(window.aliboardChat && typeof window.aliboardChat.sendCallSignal === 'function'){
          window.aliboardChat.sendCallSignal('ring');
        }
        window.aliboardVoice.startOutgoingCall()
          .catch((err)=>{
            console.error('[AliboardVoice] startOutgoingCall error', err);
            window.aliboardVoice.hangupCall();
          });
      });
    }

    function wireRealtimeBridge(){
      const tryAttach = ()=>{
        const realtime = window.AliboardRealtime;
        if(!realtime){
          setTimeout(tryAttach, 600);
          return;
        }
        if(typeof realtime.sendChatMessage === 'function'){
          window.aliboardChat.sendToServer = (text)=> realtime.sendChatMessage(text);
        }
        if(typeof realtime.sendChatPing === 'function'){
          window.aliboardChat.sendPing = ()=> realtime.sendChatPing();
        }
        if(typeof realtime.sendCallSignal === 'function'){
          window.aliboardChat.sendCallSignal = (action)=> realtime.sendCallSignal(action);
        }
        if(typeof realtime.sendChatMicState === 'function'){
          window.aliboardChat.toggleMic = (muted)=> realtime.sendChatMicState(muted);
        }
      };
      tryAttach();
    }

    wireRealtimeBridge();

    (function enableChatBubbleDrag(){
      const bubble = document.getElementById('aliboard-chat-bubble');
      if(!bubble) return;

      let dragging = false, startX=0, startY=0, startLeft=0, startTop=0;

      bubble.style.position = 'fixed';
      bubble.style.right = bubble.style.right || '16px';
      bubble.style.bottom = bubble.style.bottom || '16px';

      const onMove = (e)=>{
        if(!dragging) return;
        const x = e.clientX ?? (e.touches && e.touches[0]?.clientX);
        const y = e.clientY ?? (e.touches && e.touches[0]?.clientY);
        if(x==null || y==null) return;
        const dx = x - startX;
        const dy = y - startY;
        bubble.style.right = 'auto';
        bubble.style.bottom = 'auto';
        bubble.style.left = `${startLeft + dx}px`;
        bubble.style.top = `${startTop + dy}px`;
      };

      const onUp = ()=>{
        dragging = false;
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      };

      bubble.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        dragging = true;
        startX = e.clientX;
        startY = e.clientY;
        const rect = bubble.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      });
    })();
  })();

  // START
  if(!restoreLocal()){ createPage(false); }
  setTool(TOOLS.SELECT);
})();

/* === ALIBOARD: pokazuj przycisk wielkości czcionki tylko przy narzędziu Tekst === */
const textFontBtn = document.getElementById("textFontBtn");

function updateFontButtonVisibility(activeTool){
    if(activeTool === "text"){
        textFontBtn.classList.add("is-visible");
    } else {
        textFontBtn.classList.remove("is-visible");
    }
}

document.querySelectorAll('#tools .btn[data-tool]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
        const tool = btn.getAttribute('data-tool');
        updateFontButtonVisibility(tool);
    });
});
</script>
<script>
  (function(){
    const root = document.getElementById('aliboard-root');
    window.ALIBOARD_USER_ID = Number(root.dataset.userId);
    window.ALIBOARD_USER_ROLE = root.dataset.userRole || 'unknown';
  })();
</script>
<script>
  (function(){
    let roomId = window.ALIBOARD_ROOM_ID;
    if(!roomId){
      const root = document.getElementById('aliboard-root') || document.body;
      roomId = (root && root.dataset.roomId) || "{{ room_id|default:'local-test' }}";
      window.ALIBOARD_ROOM_ID = roomId;
    }
    window.ALIBOARD_CONFIG = {
      roomId,
      wsBase: "{% if request.is_secure %}wss{% else %}ws{% endif %}://{{ request.get_host }}/ws/aliboard/"
    };
  })();
</script>
<script src="{% static 'panel/js/aliboard_realtime.js' %}"></script>
</body>
</html>
