{% load static %}

<!DOCTYPE html>

<html lang="pl">

<head>

<meta charset="utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Aliboard 2.5 – PolubiszTo.pl (test)</title>



<!-- PDF render -->

<link rel="preload" as="script" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js">

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>



<!-- PDF export (klient) -->

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>



<style>

  :root{

    --brand:#0b74ff; --ink:#0b1320; --muted:#5b6777; --line:#e6edff;

    --bg:#f7f9fe; --radius:16px;

  }

  *{box-sizing:border-box}

  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);

    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}

  header{

    position:sticky; top:0; z-index:20; background:#fff; border-bottom:1px solid var(--line);

    display:flex; align-items:center; gap:12px; padding:10px 12px;

  }

  .left{ display:flex; flex-direction:column; gap:8px; min-width:260px; }

  .brand{display:flex;align-items:center;gap:10px}

  .brand .mark{width:40px;height:40px;border-radius:10px;display:grid;place-items:center;flex:0 0 auto;overflow:hidden}

  .brand .mark img{width:100%;height:100%;object-fit:contain}

  .state{font-size:12px;color:var(--muted)}

  .toolrow{

    display:flex;

    gap:8px;

    flex-wrap:nowrap;

    overflow:hidden !important;

    white-space:nowrap;

    align-items:center;

    padding-bottom:4px;

    position:relative;

  }

.btn,.seg{border:1px solid var(--line);background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer;font-weight:700}

.btn.primary{background:var(--brand);color:#fff;border-color:transparent}

.btn.is-active{ outline:2px solid var(--brand); outline-offset:2px }

.btn.is-disabled{ opacity:0.4; pointer-events:none; }

  .hidden{ display:none !important; }

  .toolrow .btn[data-tool]{position:relative;font-size:0;}

  .toolrow .btn[data-tool]::before{

    content:'';

    font-size:18px;

    line-height:1;

    display:inline-block;

  }

  .toolrow .btn[data-tool="select"]::before{ content:""; }

  .toolrow .btn[data-tool="pen"]::before{ content:""; }

  .toolrow .btn[data-tool="line"]::before{ content:""; }

  .toolrow .btn[data-tool="eraser"]::before{ content:""; }

  .toolrow .btn[data-tool="text"]{font-size:16px;}

  .toolrow .btn[data-tool="text"]::before{ content:"T"; font-size:16px; font-weight:700; }

  .toolrow .btn[data-tool="crop"]::before{ content:""; }

  .toolrow .btn[data-tool="figure"]::before{ content:""; }

  .right{margin-left:auto; display:flex; align-items:center;}

  .menu-wrap{position:relative}

  .menu-btn{

    display:inline-flex;

    align-items:center;

    justify-content:center;

    gap:0;

    width:78px;

    height:78px;

    padding:0;

    border:none;

    background:transparent;

    box-shadow:none;

    border-radius:999px;

  }

  .menu-btn .icon-img{ width:78px; height:78px; }

    .dropdown{

      position:absolute; right:0; top:calc(100% + 8px); min-width:240px;

      background:#fff; border:1px solid var(--line); border-radius:12px;

      box-shadow:0 12px 40px rgba(11,116,255,.12); padding:8px; display:none; z-index:30;

    }

  .dropdown.open{display:block}

    .drop-group{padding:6px 6px}

    .drop-title{font-size:12px; color:var(--muted); margin:4px 6px 6px}

    .drop-item{width:100%; text-align:left; background:#fff; border:1px solid var(--line);

      border-radius:10px; padding:8px 10px; cursor:pointer; margin:4px 0; text-decoration:none; color:inherit}

    .drop-row{display:flex; gap:6px; flex-wrap:wrap}

    .drop-item.primary{background:var(--brand);color:#fff;border-color:transparent}



  #toolsMoreBtn{

    display:none;

    align-items:center;

    justify-content:center;

    height:36px;

    padding:6px 10px;

    background:var(--brand);

    color:#fff;

    border:none;

    border-radius:10px;

    margin-left:8px;

  }



  #toolsMorePanel.dropdown{

    top:42px;

    right:0;

    left:auto;

    min-width:180px;

    z-index:50;

  }



  /* Obszar kartek */

  .wrap{

    height:calc(100% - 64px);

    overflow:auto;

    padding:16px;

    overscroll-behavior:contain;

    overflow-anchor:none;

    -webkit-overflow-scrolling:touch;

  }

  .pages{

    display:flex; flex-direction:column; align-items:center; gap:24px;

    overflow-anchor:none;

  }

  .page{

    position:relative; background:#fff; border:1px solid var(--line);

    border-radius:12px; box-shadow:0 8px 30px rgba(11,116,255,.10);

    width:min(1200px, 96vw); aspect-ratio: 1 / 1.4142; /* A4 portret */

    overflow:hidden;

  }

  .page canvas{ position:absolute; inset:0; width:100%; height:100%; }

  .page .grid, .page .overlay{ pointer-events:none; }

  .page .board{ touch-action:none; } /* blok gest?w przy rysowaniu */



  /* ZDALNE KURSORY (CRDT) ? kropka dok?adnie w miejscu rysowania */

  .remote-cursor{

    position:absolute;

    z-index:30;

    pointer-events:none;

    /* UWAGA: bez translate na kontenerze ? kotwica = punkt rysowania */

    width:0;

    height:0;

    font-size:11px;

    font-weight:600;

  }



  .remote-cursor-dot{

    position:absolute;

    left:0;

    top:0;

    width:10px;

    height:10px;

    border-radius:999px;

    transform:translate(-50%,-50%);  /* centrum kropki = punkt rysowania */

    background:#3b82f6;              /* kolor nadpisujemy w JS */

  }



  .remote-cursor-label{

    position:absolute;

    left:12px;        /* tekst troch? na prawo od kropki */

    top:-20px;        /* lekko nad kropk? */

    padding:2px 6px;

    border-radius:999px;

    background:rgba(15,23,42,.85);

    color:#fff;

    white-space:nowrap;

  }



  /* edytor tekstu inline */

  .text-editor{

    position:absolute; z-index:50; min-width:60px;

    border:1px solid var(--line); border-radius:8px; padding:6px 8px; background:#fff;

    font: 16px ui-sans-serif, system-ui, Arial; color: var(--ink);

    outline: none; box-shadow:0 6px 20px rgba(15,23,42,.15);

  }



  /* ramka cropa */

  .crop-rect{

    position:absolute; z-index:40; border:2px dashed #0b74ff; background:rgba(11,116,255,.06); pointer-events:none;

  }

  .crop-choice-backdrop{

    position:fixed; inset:0; background:rgba(15,23,42,.45); display:flex; align-items:center; justify-content:center;

    z-index:70; opacity:0; transition:opacity .15s ease;

  }

  .crop-choice-backdrop.open{ opacity:1; }

  .crop-choice-dialog{

    background:#fff; border-radius:16px; padding:20px 24px; max-width:90vw; box-shadow:0 18px 55px rgba(15,23,42,.25);

    display:flex; flex-direction:column; gap:16px; min-width:280px;

  }

  .crop-choice-dialog p{ margin:0; font-size:15px; color:#0b1320; }

  .crop-choice-actions{ display:flex; gap:12px; flex-wrap:wrap; }

  .crop-choice-actions button{

    flex:1 1 120px; border:none; border-radius:10px; font-weight:600; padding:10px 14px; cursor:pointer;

  }

  .crop-choice-actions button.primary{ background:var(--brand); color:#fff; }

  .crop-choice-actions button.secondary{ background:#eef3ff; color:#0b1320; }

  .crop-busy-toast{

    position:fixed; top:16px; left:50%; transform:translate(-50%, -10px);

    background:#0b1320; color:#fff; padding:8px 16px; border-radius:999px;

    font-size:14px; box-shadow:0 10px 30px rgba(11,19,32,.35);

    z-index:80; pointer-events:none; opacity:0; transition:opacity .2s ease, transform .2s ease;

  }

  .crop-busy-toast.show{ opacity:1; transform:translate(-50%,0); }

  .modal-backdrop{

    position:fixed; inset:0; background:rgba(2,15,46,.55); display:none;

    align-items:center; justify-content:center; z-index:90;

  }

  .modal-backdrop.open{ display:flex; }

  .modal{

    background:#fff; border-radius:18px; padding:24px; width:min(420px, 92vw);

    box-shadow:0 25px 80px rgba(2,15,46,.35); display:flex; flex-direction:column; gap:16px;

  }

  .modal h3{ margin:0; font-size:20px; }

  .modal p{ margin:0; color:var(--muted); }

  .modal label{ display:flex; flex-direction:column; gap:6px; font-weight:600; }

  .modal input[type="text"]{

    border:1px solid var(--line); border-radius:10px; padding:10px 12px; font-size:15px;

  }

  .modal-actions{ display:flex; justify-content:flex-end; gap:12px; flex-wrap:wrap; }

  .modal-actions .btn{

    border:none; border-radius:10px; padding:10px 16px; font-weight:600; cursor:pointer;

  }

  .modal-actions .btn.secondary{ background:#eef3ff; color:#0b1320; }

  .modal-actions .btn.primary{ background:var(--brand); color:#fff; }



  .footer{ position:fixed; right:12px; bottom:12px; display:flex; gap:8px; flex-wrap:wrap; z-index:25; }



  /* mobile tap UX */

  .toolrow .btn { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }



  /* === PATCH: delikatne, ma?e narz?dzia bez ?grubej ramki? === */

.toolrow .btn,

.toolrow label.btn{

  border:0 !important;

  box-shadow:none !important;

  background:transparent !important;

  padding:4px 6px !important;

  border-radius:8px !important;

}



.toolrow .btn:hover{

  background:rgba(11,116,255,0.08) !important;

}



.toolrow .btn.is-active{

  background:rgba(11,116,255,0.18) !important;

  color:var(--ink) !important;

  outline:none !important;

}



.toolrow .btn:focus-visible{

  outline:1px solid var(--brand) !important;

  outline-offset:2px !important;

}



.toolrow .btn input[type="color"],

.toolrow .btn select{

  border:0 !important;

  background:transparent !important;

  box-shadow:none !important;

}

.text-font-btn{ display:none; }

.text-font-btn.is-visible{ display:inline-flex; }



/* === ALIBOARD: Ikona wielko?ci czcionki (estetyczna) === */

#textFontBtn{

  font-size:20px !important;

  padding:4px 6px !important;

  line-height:1;

}



/* MENU WIELKO?CI CZCIONKI (AI Neon Premium) */

.font-size-menu {

  position: fixed;

  top: -9999px;

  left: -9999px;

  background: #fff;

  padding: 7px 8px;

  border-radius: 7px;

  display: none;

  flex-direction: column;

  gap: 8px;

  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12);

  z-index: 5000;

}

.font-size-menu.open{

  display:flex;

}



.font-option {

  width: 39px;

  height: 27px;

  border-radius: 6px;

  background: rgba(0, 0, 0, 0.04);

  cursor: pointer;

  display: flex;

  justify-content: center;

  align-items: center;

  transition: 0.25s ease;

}



.font-option:hover {

  background: rgba(0, 150, 255, 0.12);

  box-shadow: 0 0 10px rgba(0, 150, 255, 0.2);

}



.font-option.active {

  background: rgba(0, 150, 255, 0.2);

  box-shadow: 0 0 12px rgba(0, 150, 255, 0.35);

}



.font-preview {

  color: #0b74ff;

  font-family: "Arial", sans-serif;

  font-weight: 600;

  text-shadow: none;

  user-select: none;

}



/* cia?niejszy pasek narz?dzi na telefonie */

@media (max-width: 900px){

  .toolrow{

    gap:4px;

  }

  .toolrow .btn{

    padding:4px 4px !important;

  }

}



    /* === FIGURY - nowe, pomniejszone okienko === */

  .figure-palette{

    position:absolute;

    z-index:26;

    background:#ffffff;

    border:1px solid var(--line);

    border-radius:14px;

    box-shadow:0 14px 32px rgba(11,116,255,.18);

    padding:6px;

    display:none;

    min-width:126px;

  }

  .figure-palette.open{ display:block; }

  .figure-palette-grid{

    display:grid;

    grid-template-columns:repeat(3, 1fr);

    gap:5px;

  }

  .figure-palette .shape-btn{

    position:relative;

    display:inline-flex;

    align-items:center;

    justify-content:center;

    width:35px;

    height:28px;

    border-radius:7px;

    border:1px solid rgba(148,163,184,0.4);

    background:linear-gradient(135deg,#f9fbff,#eef3ff);

    cursor:pointer;

    padding:0;

    transition:

      border-color .15s ease-out,

      box-shadow .15s ease-out,

      transform .06s ease-out,

      background .15s ease-out;

  }

  .figure-palette .shape-btn:hover{

    border-color:var(--brand);

    box-shadow:0 8px 18px rgba(15,23,42,0.16);

    transform:translateY(-1px);

  }

  .figure-palette .shape-btn.is-active{

    border-color:var(--brand);

    box-shadow:0 0 0 1px rgba(11,116,255,0.25);

  }

  .figure-palette .shape-icon{

    position:relative;

    width:16px;

    height:16px;

  }

  /* Prostokat */

  .figure-palette .shape-icon--rect{

    border-radius:4px;

    border:1.5px solid #0f172a;

    background:rgba(15,23,42,0.02);

  }

  /* Trojkat rownoramienny */

  .figure-palette .shape-icon--triangle{

    width:0;

    height:0;

    border-left:8px solid transparent;

    border-right:8px solid transparent;

    border-bottom:14px solid #0f172a;

    transform:translateY(1px);

  }

  /* Trojkat prostokatny */

  .figure-palette .shape-icon--right{

    width:0;

    height:0;

    border-bottom:14px solid #0f172a;

    border-right:14px solid transparent;

    transform:translateY(1px);

  }

  /* Szesciokat */

  .figure-palette .shape-icon--hex{

    width:16px;

    height:9px;

    background:#0f172a;

    position:relative;

  }

  .figure-palette .shape-icon--hex::before,

  .figure-palette .shape-icon--hex::after{

    content:"";

    position:absolute;

    left:0;

    right:0;

    margin:auto;

    border-left:8px solid transparent;

    border-right:8px solid transparent;

  }

  .figure-palette .shape-icon--hex::before{

    top:-5px;

    border-bottom:5px solid #0f172a;

  }

  .figure-palette .shape-icon--hex::after{

    bottom:-5px;

    border-top:5px solid #0f172a;

  }

  /* Kolo */

  .figure-palette .shape-icon--circle{

    border-radius:999px;

    border:1.5px solid #0f172a;

    background:rgba(15,23,42,0.02);

  }

  /* drobne scisniecie na telefonie */

  @media (max-width:900px){

    .figure-palette{

      transform:translateY(6px);

      padding:5px;

    }

    .figure-palette .shape-btn{

      width:31px;

      height:25px;

    }

  }

/* === FIX: przywr?cenie widoczno?ci ikon narz?dzi Aliboard === */

.toolrow .btn[data-tool]{

  font-size:18px !important;

  line-height:1;

}

.toolrow .btn[data-tool]::before{

  content:none !important;

}



/* Aliboard Chat – bazowe zmienne */

:root{

  --aliboard-chat-bg: rgba(9, 18, 40, 0.96);

  --aliboard-chat-accent: #0b74ff;

  --aliboard-chat-accent-soft: rgba(11, 116, 255, 0.25);

  --aliboard-chat-border: rgba(255, 255, 255, 0.12);

  --aliboard-chat-text: #f9fbff;

  --aliboard-chat-muted: #a5b3d1;

}

.aliboard-chat-root{

  position:fixed;

  right:16px;

  bottom:16px;

  z-index:9999;

}

.aliboard-chat-root.desktop-offset{

  bottom:72px;

}

.aliboard-chat-bubble{

  display:inline-flex;

  align-items:center;

  justify-content:center;

  width:46px;

  height:46px;

  position:relative;

  border-radius:999px;

  border:none;

  cursor:pointer;

  background:transparent;

  box-shadow:none;

  font-size:24px;

  transition:transform 0.15s ease-out, box-shadow 0.15s ease-out, opacity 0.15s ease-out;

  color:#fff;

}

.aliboard-chat-bubble:hover{

  transform:translateY(-1px) scale(1.03);

  box-shadow:none;

}

.aliboard-chat-bubble:active{

  transform:translateY(0) scale(0.97);

  box-shadow:none;

}

.aliboard-chat-panel{

  position:fixed;

  right:16px;

  bottom:76px;

  width:320px;

  max-height:60vh;

  display:flex;

  flex-direction:column;

  background:var(--aliboard-chat-bg);

  border-radius:18px;

  border:1px solid var(--aliboard-chat-border);

  box-shadow:0 18px 50px rgba(0,0,0,0.6);

  overflow:hidden;

  opacity:0;

  transform:translateY(12px) scale(0.96);

  pointer-events:none;

  transition:opacity 0.16s ease-out, transform 0.16s ease-out;

}

.aliboard-chat-panel.is-open{

  opacity:1;

  transform:translateY(0) scale(1);

  pointer-events:auto;

}

.aliboard-chat-header{

  display:flex;

  align-items:center;

  justify-content:space-between;

  padding:10px 12px 8px;

  background:linear-gradient(135deg, rgba(11,116,255,0.28), rgba(11,116,255,0.02));

  border-bottom:1px solid var(--aliboard-chat-border);

}

.aliboard-chat-title{

  display:flex;

  flex-direction:column;

}

.aliboard-chat-title-main{

  font-size:13px;

  font-weight:600;

  color:var(--aliboard-chat-text);

}

.aliboard-chat-title-sub{

  font-size:11px;

  color:var(--aliboard-chat-muted);

}

.aliboard-chat-actions{

  display:inline-flex;

  align-items:center;

  gap:4px;

}

.aliboard-chat-icon-btn{

  border:none;

  background:transparent;

  color:var(--aliboard-chat-text);

  cursor:pointer;

  border-radius:999px;

  width:28px;

  height:28px;

  display:inline-flex;

  align-items:center;

  justify-content:center;

  font-size:14px;

  transition:background 0.12s ease-out, transform 0.08s ease-out;

}

.aliboard-chat-icon-btn:hover{

  background:rgba(255,255,255,0.09);

}

.aliboard-chat-icon-btn:active{

  transform:scale(0.92);

}

.aliboard-select{

  height:28px;

  padding:4px 6px;

  border-radius:8px;

  border:1px solid var(--aliboard-chat-border);

  background:rgba(15,23,42,0.85);

  color:var(--aliboard-chat-text);

  font-size:11px;

  outline:none;

}

.aliboard-select:focus{

  border-color:var(--aliboard-chat-accent);

  box-shadow:0 0 0 1px var(--aliboard-chat-accent-soft);

}

.aliboard-chat-messages,

#aliboard-chat-messages{

  flex:1;

  padding:8px 8px 6px;

  display:flex;

  flex-direction:column;

  align-items:stretch;

  gap:4px;

  overflow-y:auto;

  scrollbar-width:thin;

  scrollbar-color:rgba(255,255,255,0.22) transparent;

}

.aliboard-chat-messages::-webkit-scrollbar{

  width:6px;

}

.aliboard-chat-messages::-webkit-scrollbar-track{

  background:transparent;

}

.aliboard-chat-messages::-webkit-scrollbar-thumb{

  background:rgba(255,255,255,0.22);

  border-radius:999px;

}

.aliboard-chat-message{

  max-width:80%;

  padding:6px 10px;

  border-radius:12px;

  font-size:13px;

  line-height:1.35;

  display:inline-block;

  align-self:flex-start;

  word-wrap:break-word;

  white-space:pre-wrap;

}

/* JA -> po PRAWEJ */

.aliboard-chat-message.me{

  align-self:flex-end;

  background:#0b74ff;

  color:#fff;

}

/* DRUGA OSOBA -> po LEWEJ */

.aliboard-chat-message.other{

  align-self:flex-start;

  background:rgba(15,23,42,0.85);

  color:#fff;

  border:1px solid #344155;

}

.aliboard-chat-row{

  display:flex;

  flex-direction:column;

  margin-bottom:6px;

  max-width:100%;

}

.aliboard-chat-row.mine{

  align-items:flex-end;

}

.aliboard-chat-row.theirs{

  align-items:flex-start;

}

.aliboard-chat-author{

  font-size:11px;

  color:var(--aliboard-chat-muted);

  margin:0 2px 2px;

}

.aliboard-chat-row .aliboard-chat-message{

  max-width:100%;

}

.aliboard-chat-row.mine .aliboard-chat-message{

  align-self:flex-end;

}

.aliboard-chat-row.theirs .aliboard-chat-message{

  align-self:flex-start;

}

.aliboard-chat-meta{

  display:block;

  margin-top:2px;

  font-size:10px;

  color:var(--aliboard-chat-muted);

}

.aliboard-chat-input-row{

  display:flex;

  align-items:center;

  gap:6px;

  padding:6px 8px 8px;

  border-top:1px solid var(--aliboard-chat-border);

  background:rgba(7,12,25,0.98);

}

.aliboard-chat-input{

  flex:1;

  border-radius:999px;

  border:1px solid rgba(148,163,184,0.6);

  padding:6px 10px;

  font-size:12px;

  background:rgba(15,23,42,0.7);

  color:var(--aliboard-chat-text);

  outline:none;

}

.aliboard-chat-input::placeholder{

  color:var(--aliboard-chat-muted);

}

.aliboard-chat-input:focus{

  border-color:var(--aliboard-chat-accent);

  box-shadow:0 0 0 1px var(--aliboard-chat-accent-soft);

}

.aliboard-chat-send-btn{

  border:none;

  border-radius:999px;

  padding:6px 10px;

  font-size:11px;

  font-weight:500;

  background:var(--aliboard-chat-accent);

  color:#fff;

  cursor:pointer;

  transition:transform 0.08s ease-out, box-shadow 0.08s ease-out, opacity 0.08s ease-out;

  white-space:nowrap;

}

.aliboard-chat-send-btn:hover{

  box-shadow:0 8px 20px rgba(0,0,0,0.45);

}

.aliboard-chat-send-btn:active{

  transform:scale(0.94);

  box-shadow:none;

}

.aliboard-call-banner{

  padding:6px 10px;

  font-size:12px;

  background:rgba(34,197,94,0.16);

  color:#bbf7d0;

  border-bottom:1px solid rgba(34,197,94,0.5);

  display:flex;

  align-items:center;

  gap:8px;

}

.aliboard-call-actions{

  margin-left:auto;

  display:flex;

  align-items:center;

  gap:4px;

}

.aliboard-call-accept-btn,

.aliboard-call-end-btn{

  padding:4px 8px;

  border-radius:6px;

  border:1px solid transparent;

  font-size:11px;

  cursor:pointer;

  transition:background 0.15s ease-out, transform 0.1s ease-out;

}

.aliboard-call-accept-btn{

  background:rgba(34,197,94,0.3);

  border-color:rgba(34,197,94,0.6);

  color:#bbf7d0;

}

.aliboard-call-accept-btn:hover{

  background:rgba(34,197,94,0.5);

}

.aliboard-call-end-btn{

  background:rgba(239,68,68,0.25);

  border-color:rgba(239,68,68,0.5);

  color:#fecaca;

}

.aliboard-call-end-btn:hover{

  background:rgba(239,68,68,0.4);

}

.aliboard-call-accept-btn:active,

.aliboard-call-end-btn:active{

  transform:scale(0.95);

}

.aliboard-chat-badge{

  position:absolute;

  top:-4px;

  right:-4px;

  min-width:16px;

  height:16px;

  padding:0 4px;

  border-radius:999px;

  background:#ef4444;

  color:#fff;

  font-size:10px;

  font-weight:600;

  display:flex;

  align-items:center;

  justify-content:center;

}

.aliboard-chat-badge-hidden{

  display:none;

}

.aliboard-chat-icon-btn.is-muted{

  background:rgba(239,68,68,0.2);

  color:#fecaca;

}

@media (max-width:768px){

  .aliboard-chat-root{

    right:10px;

    bottom:10px;

  }

  .aliboard-chat-panel{

    right:0;

    left:0;

    bottom:0;

    margin:0 auto;

    width:100%;

    max-width:100%;

    max-height:60vh;

    border-radius:18px 18px 0 0;

  }

}



/* === ALIBOARD: wyra?ne pod?wietlenie aktywnego narz?dzia === */

.toolrow .btn[data-tool].is-active{

  background: rgba(11,116,255,0.14) !important;

  color: #0b1320 !important;

  outline: none !important;

  border-radius: 10px;

  box-shadow: 0 0 0 2px var(--brand);

}



/* nieaktywne ikony delikatnie przygaszone, ?eby aktywne si? wyr??nia?o */

.toolrow .btn[data-tool]:not(.is-active){

  opacity: 0.8;

}

.toolrow .btn[data-tool]:not(.is-active):hover{

  opacity: 1;

}



/* === ALIBOARD: uk?ad nag??wka + narz?dzi na telefonie === */

@media (max-width: 768px){



  /* nag??wek nadal w jednym rz?dzie:

     [logo+Aliboard] po lewej, [Menu] po prawej */

  header{

    flex-direction: row;

    align-items: flex-start;

    gap: 8px;

  }



  /* lewa cz??? (logo + pasek narz?dzi) mo?e si? ?cisn?? */

  .left{

    flex: 1 1 auto;

    min-width: 0;

  }



  /* prawa cz??? ? menu przy logo po prawej */

  .right{

    margin-left: 8px;

    flex: 0 0 auto;

  }



  .menu-wrap{

    flex-shrink: 0;

  }



  .menu-btn{

    width:78px;

    height:78px;

    padding:0 !important;

    font-size:0;

    border:none !important;

    background:transparent !important;

    display:inline-flex;

    align-items:center;

    justify-content:center;

    gap:0;

    box-shadow:none !important;

    border-radius:999px !important;

  }

  .menu-btn .icon-img{ width:78px; height:78px; }



  /* pasek narz?dzi POD logo, mo?e zej?? w 2 rz?dy */

  .toolrow{

    flex-wrap: wrap;

    overflow: visible !important;

    justify-content: flex-start;

    margin-top: 4px;

    gap: 4px;

  }



  /* wszystkie narzędzia mają być widoczne – wyłączamy overflow na telefonie */

  #toolsMoreBtn,

  #toolsMorePanel{

    display: none !important;

  }



  /* cia?niejsze przyciski, ?eby wszystko si? mie?ci?o */

  .toolrow .btn,

  .toolrow label.btn{

    padding: 4px 6px;

    font-size: 16px;

  }



  /* select z grubo?ci? ? troch? w??szy */

  .toolrow label.btn select{

    max-width: 72px;

  }

}



/* === ALIBOARD: Ikona przycisku Usu? (zaznaczony element) === */

#deleteSelection{

  font-size:18px !important;

  padding:4px 6px !important;

  line-height:1;

}



/* === ALIBOARD: menu grubo?ci linii (neon) === */

  .line-width-menu {

    position: fixed;

    top: -9999px;

    left: -9999px;

    background: #fff;

    padding: 6px 7px;

    border-radius: 8px;

    display: none;

    flex-direction: column;

    gap: 7px;

    box-shadow: 0 4px 25px rgba(0, 150, 255, 0.25);

    backdrop-filter: blur(10px);

    z-index: 5000;

  }



  .line-width-menu.open{

    display:flex;

  }



.line-option {

  width: 24px;

  height: 24px;

  border-radius: 6px;

  background: rgba(255, 255, 255, 0.05);

  cursor: pointer;

  display: flex;

  justify-content: center;

  align-items: center;

  transition: 0.25s ease;

}



.line-option:hover {

  background: rgba(0, 150, 255, 0.15);

  box-shadow: 0 0 12px rgba(0, 150, 255, 0.35);

}



.line-option.active {

  background: rgba(0, 150, 255, 0.3);

  box-shadow: 0 0 15px rgba(0, 150, 255, 0.55);

}



.line-preview {

  width: 14px;

  background: #0cbcff;

  border-radius: 3px;

  box-shadow: 0 0 6px #0cbcff;

}



/* Ikony obrazkowe w pasku narz?dzi */

.icon-img{

  width:26px;

  height:26px;

  object-fit:contain;

  display:block;

  pointer-events:none;

}

.aliboard-chat-bubble .icon-img{

  width:78px;

  height:78px;

}



</style>

</head>

<body id="aliboard-root" data-room-id="{{ room_id|default:'local-test' }}" data-user-id="{{ request.user.id }}" data-user-role="{{ user_role|default:'unknown' }}">

<header>

  <!-- LEWA: brand + narz?dzia -->

  <div class="left">

    <div class="brand">

      <div class="mark">

        <!-- Sama g?owa loga -->

        <img src="{% static 'img/brand/logo_head.png' %}" alt="PolubiszTo.pl" />

      </div>

      <div>

        <div style="font-weight:800">Aliboard</div>

        <div class="state" id="state">Tryb: Kursor • 3px • #0b74ff</div>

      </div>

    </div>



    <div class="toolrow" id="tools">

      <button class="btn" type="button" data-tool="select" title="Kursor (V)">

        <img src="{% static 'img/icons/cursor_ai.png' %}" class="icon-img" alt="Kursor">

      </button>

      <button class="btn" type="button" data-tool="pen"    title="Ołówek (P)">

        <img src="{% static 'img/icons/pen_ai.png' %}" class="icon-img" alt="Ołówek">

      </button>

      <button class="btn" type="button" data-tool="line"   title="Linia (L)">

        <img src="{% static 'img/icons/line_ai.png' %}" class="icon-img" alt="Linia">

      </button>

      <button class="btn" type="button" data-tool="eraser" title="Gumka (E)">

        <img src="{% static 'img/icons/eraser_ai.png' %}" class="icon-img" alt="Gumka">

      </button>

      <button class="btn" type="button" data-tool="text"   title="Tekst (T)">

        <img src="{% static 'img/icons/text_ai.png' %}" class="icon-img" alt="Tekst">

      </button>

      <button class="btn text-font-btn" type="button" id="textFontBtn" title="Wielkość czcionki" data-overflow="1">

        <img src="{% static 'img/icons/font_size_ai.png' %}" class="icon-img" alt="Wielkość czcionki">

      </button>

      <button class="btn" type="button" data-tool="crop"   title="Kopiuj (C)">

        <img src="{% static 'img/icons/copy_ai.png' %}" class="icon-img" alt="Kopiuj">

      </button>

      <button class="btn" type="button" data-tool="figure" title="Figury (F)" data-overflow="1">

        <img src="{% static 'img/icons/figure_ai.png' %}" class="icon-img" alt="Figury">

      </button>



      <label class="btn" title="Kolor pisaka">

        <img src="{% static 'img/icons/color_ai.png' %}" class="icon-img" alt="Kolor">

        <input type="color" id="color" value="#0b74ff" style="display:none;">

      </label>

      <button class="btn" type="button" id="lineWidthBtn" title="Grubość linii">

        <img src="{% static 'img/icons/size_ai.png' %}" class="icon-img" alt="Grubość linii">

      </button>

      <div class="line-width-menu" id="lineWidthMenu">

        <div class="line-option" data-size="1">

          <div class="line-preview" style="height:1px"></div>

        </div>

        <div class="line-option" data-size="3">

          <div class="line-preview" style="height:3px"></div>

        </div>

        <div class="line-option" data-size="5">

          <div class="line-preview" style="height:5px"></div>

        </div>

        <div class="line-option" data-size="8">

          <div class="line-preview" style="height:8px"></div>

        </div>

      </div>

      <select id="size" style="display:none;">

        <option value="1">1px</option>

        <option value="3" selected>3px</option>

        <option value="5">5px</option>

        <option value="8">8px</option>

      </select>



      <!-- Ikony: obraz + pdf -->

      <label class="btn" title="Wstaw obraz">

        <img src="{% static 'img/icons/image_ai.png' %}" class="icon-img" alt="Wstaw obraz">

        <input id="imgInput" type="file" accept="image/*" style="display:none">

      </label>

      <label class="btn" title="Wstaw PDF">

        <img src="{% static 'img/icons/pdf_ai.png' %}" class="icon-img" alt="Wstaw PDF">

        <input id="pdfInput" type="file" accept="application/pdf" style="display:none">

      </label>



      <button class="btn is-disabled" type="button" id="deleteSelection" title="Usuń zaznaczony obiekt" disabled>

        X

      </button>

    </div>

  </div>



  <!-- PRAWA: MENU -->

  <div class="right">

    <div class="menu-wrap">

      <button class="btn menu-btn" type="button" id="menuBtn" aria-expanded="false" aria-controls="dropdown" title="Menu">

        <img src="{% static 'img/icons/menu_ai.png' %}" class="icon-img" alt="Menu">

      </button>

      <div class="dropdown" id="dropdown" role="menu" aria-labelledby="menuBtn">

        <div class="drop-group">

          <a href="{% url 'aliboard_new_room' %}" target="_blank" class="drop-item btn-aliboard" id="openBoardBtn">

            Nowa Tablica

          </a>

        </div>

        <div class="drop-group">

          <button class="drop-item" type="button" id="undo" title="Cofnij (Ctrl+Z)">Cofnij</button>

        </div>

        <div class="drop-group">

          <button class="drop-item" type="button" id="saveToggle">Zapisz</button>

          <div class="drop-row" id="saveRow" style="display:none">

            <button class="drop-item" type="button" id="savePng">PNG</button>

            <button class="drop-item" type="button" id="saveJpg">JPG</button>

            <button class="drop-item" type="button" id="savePdf">PDF</button>

          </div>

        </div>

        <div class="drop-group">

          <button class="drop-item" type="button" id="templatesToggle">Szablony</button>

          <button class="drop-item" type="button" id="gridToggle" style="display:none">Siatka</button>

          <div class="drop-row" id="templatesRow" style="display:none">

            <button class="drop-item" type="button" data-grid="0">Brak</button>

            <button class="drop-item" type="button" data-grid="16">Mała</button>

            <button class="drop-item" type="button" data-grid="24">Średnia</button>

            <button class="drop-item" type="button" data-grid="32">Duża</button>

            <button class="drop-item" type="button" data-grid="tech">Papier milimetrowy</button>

          </div>

        </div>

        <div class="drop-group">

          <div class="drop-title">Nowa tablica</div>

          <div class="drop-row">

            <button class="drop-item" type="button" id="addPage">+ Dodaj kartkę A4</button>

          </div>

        </div>

      </div>

    </div>

  </div>

</header>



<div class="wrap" id="wrap">

  <div class="pages" id="pages"></div>

</div>



<!-- Aliboard Chat Module -->

<div class="aliboard-chat-root">

  <button class="aliboard-chat-bubble" id="aliboard-chat-bubble" type="button" aria-label="Otwórz czat">

    <img src="{% static 'img/icons/chat_ai.png' %}" class="icon-img" alt="Czat">

  </button>



  <section class="aliboard-chat-panel" id="aliboard-chat-panel" aria-hidden="true">

    <header class="aliboard-chat-header">

      <div class="aliboard-chat-title">

        <span class="aliboard-chat-title-main">Czat zajęć</span>

        <span class="aliboard-chat-title-sub">Aliboard</span>

      </div>

      <div class="aliboard-chat-actions">

        <button type="button" class="aliboard-chat-icon-btn" id="aliboard-chat-ping" title="Zaczep">

          &#128276;

        </button>
        <button type="button" class="aliboard-chat-icon-btn" id="aliboard-chat-call" title="Rozmowa głosowa">

          &#128222;

        </button>
        <button type="button" class="aliboard-call-end-btn hidden" id="aliboard-call-hangup-btn" title="Rozłącz połączenie">
          Rozłącz
        </button>

        <select id="aliboard-call-mode" class="aliboard-select" title="Tryb rozmowy">

          <option value="1">1-1</option>

          <option value="4">1-4</option>

          <option value="30">1-30</option>

        </select>

        <button type="button" class="aliboard-chat-icon-btn" id="aliboard-chat-mic" title="Wycisz/odcisz mikrofon">

          &#127908;

        </button>

        <button type="button" class="aliboard-chat-icon-btn" id="aliboard-chat-close" title="Zamknij czat">

          &#10006;

        </button>

      </div>

    </header>

    <!-- Audio remote dla WebRTC -->

    <audio id="aliboard-remote-audio" autoplay playsinline style="display:none;"></audio>



    <div class="aliboard-chat-messages" id="aliboard-chat-messages" aria-live="polite"></div>



    <form class="aliboard-chat-input-row" id="aliboard-chat-form" autocomplete="off">

      <input

        type="text"

        id="aliboard-chat-input"

        class="aliboard-chat-input"

        placeholder="Napisz wiadomość"

        maxlength="500"

      />

      <button type="submit" class="aliboard-chat-send-btn">

        Wyślij

      </button>

    </form>

  </section>

</div>

<!-- koniec: Aliboard Chat Module -->



<div class="footer" style="left:12px; right:auto;">

  <span class="btn" id="roomInfo" title="Room ID z query string">room_id: {{ room_id|default:'local-test' }}</span>

</div>



<div class="modal-backdrop" id="openBoardModal" aria-hidden="true">

  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="openBoardTitle">

    <h3 id="openBoardTitle">Otwórz nową tablicę</h3>

    <p>Utwórz pustą tablicę. Aktualne karty zostaną zamknięte.</p>

    <label>

      Nazwa tablicy (opcjonalnie)

      <input type="text" id="openBoardName" placeholder="np. Matematyka - lekcja 3">

    </label>

    <div class="modal-actions">

      <button type="button" class="btn secondary" id="openBoardCancel">Anuluj</button>

      <button type="button" class="btn primary" id="openBoardCreate">Utwórz</button>

    </div>

  </div>

</div>



<script src="{% static 'panel/js/aliboard_crdt_core.js' %}"></script>



<script>

(function(){

  /* === PATCH: wstrzykni?cie delikatnego CSS dla paska narz?dzi (bez kapsli) === */

  const __css = `

  .toolrow .btn, .toolrow label.btn{border:0 !important;background:transparent !important;box-shadow:none !important}

  .toolrow .btn.is-active{background:transparent !important;color:var(--ink) !important;outline:2px solid var(--brand);outline-offset:2px;border-radius:10px}

  .toolrow .btn:focus-visible{outline:2px solid var(--brand);outline-offset:2px}

  .toolrow .btn input[type="color"], .toolrow .btn select{border:0 !important;background:transparent !important;box-shadow:none !important}

  @media (max-width: 900px){ .toolrow{gap:4px} .toolrow .btn{padding:6px 8px} }`;

  const styleEl = document.createElement('style'); styleEl.textContent = __css; document.head.appendChild(styleEl);



  /* ---------- STAN GLOBALNY ---------- */

  const wrapEl  = document.getElementById('wrap');

  const pagesEl = document.getElementById('pages');

  const stateEl = document.getElementById('state');

  let figureBtn = document.querySelector('[data-tool="figure"]');

  let figurePalette = null;

  let selectionRotateEnabled = false;

  const textFontBtn = document.getElementById('textFontBtn');

  const deleteSelectionBtn = document.getElementById('deleteSelection');

  let textFontPanel = null;

  const TEXT_FONT_MIN = 14;

  const TEXT_FONT_MAX = 96;

  const TEXT_FONT_STEP = 2;



    function ensureFigurePalette(){

    if(figurePalette) return;

    figurePalette = document.createElement('div');

    figurePalette.className = 'figure-palette';

    figurePalette.innerHTML = `

      <div class="figure-palette-grid">

        <button class="shape-btn" type="button" data-shape="rect" title="Prostokąt">

          <div class="shape-icon shape-icon--rect"></div>

        </button>

        <button class="shape-btn" type="button" data-shape="tri_iso" title="Trójkąt równoramienny">

          <div class="shape-icon shape-icon--triangle"></div>

        </button>

        <button class="shape-btn" type="button" data-shape="tri_right" title="Trójkąt prostokątny">

          <div class="shape-icon shape-icon--right"></div>

        </button>

        <button class="shape-btn" type="button" data-shape="hex" title="Sześciokąt">

          <div class="shape-icon shape-icon--hex"></div>

        </button>

        <button class="shape-btn" type="button" data-shape="circle" title="Koło">

          <div class="shape-icon shape-icon--circle"></div>

        </button>

      </div>

    `;

    document.body.appendChild(figurePalette);

    updateFigurePaletteSelection();

  }



  function positionFigurePalette(){

    const btn = document.querySelector('[data-tool="figure"]');

    if(btn) figureBtn = btn;

    if(!figureBtn || !figurePalette) return;

    const r = figureBtn.getBoundingClientRect();

    figurePalette.style.left = r.left + 'px';

    figurePalette.style.top  = (r.bottom + 8) + 'px';

  }



  function updateFigurePaletteSelection(){

    if(!figurePalette) return;

    figurePalette.querySelectorAll('.shape-btn').forEach(b=>{

      b.classList.toggle('is-active', b.getAttribute('data-shape')===currentShape);

    });

  }



  function toggleFigurePalette(forceOpen){

    const open = (typeof forceOpen==='boolean') ? forceOpen : !figurePalette?.classList.contains('open');

    if(open){

      ensureFigurePalette();

      positionFigurePalette();

      figurePalette.classList.add('open');

    }else if(figurePalette){

      figurePalette.classList.remove('open');

    }

  }



  const TOOLS = { SELECT:'select', PEN:'pen', LINE:'line', ERASER:'eraser', TEXT:'text', CROP:'crop', FIGURE:'figure' };

  let tool = TOOLS.SELECT, color = '#0b74ff', size = 3;
  const BASE_PHONE_WIDTH_PX = 360;
  const GRID_STEPS_ON_PHONE = { sm: 18, md: 26, lg: 34 };
  function computeStepPx(gridSizeKey, canvasWidth) {
    const stepOnPhone = GRID_STEPS_ON_PHONE[gridSizeKey] || GRID_STEPS_ON_PHONE.md;
    const scale = (canvasWidth || BASE_PHONE_WIDTH_PX) / BASE_PHONE_WIDTH_PX;
    return Math.max(6, Math.round(stepOnPhone * scale));
  }

  let textFontSizePx = Math.max(TEXT_FONT_MIN, size*6);

  let lastBrushSize = size;

  let currentShape = 'rect';

  const TEMPLATE_KINDS = {

    NONE: 'none',

    GRID_SMALL: 'grid-small',

    GRID_MEDIUM: 'grid-medium',

    GRID_LARGE: 'grid-large',

    GRID_TECH: 'grid-tech',

    LINED: 'lined'

  };



  function normalizeTemplateKind(rawKind, sizeHint){

    if(typeof rawKind === 'object' && rawKind !== null && 'templateKind' in rawKind){

      return normalizeTemplateKind(rawKind.templateKind, rawKind.gridSize ?? rawKind.size);

    }

    let sizeNum = Number.isFinite(sizeHint) ? sizeHint : parseInt(sizeHint, 10);

    const sizeStr = typeof sizeHint === 'string' ? sizeHint.toLowerCase() : '';

    const rawStr = typeof rawKind === 'string' ? rawKind.trim().toLowerCase() : '';

    if((!Number.isFinite(sizeNum)) && rawStr && /^[0-9]+$/.test(rawStr)){

      sizeNum = parseInt(rawStr, 10);

    }

    if(rawStr === 'grid-tech' || rawStr === 'tech' || sizeStr === 'tech'){ return TEMPLATE_KINDS.GRID_TECH; }

    if(rawStr === 'lined' || rawStr === 'line'){ return TEMPLATE_KINDS.LINED; }

    if(rawStr === 'grid-small' || rawStr === 'small' || sizeNum === 16){ return TEMPLATE_KINDS.GRID_SMALL; }

    if(rawStr === 'grid-medium' || rawStr === 'medium' || sizeNum === 24){ return TEMPLATE_KINDS.GRID_MEDIUM; }

    if(rawStr === 'grid-large' || rawStr === 'large' || sizeNum === 32){ return TEMPLATE_KINDS.GRID_LARGE; }

    if(rawStr === 'grid' && sizeNum){

      if(sizeNum <= 18){ return TEMPLATE_KINDS.GRID_SMALL; }

      if(sizeNum <= 26){ return TEMPLATE_KINDS.GRID_MEDIUM; }

      return TEMPLATE_KINDS.GRID_LARGE;

    }

    if(rawStr === 'none' || rawStr === 'brak' || sizeNum === 0){ return TEMPLATE_KINDS.NONE; }

    return TEMPLATE_KINDS.NONE;

  }

  function templateKindToStep(kind){

    switch(kind){

      case TEMPLATE_KINDS.GRID_SMALL: return 16;

      case TEMPLATE_KINDS.GRID_MEDIUM: return 24;

      case TEMPLATE_KINDS.GRID_LARGE: return 32;

      default: return 0;

    }

  }

  function gridStateToTemplateKind(state){

    const isObj = state && typeof state === 'object';

    const rawKind = isObj ? (state.kind || state.templateKind || state.type) : state;

    const sizeHint = isObj ? (state.gridSize ?? state.size) : state;

    if(rawKind === 'tech' || rawKind === 'grid-tech'){ return TEMPLATE_KINDS.GRID_TECH; }

    if(sizeHint === 'none' || sizeHint === 0){ return TEMPLATE_KINDS.NONE; }

    if(sizeHint === 'sm'){ return TEMPLATE_KINDS.GRID_SMALL; }
    if(sizeHint === 'md'){ return TEMPLATE_KINDS.GRID_MEDIUM; }
    if(sizeHint === 'lg'){ return TEMPLATE_KINDS.GRID_LARGE; }

    return TEMPLATE_KINDS.GRID_MEDIUM;

  }

  function templateElementKind(el){

    if(!el) return TEMPLATE_KINDS.NONE;

    const data = el.data || {};

    const rawKind = data.templateKind ?? el.templateKind ?? data.kind ?? el.kind;

    const sizeHint = data.gridSize ?? data.size ?? el.gridSize ?? el.size;

    return normalizeTemplateKind(rawKind, sizeHint);

  }



  /* ---------- TEKST: ROZMIAR CZCIONKI ---------- */

  function clampTextFont(px){

    return Math.max(TEXT_FONT_MIN, Math.min(TEXT_FONT_MAX, px));

  }

  function updateTextFontUI(){

    if(!textFontPanel) return;

    const options = textFontPanel.querySelectorAll('.font-option');

    options.forEach(opt=>{

      opt.classList.toggle('active', String(opt.dataset.size) === String(Math.round(textFontSizePx)));

    });

  }

  function ensureTextFontPanel(){

    if(textFontPanel) return;

    textFontPanel = document.createElement('div');

    textFontPanel.id = 'fontSizeMenu';

    textFontPanel.className = 'font-size-menu';

    textFontPanel.innerHTML = `

      <div class="font-option" data-size="16">

          <span class="font-preview" style="font-size:16px">Aa</span>

      </div>

      <div class="font-option" data-size="22">

          <span class="font-preview" style="font-size:22px">Aa</span>

      </div>

      <div class="font-option" data-size="28">

          <span class="font-preview" style="font-size:28px">Aa</span>

      </div>

      <div class="font-option" data-size="36">

          <span class="font-preview" style="font-size:36px">Aa</span>

      </div>

    `;

    document.body.appendChild(textFontPanel);

    textFontPanel.querySelectorAll('.font-option').forEach(opt=>{

      opt.addEventListener('pointerdown', (e)=>{

        e.preventDefault();

        const val = parseInt(opt.dataset.size,10);

        if(Number.isNaN(val)) return;

        setTextFontPx(val);

      });

    });

    updateTextFontUI();

  }

  function positionTextFontPanel(){

    if(!textFontBtn || !textFontPanel) return;

    const r = textFontBtn.getBoundingClientRect();

    textFontPanel.style.left = `${r.left}px`;

    textFontPanel.style.top = `${r.bottom + 8}px`;

  }

  function toggleTextFontPanel(force){

    if(!textFontBtn) return;

    ensureTextFontPanel();

    const open = typeof force==='boolean' ? force : !textFontPanel.classList.contains('open');

    if(open && tool===TOOLS.TEXT){

      positionTextFontPanel();

      updateTextFontUI();

      textFontPanel.classList.add('open');

    }else if(textFontPanel){

      textFontPanel.classList.remove('open');

      if(textFontBtn){ textFontBtn.classList.remove('is-active'); }

    }

  }

  function setTextFontPx(px){

    textFontSizePx = clampTextFont(px);

    if(tool===TOOLS.TEXT){

      size = Math.max(1, textFontSizePx / 6);

    }

    updateTextFontUI();

    updateState();

  }

  function handleTextToolToggle(previousTool){

    const isText = tool===TOOLS.TEXT;

    if(textFontBtn){

      textFontBtn.classList.toggle('is-visible', isText);

      if(!isText){

        textFontBtn.classList.remove('is-active');

      }

    }

    if(isText){

      if(previousTool!==TOOLS.TEXT){

        lastBrushSize = size;

        size = Math.max(1, textFontSizePx / 6);

      }

      updateTextFontUI();

    }else if(previousTool===TOOLS.TEXT){

      textFontSizePx = clampTextFont(textFontSizePx);

      size = lastBrushSize;

      toggleTextFontPanel(false);

    }

  }

  function updateDeleteButtonState(pageOverride){

    if(!deleteSelectionBtn) return;

    const target = pageOverride || currentPage();

    const hasSelection = Boolean(target && target.state.selection);

    deleteSelectionBtn.disabled = !hasSelection;

    deleteSelectionBtn.classList.toggle('is-disabled', !hasSelection);

  }

  function deleteCurrentSelection(){

    const p = currentPage();

    if(!p || !p.state.selection) return;

    const sel = p.state.selection;

    pushHistory(p);

    if(sel.kind==='image' && p.state.images[sel.index]){

      const removedImage = p.state.images.splice(sel.index,1)[0];

      const elementId = removedImage && removedImage.__elementId;

      if(elementId){

        AliboardModel.removeElement(elementId);

        if (window.AliboardRealtime &&

            typeof window.AliboardRealtime.broadcastElementRemove === 'function') {

          window.AliboardRealtime.broadcastElementRemove(elementId);

        }

      }

    } else if(sel.kind==='stroke' && p.state.strokes[sel.index]){

      const removedStroke = p.state.strokes.splice(sel.index,1)[0];

      if(removedStroke?.id){

        AliboardModel.removeElement(removedStroke.id);

        if (window.AliboardRealtime &&

            typeof window.AliboardRealtime.broadcastElementRemove === 'function') {

          window.AliboardRealtime.broadcastElementRemove(removedStroke.id);

        }

      }

    }

    p.state.selection = null;

    renderAll(p);

    clearOverlay(p);

    updateDeleteButtonState();

  }



  function resetBoardForSnapshot(){

    while(PAGES.length){ PAGES.pop(); }

    pagesEl.innerHTML = '';

    createPage(false);

    setTool(TOOLS.SELECT);

    updateDeleteButtonState();

  }

  window.aliboardResetBoardForSnapshot = resetBoardForSnapshot;



  function ensurePageForPatch(index){

    if(typeof index!=='number' || index<0){

      return currentPage();

    }

    while(PAGES.length <= index){

      createPage(false);

    }

    return PAGES[index];

  }



  function getPageRef(pageIndex){

    if(typeof pageIndex==='number' && pageIndex>=0){

      return PAGES[pageIndex];

    }

    return currentPage();

  }



  function getPageDimensions(page){

    const rect = page?.el?.getBoundingClientRect();

    let width = rect?.width;

    let height = rect?.height;

    if(!Number.isFinite(width) || width<=0){ width = page?.el?.offsetWidth || page?.drawC?.clientWidth || 1; }

    if(!Number.isFinite(height) || height<=0){ height = page?.el?.offsetHeight || page?.drawC?.clientHeight || 1; }

    return { width, height };

  }



  function toRelativePoint(pt, dims){

    if(!pt || !dims) return null;

    const x = Number(pt.x ?? pt[0]);

    const y = Number(pt.y ?? pt[1]);

    if(!Number.isFinite(x) || !Number.isFinite(y)) return null;

    return {

      x: dims.width ? x / dims.width : 0,

      y: dims.height ? y / dims.height : 0

    };

  }



  function fromRelativePoint(pt, dims){

    if(!pt || !dims) return null;

    const x = Number(pt.x ?? pt[0]);

    const y = Number(pt.y ?? pt[1]);

    if(!Number.isFinite(x) || !Number.isFinite(y)) return null;

    return {

      x: x * dims.width,

      y: y * dims.height

    };

  }



  function newElementId(){

    if(window.crypto?.randomUUID){ return window.crypto.randomUUID(); }

    return 'el_' + Date.now().toString(36) + Math.random().toString(36).slice(2,10);

  }



  function serializeStrokeElement(stroke, pageIndex){

    if(!stroke) return null;

    const page = getPageRef(pageIndex);

    if(!page) return null;

    const dims = getPageDimensions(page);

    const tool = stroke.type || stroke.tool || 'pen';

    const kind = tool === 'poly' ? 'line' : tool;

    const data = {

      color: stroke.color || '#0b74ff',

      size: stroke.size || stroke.width || 3

    };

    if(tool==='pen'){

      const pts = (stroke.points || []).map(pt=>toRelativePoint(pt, dims)).filter(Boolean);

      if(pts.length<2) return null;

      data.points = pts;

    }else if(tool==='line'){

      if(!stroke.a || !stroke.b) return null;

      const relA = toRelativePoint(stroke.a, dims);

      const relB = toRelativePoint(stroke.b, dims);

      if(!relA || !relB) return null;

      data.a = relA;

      data.b = relB;

    }else if(tool==='poly'){

      const pts = (stroke.points || []).map(pt=>toRelativePoint(pt, dims)).filter(Boolean);

      if(pts.length<2) return null;

      data.points = pts;

      if(stroke.closed) data.closed = true;

    }else if(tool==='text'){

      const rel = toRelativePoint({x: stroke.x, y: stroke.y}, dims);

      if(!rel) return null;

      data.text = stroke.text || '';

      data.x = rel.x;

      data.y = rel.y;

    }else{

      return null;

    }

    const element = {

      id: stroke.id || newElementId(),

      kind,

      type: kind,

      page: pageIndex,

      pageIndex,

      data

    };

    stroke.id = element.id;

    return element;

  }



  function serializeImageElement(image, pageIndex){

    if(!image) return null;

    const page = getPageRef(pageIndex);

    if(!page) return null;

    const dims = getPageDimensions(page);

    const kind = image.meta?.pdf ? 'pdf' : 'image';

    const element = {

      id: image.id || newElementId(),

      kind,

      type: kind,

      page: pageIndex,

      pageIndex,

      data: {

        x: dims.width ? (image.x || 0) / dims.width : 0,

        y: dims.height ? (image.y || 0) / dims.height : 0,

        w: dims.width ? (image.w || 0) / dims.width : 0,

        h: dims.height ? (image.h || 0) / dims.height : 0,

        src: image.src,

        meta: image.meta || null

      }

    };

    image.id = element.id;

    return element;

  }



  function elementToLocalText(element, page){

    if(!element || !page) return null;

    const dims = getPageDimensions(page);

    const data = element.data || {};

    const rel = { x: data.x ?? element.x, y: data.y ?? element.y };

    const pt = fromRelativePoint(rel, dims);

    if(!pt) return null;

    return {

      id: element.id,

      kind: 'text',

      type: 'text',

      x: pt.x,

      y: pt.y,

      text: data.text ?? element.text ?? '',

      color: data.color ?? element.color ?? '#0b1320',

      size: data.size ?? element.size ?? 3,

      isEditing: data.isEditing ?? element.isEditing ?? false

    };

  }



  function elementToLocalStroke(element, page){

    if(!element || !page) return null;

    const dims = getPageDimensions(page);

    const data = element.data || {};

    const base = {

      id: element.id,

      color: data.color || '#0b74ff',

      size: data.size || 3

    };

    if(element.kind === 'pen'){

      const pts = (data.points || []).map(pt=>fromRelativePoint(pt, dims)).filter(Boolean);

      if(pts.length < 2) return null;

      return { ...base, type: 'pen', points: pts };

    }

    if(element.kind === 'line'){

      if(data.a && data.b){

        const a = fromRelativePoint(data.a, dims);

        const b = fromRelativePoint(data.b, dims);

        if(!a || !b) return null;

        return { ...base, type: 'line', a, b };

      }

      const pts = (data.points || []).map(pt=>fromRelativePoint(pt, dims)).filter(Boolean);

      if(pts.length >= 2){

        return { ...base, type: data.closed ? 'poly' : 'line', points: pts, closed: !!data.closed };

      }

    }

    if(element.kind === 'text'){

      const rel = fromRelativePoint({x: data.x, y: data.y}, dims);

      if(!rel) return null;

      return { ...base, type: 'text', x: rel.x, y: rel.y, text: data.text || '' };

    }

    return null;

  }



  function elementToLocalImage(element, page){

    if(!element || !page) return null;

    const dims = getPageDimensions(page);

    const data = element.data || {};

    const raw = {

      id: element.id,

      x: (data.x || 0) * (dims.width || 1),

      y: (data.y || 0) * (dims.height || 1),

      w: (data.w || 0) * (dims.width || 1),

      h: (data.h || 0) * (dims.height || 1),

      src: data.src,

      meta: data.meta || (element.kind === 'pdf' ? { pdf: true } : null)

    };

    const revived = reviveImage(raw, page);

    if(revived){

      revived.__elementId = element.id;

    }

    return revived;

  }



  function syncPageStateFromModel(page){

    const pageIndex = PAGES.indexOf(page);

    if(pageIndex < 0) return;

    const existingImages = new Map((page.state.images || []).map(im=>[im.__elementId, im]));

    const elements = AliboardModel.getAllElements().filter(el => el.page === pageIndex);

    const nextStrokes = [];

    const nextImages = [];

    let nextTemplateKind = TEMPLATE_KINDS.NONE;

    elements.forEach(el=>{

      if(el.kind === 'template'){

        nextTemplateKind = templateElementKind(el);

        return;

      }

      if(el.kind === 'image' || el.kind === 'pdf'){

        const cached = existingImages.get(el.id);

        const fresh = elementToLocalImage(el, page);

        if(cached && fresh){

          const srcChanged = cached.src !== fresh.src;

          cached.x = fresh.x; cached.y = fresh.y; cached.w = fresh.w; cached.h = fresh.h;

          cached.meta = fresh.meta;

          if(srcChanged){

            cached.src = fresh.src;

            cached.img = fresh.img; // jeżeli źródło się zmieniło, przypnij nowy obraz

          }

          nextImages.push(cached);

        }else if(fresh){

          nextImages.push(fresh);

        }

      }else{

        const st = elementToLocalStroke(el, page);

        if(st){ nextStrokes.push(st); }

      }

    });

    page.state.strokes = nextStrokes;

    page.state.images = nextImages;

    setPageTemplateKind(page, nextTemplateKind);

  }



  function syncAllPagesFromModel(){

    PAGES.forEach(p=>{

      syncPageStateFromModel(p);

      renderAll(p);

      if(p.state.selection){ drawSelection(p); }

    });

  }



  function syncPageStateToModel(p){

    const pageIndex = PAGES.indexOf(p);

    if(pageIndex < 0) return;

    const kept = new Set();

    (p.state.strokes || []).forEach(st=>{

      const el = serializeStrokeElement(st, pageIndex);

      if(el){

        kept.add(el.id);

        AliboardModel.upsertElement(el);

      }

    });

    (p.state.images || []).forEach(im=>{

      const el = serializeImageElement(im, pageIndex);

      if(el){

        kept.add(el.id);

        im.__elementId = el.id;

        AliboardModel.upsertElement(el);

      }

    });

    AliboardModel.getAllElements().forEach(el=>{

      if(el.page === pageIndex && el.kind !== 'template' && !kept.has(el.id)){

        AliboardModel.removeElement(el.id);

      }

    });

  }



  function applyElementAddPayload(element){

    if(!element || !element.id) return;

    AliboardModel.upsertElement(element);

  }



  function applySnapshotElements(elements){

    resetBoardForSnapshot();

    AliboardModel.applySnapshot(Array.isArray(elements) ? elements : []);

  }



  function boardHasElements(){

    return AliboardModel.getAllElements().length > 0;

  }



  function removeElementById(id){

    if(!id) return;

    AliboardModel.removeElement(id);

  }



  function emitElementAddFromStroke(stroke, pageIndex){

    const payload = serializeStrokeElement(stroke, pageIndex);

    if(!payload) return;

    AliboardModel.upsertElement(payload);

    const realtime = window.AliboardRealtime;

    if(realtime && typeof realtime.broadcastElementAdd==='function'){

      realtime.broadcastElementAdd(payload);

    }

  }



  function emitElementRemove(id){

    if(!id) return;

    const realtime = window.AliboardRealtime;

    AliboardModel.removeElement(id);

    if(realtime && typeof realtime.broadcastElementRemove==='function'){

      realtime.broadcastElementRemove(id);

    }

  }



  function emitImageElementAdd(image, pageIndex){

    if(!image) return;

    const payload = serializeImageElement(image, pageIndex);

    if(!payload) return;

    image.id = payload.id;

    AliboardModel.upsertElement(payload);

    const realtime = window.AliboardRealtime;

    if(realtime && typeof realtime.broadcastElementAdd==='function'){

      realtime.broadcastElementAdd(payload);

    }

  }



  function syncBoardStateToServer(){

    const realtime = window.AliboardRealtime;

    if(!realtime) return;

    AliboardModel.getAllElements().forEach(el=>{

      if(typeof realtime.broadcastElementUpdate === 'function'){

        realtime.broadcastElementUpdate(el);

      }else if(typeof realtime.broadcastElementAdd === 'function'){

        realtime.broadcastElementAdd(el);

      }

    });

  }



  function initRealtimeBridge(){

    const realtime = window.AliboardRealtime;

    if(!realtime || typeof realtime.on!=='function'){

      setTimeout(initRealtimeBridge, 600);

      return;

    }

    realtime.on('snapshot', (elements)=>{

      applySnapshotElements(elements);

    });

    realtime.on('open', ()=>{

      if(boardHasElements()){

        syncBoardStateToServer();

      }

    });

    realtime.on('element_add', applyElementAddPayload);

    realtime.on('element_update', applyElementAddPayload);

    realtime.on('element_remove', (payload)=>{

      const id = typeof payload === 'string' ? payload : payload?.id;

      removeElementById(id);

    });

  }



  initRealtimeBridge();



  // ---- USTALENIE roomId (wsp?lne z realtime) ----

  let roomId = null;



  // 1) je?li ju? kto? ustawi? globalnie (np. inny skrypt / Django):

  if (window.ALIBOARD_ROOM_ID) {

    roomId = window.ALIBOARD_ROOM_ID;

  }



  // 2) je?li nie ma ? spr?buj odczyta? z data-room-id na kontenerze tablicy

  if (!roomId) {

    const rootEl =

      document.getElementById('aliboard-root') ||

      document.querySelector('[data-room-id]');

    if (rootEl && rootEl.dataset.roomId) {

      roomId = rootEl.dataset.roomId;

    }

  }



  // 3) jeśli nadal brak — spróbuj z query stringa (?room= / ?room_id=)

  if (!roomId) {

    const qs = new URLSearchParams(location.search);

    roomId = qs.get('room') || qs.get('room_id') || 'local-test';

  }



  // 4) zapisz globalnie (dla aliboard_realtime.js i innych)

  window.ALIBOARD_ROOM_ID = roomId;



  // info w stopce

  const roomInfoEl = document.getElementById('roomInfo');

  if (roomInfoEl) roomInfoEl.textContent = 'room_id: ' + roomId;



  console.log('[Aliboard] roomId =', roomId);



  /* ---------- MODEL STANU (CRDT) ---------- */

  const AliboardModel = (function(){

    const elements = new Map();

    const subs = new Set();



    function buildDataFromLegacy(raw){

      if((raw.kind === 'template' || raw.type === 'template') && (raw.templateKind || raw.gridSize || raw.size)){

        return { templateKind: normalizeTemplateKind(raw.templateKind || raw.kind || raw.type, raw.gridSize ?? raw.size) };

      }

      if(raw.points){

        return { points: raw.points, color: raw.color, size: raw.size, closed: raw.closed };

      }

      if(raw.a && raw.b){

        return { a: raw.a, b: raw.b, color: raw.color, size: raw.size };

      }

      if(raw.text !== undefined){

        return { x: raw.x, y: raw.y, text: raw.text, color: raw.color, size: raw.size, isEditing: raw.isEditing };

      }

      if(raw.src){

        return { x: raw.x, y: raw.y, w: raw.w, h: raw.h, src: raw.src, meta: raw.meta };

      }

      return {};

    }



    function normalize(raw){

      if(!raw || !raw.id) return null;

      const kind = raw.kind || raw.tool || raw.type || 'pen';

      const page = Number.isFinite(raw.page) ? Number(raw.page) : (

        Number.isFinite(raw.pageIndex) ? Number(raw.pageIndex) : 0

      );

      let data = raw.data ? { ...raw.data } : buildDataFromLegacy(raw);

      if(kind === 'template'){

        const templateKind = normalizeTemplateKind(

          raw.templateKind ?? data.templateKind ?? data.kind ?? raw.kind,

          data.gridSize ?? data.size ?? raw.gridSize ?? raw.size

        );

        data = { templateKind };

      }else if(kind === 'text'){

        data = {

          x: data.x ?? raw.x,

          y: data.y ?? raw.y,

          text: data.text ?? raw.text ?? '',

          color: data.color ?? raw.color,

          size: data.size ?? raw.size,

          isEditing: data.isEditing ?? raw.isEditing

        };

      }

      const normalized = { id: raw.id, kind, page, pageIndex: page, data };

      if(kind === 'text'){

        normalized.x = data.x;

        normalized.y = data.y;

        normalized.text = data.text;

        normalized.color = data.color;

        normalized.size = data.size;

        normalized.isEditing = data.isEditing;

      }

      return normalized;

    }



    function notify(){

      const snapshot = getAllElements();

      subs.forEach(fn=>{

        try{

          fn(snapshot);

        }catch(err){

          console.error('[AliboardModel] subscriber error', err);

        }

      });

    }



    function applySnapshot(list){

      elements.clear();

      (list || []).forEach(el=>{

        const normalized = normalize(el);

        if(normalized){

          elements.set(normalized.id, normalized);

        }

      });

      notify();

    }



    function upsertElement(el){

      const normalized = normalize(el);

      if(!normalized) return;

      elements.set(normalized.id, normalized);

      notify();

    }



    function removeElement(id){

      if(!id) return;

      elements.delete(id);

      notify();

    }



    function getElementsForPage(pageIndex){

      if(!Number.isFinite(pageIndex)) return [];

      return getAllElements().filter(el=> (el.page ?? el.pageIndex) === pageIndex || el.pageIndex === pageIndex);

    }



    function getAllElements(){

      return Array.from(elements.values());

    }



    function getElement(id){

      return elements.get(id) || null;

    }



    function clear(){

      elements.clear();

      notify();

    }



    function subscribe(fn){

      if(typeof fn !== 'function') return ()=>{};

      subs.add(fn);

      try{

        fn(getAllElements());

      }catch(err){

        console.error('[AliboardModel] initial subscriber error', err);

      }

      return ()=> subs.delete(fn);

    }



    return {

      applySnapshot,

      upsertElement,

      upsert: upsertElement,

      removeElement,

      getAllElements,

      getElementsForPage,

      getElement,

      get: getElement,

      clear,

      subscribe

    };

  })();



  /* ---------- MODEL STRONY ---------- */

  function makeEmptyPageState(){

    return { strokes: [], images: [], history: [], redo: [], selection: null, dragging: null, templateKind: TEMPLATE_KINDS.NONE, templateGridSize: null, templateStepPx: null };

  }

  // ZDALNE KURSORY: klientId -> { el, dot, label, pageIndex }

  const REMOTE_CURSORS = new Map();

  const PAGES = [];



  // automatyczne odrysowanie po każdej zmianie modelu (po zainicjalizowaniu PAGES)

  AliboardModel.subscribe(()=> syncAllPagesFromModel());



  function ensurePage(index){

    while (PAGES.length <= index){

      createPage(false);

    }

    return PAGES[index];

  }

  function currentPage(){

    if(!PAGES.length) return null;

    if(wrapEl){

      const center = wrapEl.scrollTop + wrapEl.clientHeight/2;

      let best = null, bestDist = Infinity;

      PAGES.forEach(p=>{

        const mid = p.el.offsetTop + p.el.offsetHeight/2;

        const dist = Math.abs(mid - center);

        if(dist < bestDist){

          bestDist = dist;

          best = p;

        }

      });

      if(best) return best;

    }

    return PAGES[PAGES.length-1] || null;

  }



  /* ---------- TWORZENIE STRONY ---------- */

  function createPage(scrollTo=true){

    const page = document.createElement('div');

    page.className = 'page';



    const gridC = document.createElement('canvas'); gridC.className='grid';

    const drawC = document.createElement('canvas'); drawC.className='board';

    const ovlC  = document.createElement('canvas'); ovlC.className='overlay';



    page.appendChild(gridC); page.appendChild(drawC); page.appendChild(ovlC);

    pagesEl.appendChild(page);



    const g   = gridC.getContext('2d');

    const ctx = drawC.getContext('2d');

    const ovl = ovlC.getContext('2d');



    const p = { el:page, gridC, drawC, ovlC, g, ctx, ovl, state: makeEmptyPageState() };

    PAGES.push(p);

    p.index = PAGES.length - 1;

    resizePage(p);

    setPageTemplateKind(p, p.state.templateKind, true);

    renderAll(p);

    bindPage(p);

    if(scrollTo) page.scrollIntoView({behavior:'smooth', block:'center'});

    return p;

  }



  /* ---------- ROZMIAR I SZABLON ---------- */

  function resizePage(p){

    const rect = p.el.getBoundingClientRect();

    const dpr  = window.devicePixelRatio || 1;

    [p.gridC, p.drawC, p.ovlC].forEach(c=>{

      c.width  = Math.floor(rect.width * dpr);

      c.height = Math.floor(rect.height * dpr);

      c.style.width  = rect.width + 'px';

      c.style.height = rect.height + 'px';

      const c2d = c.getContext('2d');

      c2d.setTransform(dpr,0,0,dpr,0,0);

    });

    renderTemplateLayer(p);

  }

  function drawSimpleGrid(ctx, w, h, step){

    if(!step) return;

    ctx.save(); ctx.strokeStyle='#e6edff'; ctx.lineWidth=1;

    for(let x=0;x<=w;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }

    for(let y=0;y<=h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    ctx.restore();

  }

  function drawLinedPattern(ctx, w, h){

    const step = 28;

    ctx.save(); ctx.strokeStyle='#e6edff'; ctx.lineWidth=1;

    for(let y=0;y<=h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    ctx.restore();

  }

  function drawTemplateOnContext(ctx, w, h, templateKind, stepOverride){

    const kind = normalizeTemplateKind(templateKind);

    ctx.clearRect(0,0,w,h);

    if(kind === TEMPLATE_KINDS.NONE) return;

    if(kind === TEMPLATE_KINDS.GRID_TECH){ drawTechPattern(ctx, w, h, stepOverride); return; }

    if(kind === TEMPLATE_KINDS.LINED){ drawLinedPattern(ctx, w, h); return; }

    const step = stepOverride || templateKindToStep(kind);

    if(step){ drawSimpleGrid(ctx, w, h, step); }

  }

  function renderTemplateLayer(p){

    if(!p || !p.gridC) return;

    const dpr = window.devicePixelRatio || 1;

    const w = p.gridC.width / dpr, h = p.gridC.height / dpr;

    const currentWidth = (p?.el?.getBoundingClientRect()?.width) || (p?.gridC?.clientWidth) || p.gridC.width;
    let stepOverride = p.state.templateStepPx;
    if(p.state.templateGridSize){
      stepOverride = computeStepPx(p.state.templateGridSize, currentWidth);
    }

    drawTemplateOnContext(p.g, w, h, p.state.templateKind, stepOverride);

  }

  function setPageTemplateKind(p, templateKind, forceDraw, meta){

    if(!p || !p.state) return;

    const next = normalizeTemplateKind(templateKind);

    if(meta){
      p.state.templateGridSize = meta.gridSize ?? null;
      p.state.templateStepPx = meta.stepPx ?? null;
    }else{
      p.state.templateGridSize = null;
      p.state.templateStepPx = null;
    }

    if(!forceDraw && p.state.templateKind === next) return;

    p.state.templateKind = next;

    renderTemplateLayer(p);

  }

  function buildTemplateElement(pageIndex, templateKind){

    return {

      id: `template:${pageIndex}`,

      kind: 'template',

      type: 'template',

      page: pageIndex,

      pageIndex,

      data: { templateKind: normalizeTemplateKind(templateKind) }

    };

  }

  function broadcastTemplateElement(element, opts){

    const realtime = window.AliboardRealtime;

    if(!element || !realtime) return;

    if(opts && opts.broadcast === false) return;

    if(typeof realtime.broadcastElementUpdate === 'function'){

      realtime.broadcastElementUpdate(element);

    }else if(typeof realtime.broadcastElementAdd === 'function'){

      realtime.broadcastElementAdd(element);

    }

  }

  function setTemplateForPage(pageIndex, templateKind, opts){

    const p = ensurePage(pageIndex);

    const normalized = normalizeTemplateKind(templateKind);

    const meta = opts ? { gridSize: opts.gridSize, stepPx: opts.stepPx } : undefined;

    setPageTemplateKind(p, normalized, true, meta);

    const element = buildTemplateElement(pageIndex, normalized);

    AliboardModel.upsertElement(element);

    broadcastTemplateElement(element, opts);

  }

  // --- LEGACY GRID EVENT: mapuj na element template ---

  window.aliboardApplyGridState = function(newGridState){

    const isObj = newGridState && typeof newGridState === 'object';
    const rawKind = isObj ? (newGridState.kind || newGridState.templateKind || newGridState.type) : null;
    const rawSize = isObj ? (newGridState.gridSize ?? newGridState.size) : newGridState;
    const sizeKey = typeof rawSize === 'string' ? rawSize : (rawSize === 0 ? 'none' : 'md');
    if(rawKind === 'none' || sizeKey === 'none'){
      setTemplateForPage(0, TEMPLATE_KINDS.NONE, { broadcast:false, gridSize: 'none', stepPx: 0 });
      PAGES.forEach((page, idx)=> setTemplateForPage(idx, TEMPLATE_KINDS.NONE, { broadcast:false, gridSize: 'none', stepPx: 0 }));
      return;
    }

    PAGES.forEach((page, idx)=>{
      const currentWidth = (page?.el?.getBoundingClientRect()?.width) || (page?.gridC?.clientWidth) || (page?.gridC?.width) || 0;
      const effectiveStep = computeStepPx(sizeKey, currentWidth);
      const templateKind = gridStateToTemplateKind({ kind: rawKind, gridSize: sizeKey });

      setTemplateForPage(idx, templateKind, {
        broadcast:false,
        gridSize: sizeKey,
        stepPx: effectiveStep,
      });
    });

  };

  function drawTechPattern(ctx, w, h, customStep){

    ctx.clearRect(0,0,w,h);

    ctx.save();

    const thin = '#e0e6f0';

    const mid  = '#b5c0d4';

    const bold = '#7f8ba1';

    const step = customStep || 8;

    ctx.strokeStyle = thin;

    ctx.lineWidth = 0.5;

    for (let x = 0; x <= w; x += step/2){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }

    for (let y = 0; y <= h; y += step/2){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

    ctx.strokeStyle = mid;

    ctx.lineWidth = 1;

    for (let x = 0; x <= w; x += step*5){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }

    for (let y = 0; y <= h; y += step*5){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

    ctx.strokeStyle = bold;

    ctx.lineWidth = 1.2;

    for (let x = 0; x <= w; x += step*10){ ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }

    for (let y = 0; y <= h; y += step*10){ ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

    ctx.restore();

  }

  function resetBoard(){

    PAGES.forEach(p=> p.el.remove());

    PAGES.length = 0;

    pagesEl.innerHTML = '';

  }

  window.addEventListener('resize', ()=>{

    PAGES.forEach(p=>{ resizePage(p); renderAll(p); drawSelection(p); });

    if(textFontPanel?.classList.contains('open')){ positionTextFontPanel(); }

  });



  /* ---------- RENDER ---------- */

  function renderAll(p){

    const dpr = window.devicePixelRatio || 1;

    const w = p.drawC.width / dpr, h = p.drawC.height / dpr;

    const ctx = p.ctx;

    ctx.clearRect(0,0,w,h);



    const pageIndex = Number.isFinite(p.index) ? p.index : PAGES.indexOf(p);

    const elements = typeof AliboardModel.getElementsForPage === 'function'

      ? AliboardModel.getElementsForPage(pageIndex)

      : AliboardModel.getAllElements().filter(el => (el.page ?? el.pageIndex) === pageIndex);



    const strokes = [];

    const images = [];

    const texts = [];



    elements.forEach(el=>{

      if(el.kind === 'template'){

        return;

      }

      if(el.kind === 'image' || el.kind === 'pdf'){

        const cached = p.state.images.find(im=>im.__elementId === el.id);

        const image = cached || elementToLocalImage(el, p);

        if(image){ images.push(image); }

      }else if(el.kind === 'text'){

        const textEl = elementToLocalText(el, p);

        if(textEl){ texts.push(textEl); }

      }else{

        const cached = p.state.strokes.find(st=>st.id === el.id);

        const stroke = cached || elementToLocalStroke(el, p);

        if(stroke){ strokes.push(stroke); }

      }

    });



    for(const im of images){ if(im?.img) ctx.drawImage(im.img, im.x, im.y, im.w, im.h); }



    ctx.lineCap='round'; ctx.lineJoin='round';

    for(const s of strokes){

      if(!s) continue;

      if(s.type==='pen'){

        ctx.strokeStyle=s.color; ctx.lineWidth=s.size;

        const pts=s.points; if(!pts.length) continue;

        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);

        for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y); }

        ctx.stroke();

      }else if(s.type==='line'){

        ctx.strokeStyle=s.color; ctx.lineWidth=s.size;

        ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();

      }else if(s.type==='poly'){

        ctx.save();

        ctx.strokeStyle = s.color;

        ctx.lineWidth   = s.size;

        ctx.lineCap = 'round';

        ctx.lineJoin = 'round';

        if(s.points && s.points.length){

          ctx.beginPath();

          ctx.moveTo(s.points[0].x, s.points[0].y);

          for(let i=1;i<s.points.length;i++){

            ctx.lineTo(s.points[i].x, s.points[i].y);

          }

          if(s.closed){ ctx.closePath(); }

          ctx.stroke();

        }

        ctx.restore();

      }

    }



    for(const t of texts){

      ctx.save();

      const pxSize = Math.max(14, (t.size || 3) * 6);

      ctx.fillStyle = t.color || '#0b1320';

      ctx.font = `${pxSize}px ui-sans-serif, system-ui, Arial`;

      ctx.textBaseline = 'top';

      ctx.fillText(t.text || '', t.x, t.y);

      ctx.restore();

    }

  }



  /* ---------- OBRAZY ---------- */

  // --- OBRAZY: lokalny model + opcjonalny CRDT (element_add) ---

  function reviveImage(im, p){

    const obj = {

      id: im.id || null,

      x: im.x,

      y: im.y,

      w: im.w,

      h: im.h,

      src: im.src,

      meta: im.meta,

      img: null,

    };

    const el = new Image();

    el.onload = ()=>{ obj.img = el; renderAll(p); };

    el.src = im.src;

    return obj;

  }



    // addImageFromSrc = JEDYNE miejsce, ktore dodaje obraz do strony



  function addImageFromSrc(src, w, h, x, y, meta, p, opts){

    opts = opts || {};



    // lokalna historia (undo)

    pushHistory(p);



    const pageIndex = PAGES.indexOf(p);

    const im = reviveImage({ id: opts.id, src, w, h, x, y, meta }, p);

    p.state.images.push(im);



    const element = serializeImageElement(im, pageIndex);

    if(element){

      im.__elementId = element.id;

      AliboardModel.upsertElement(element);

      if (!opts.silent &&

          window.AliboardRealtime &&

          typeof window.AliboardRealtime.broadcastElementAdd === "function") {

        window.AliboardRealtime.broadcastElementAdd(element);

      }

    }



    renderAll(p);

  }

  /* ---------- HISTORIA ---------- */

  function snapshotState(p){

    return JSON.stringify({

      strokes: p.state.strokes,

      images: p.state.images.map(im=>({id: im.id, x:im.x,y:im.y,w:im.w,h:im.h,src:im.src,meta:im.meta}))

    });

  }

  function ensureStrokeIds(p){

    (p.state.strokes || []).forEach(st=>{ if(!st.id) st.id = newElementId(); });

  }

  function pushHistory(p){ p.state.redo=[]; try{ p.state.history.push(snapshotState(p)); if(p.state.history.length>100) p.state.history.shift(); }catch(_){} }

  function restoreHistoryState(p, json){

    try{

      const s = JSON.parse(json);

      p.state.strokes = s.strokes||[];

      ensureStrokeIds(p);

      p.state.images  = (s.images||[]).map(im=>reviveImage(im, p));

      syncPageStateToModel(p);

      renderAll(p); drawSelection(p);

    }catch(_){}

  }



  /* ---------- SELEKCJA I TRANSFORMACJE ---------- */

  const HANDLE_SIZE=10;

  function clearOverlay(p){ p.ovl.clearRect(0,0, p.ovlC.width, p.ovlC.height); }

  function drawPolyPreview(p, pts){

    clearOverlay(p);

    if(p.state.selection) drawSelection(p);

    if(!pts || pts.length<2) return;

    p.ovl.save();

    p.ovl.strokeStyle = color;

    p.ovl.lineWidth = Math.max(1, size);

    p.ovl.setLineDash([6,4]);

    p.ovl.beginPath();

    p.ovl.moveTo(pts[0].x, pts[0].y);

    for(let i=1;i<pts.length;i++){ p.ovl.lineTo(pts[i].x, pts[i].y); }

    p.ovl.closePath();

    p.ovl.stroke();

    p.ovl.restore();

  }

  function bboxStroke(s){

    if(s.type==='pen'){

      const xs=s.points.map(p=>p.x), ys=s.points.map(p=>p.y);

      const minx=Math.min(...xs), maxx=Math.max(...xs), miny=Math.min(...ys), maxy=Math.max(...ys);

      return {x:minx,y:miny,w:maxx-minx,h:maxy-miny};

    }else if(s.type==='line'){

      const minx=Math.min(s.a.x,s.b.x), maxx=Math.max(s.a.x,s.b.x);

      const miny=Math.min(s.a.y,s.b.y), maxy=Math.max(s.a.y,s.b.y);

      return {x:minx,y:miny,w:maxx-minx,h:maxy-miny};

    }else if(s.type==='text'){

      const w = (Math.max(14, s.size*6)*0.6)*(s.text?.length||0);

      const h = Math.max(14, s.size*6);

      return {x:s.x, y:s.y, w, h};

    }else if(s.type==='poly'){

      if(!s.points || !s.points.length) return {x:0,y:0,w:0,h:0};

      const xs = s.points.map(pt=>pt.x);

      const ys = s.points.map(pt=>pt.y);

      const minx = Math.min(...xs), maxx = Math.max(...xs);

      const miny = Math.min(...ys), maxy = Math.max(...ys);

      return {x:minx, y:miny, w:maxx-minx, h:maxy-miny};

    }

    return {x:0,y:0,w:0,h:0};

  }

  function drawSelection(p){

    clearOverlay(p);

    const sel = p.state.selection;

    updateDeleteButtonState(p);

    selectionRotateEnabled = false;

    if(!sel) return;

    const b = sel.bbox;

    const canRotate = sel.kind==='stroke' && p.state.strokes[sel.index]?.type==='poly';

    selectionRotateEnabled = canRotate;

    p.ovl.save();

    p.ovl.strokeStyle = '#0b74ff'; p.ovl.lineWidth = 1.5;

    p.ovl.setLineDash([6,4]); p.ovl.strokeRect(b.x, b.y, b.w, b.h); p.ovl.setLineDash([]);

    const hs = HANDLE_SIZE, pts = handlePoints(b);

    p.ovl.fillStyle='#fff'; p.ovl.strokeStyle='#0b74ff'; p.ovl.lineWidth=2;

    for(const h of pts){ p.ovl.beginPath(); p.ovl.rect(h.x-hs/2, h.y-hs/2, hs, hs); p.ovl.fill(); p.ovl.stroke(); }

    if(canRotate){

      const rotate={x:b.x+b.w/2,y:b.y-30};

      p.ovl.beginPath();

      p.ovl.moveTo(b.x+b.w/2,b.y);

      p.ovl.lineTo(rotate.x, rotate.y);

      p.ovl.stroke();

      p.ovl.beginPath();

      p.ovl.arc(rotate.x, rotate.y, hs/1.5, 0, Math.PI*2);

      p.ovl.fill();

      p.ovl.stroke();

    }

    p.ovl.restore();

  }

  function handlePoints(b){

    const cx=b.x+b.w/2, cy=b.y+b.h/2;

    return [

      {x:b.x, y:b.y}, {x:cx, y:b.y}, {x:b.x+b.w, y:b.y},

      {x:b.x, y:cy},                 {x:b.x+b.w, y:cy},

      {x:b.x, y:b.y+b.h}, {x:cx, y:b.y+b.h}, {x:b.x+b.w, y:b.y+b.h},

    ];

  }

  function hitHandle(pxy, b){

    const hs=HANDLE_SIZE, pts=handlePoints(b);

    for(let i=0;i<pts.length;i++){

      if(Math.abs(pxy.x-pts[i].x)<=hs && Math.abs(pxy.y-pts[i].y)<=hs) return i;

    }

    if(selectionRotateEnabled){

      const rotate = {x:b.x+b.w/2, y:b.y-30};

      if(Math.hypot(pxy.x-rotate.x, pxy.y-rotate.y)<=hs) return ROTATE_HANDLE;

    }

    return -1;

  }

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  function distToSegment(p, a, b){

    const ABx=b.x-a.x, ABy=b.y-a.y, APx=p.x-a.x, APy=p.y-a.y;

    const ab2=ABx*ABx+ABy*ABy; const t=ab2?Math.max(0,Math.min(1,(APx*ABx+APy*ABy)/ab2)):0;

    const proj={x:a.x+t*ABx,y:a.y+t*ABy}; return dist(p,proj);

  }

  function hitPolyline(pts, pxy, eps){ for(let i=1;i<pts.length;i++){ if(distToSegment(pxy, pts[i-1], pts[i])<=eps) return true;} return false; }

  function hitTest(pxy, p){

    const eps = Math.max(6, size*2);

    for(let i=p.state.strokes.length-1;i>=0;i--){

      const s=p.state.strokes[i];

      if(s.type==='pen'){ if(hitPolyline(s.points,pxy,eps)) return {kind:'stroke',index:i,bbox:bboxStroke(s)}; }

      else if(s.type==='line'){ if(distToSegment(pxy,s.a,s.b)<=eps) return {kind:'stroke',index:i,bbox:bboxStroke(s)}; }

      else if(s.type==='text'){

        const b=bboxStroke(s);

        if(pxy.x>=b.x&&pxy.x<=b.x+b.w&&pxy.y>=b.y&&pxy.y<=b.y+b.h) return {kind:'stroke',index:i,bbox:b,elementId:s.id};

      }else if(s.type==='poly'){

        if(s.points && hitPolyline(s.points, pxy, eps)){

          return {kind:'stroke', index:i, bbox:bboxStroke(s)};

        }

      }

    }

    for(let i=p.state.images.length-1;i>=0;i--){

      const im=p.state.images[i];

      if(pxy.x>=im.x && pxy.x<=im.x+im.w && pxy.y>=im.y && pxy.y<=im.y+im.h){

        return {kind:'image', index:i, bbox:{x:im.x,y:im.y,w:im.w,h:im.h}};

      }

    }

    return null;

  }



  const HANDLE_MIN_SIZE = 12;

  function cloneStrokeState(stroke){

    if(!stroke) return null;

    if(stroke.type==='pen'){

      return {

        type:stroke.type,

        color:stroke.color,

        size:stroke.size,

        points: stroke.points.map(pt=>({x:pt.x, y:pt.y}))

      };

    }

    if(stroke.type==='line'){

      return {

        type:stroke.type,

        color:stroke.color,

        size:stroke.size,

        a:{...stroke.a},

        b:{...stroke.b}

      };

    }

    if(stroke.type==='text'){

      return {...stroke};

    }

    if(stroke.type==='poly'){

      return {

        type:stroke.type,

        color:stroke.color,

        size:stroke.size,

        points: stroke.points ? stroke.points.map(pt=>({x:pt.x,y:pt.y})) : [],

        closed: stroke.closed

      };

    }

    return null;

  }

  function cloneImageState(im){

    if(!im) return null;

    return {x:im.x, y:im.y, w:im.w, h:im.h, meta:im.meta};

  }

  function computeScaledBBox(startBBox, handle, x, y){

    let left = startBBox.x;

    let right = startBBox.x + startBBox.w;

    let top = startBBox.y;

    let bottom = startBBox.y + startBBox.h;

    switch(handle){

      case 0: left = x; top = y; break;

      case 1: top = y; break;

      case 2: right = x; top = y; break;

      case 3: left = x; break;

      case 4: right = x; break;

      case 5: left = x; bottom = y; break;

      case 6: bottom = y; break;

      case 7: right = x; bottom = y; break;

    }

    const moveLeft   = (handle===0||handle===3||handle===5);

    const moveRight  = (handle===2||handle===4||handle===7);

    const moveTop    = (handle===0||handle===1||handle===2);

    const moveBottom = (handle===5||handle===6||handle===7);

    if(right - left < HANDLE_MIN_SIZE){

      if(moveLeft) left = right - HANDLE_MIN_SIZE;

      else if(moveRight) right = left + HANDLE_MIN_SIZE;

    }

    if(bottom - top < HANDLE_MIN_SIZE){

      if(moveTop) top = bottom - HANDLE_MIN_SIZE;

      else if(moveBottom) bottom = top + HANDLE_MIN_SIZE;

    }

    const width = Math.max(HANDLE_MIN_SIZE, right - left);

    const height = Math.max(HANDLE_MIN_SIZE, bottom - top);

    return { x:left, y:top, w:width, h:height };

  }

  function scalePointRelative(pt, startBBox, nextBBox){

    const rx = startBBox.w ? (pt.x - startBBox.x) / startBBox.w : 0;

    const ry = startBBox.h ? (pt.y - startBBox.y) / startBBox.h : 0;

    return {

      x: nextBBox.x + rx * nextBBox.w,

      y: nextBBox.y + ry * nextBBox.h

    };

  }

  function applyScaledSelection(sel, drag, nextBBox, p){

    if(sel.kind==='image'){

      const im = p.state.images[sel.index];

      if(!im) return;

      im.x = nextBBox.x;

      im.y = nextBBox.y;

      im.w = Math.max(1, nextBBox.w);

      im.h = Math.max(1, nextBBox.h);

      return;

    }

    const stroke = p.state.strokes[sel.index];

    const original = drag.original;

    if(!stroke || !original) return;

    if(stroke.type==='pen'){

      stroke.points = original.points.map(pt=>scalePointRelative(pt, drag.startBBox, nextBBox));

    }else if(stroke.type==='line'){

      stroke.a = scalePointRelative(original.a, drag.startBBox, nextBBox);

      stroke.b = scalePointRelative(original.b, drag.startBBox, nextBBox);

    }else if(stroke.type==='text'){

      const mapped = scalePointRelative({x:original.x, y:original.y}, drag.startBBox, nextBBox);

      stroke.x = mapped.x;

      stroke.y = mapped.y;

    }else if(stroke.type==='poly'){

      stroke.points = (original.points||[]).map(pt=>scalePointRelative(pt, drag.startBBox, nextBBox));

    }

    // nie skalujemy grubości linii ani czcionki przy zmianie rozmiaru

    if(stroke.type==='pen' || stroke.type==='line' || stroke.type==='text'){

      stroke.size = original.size;

    }

  }



  /* ---------- GUMKA POD?WIETLA ---------- */

  function previewErase(pt, p){

    clearOverlay(p); if(p.state.selection) drawSelection(p);

    const eps = Math.max(6,size*2);

    for(let i=p.state.strokes.length-1;i>=0;i--){

      const s=p.state.strokes[i]; let hit=false;

      if(s.type==='pen') hit=hitPolyline(s.points,pt,eps);

      else if(s.type==='line') hit=distToSegment(pt,s.a,s.b)<=eps;

      else if(s.type==='text'){ const b=bboxStroke(s); hit=(pt.x>=b.x&&pt.x<=b.x+b.w&&pt.y>=b.y&&pt.y<=b.y+b.h); }

      else if(s.type==='poly'){ hit = s.points && hitPolyline(s.points, pt, eps); }

      if(hit){

        p.ovl.save(); p.ovl.lineCap='round'; p.ovl.lineJoin='round';

        if(s.type==='pen'){

          const pts=s.points; if(!pts.length){ p.ovl.restore();return; }

          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2);

          p.ovl.beginPath(); p.ovl.moveTo(pts[0].x, pts[0].y);

          for(let j=1;j<pts.length;j++){ p.ovl.lineTo(pts[j].x, pts[j].y); }

          p.ovl.stroke();

        }else if(s.type==='line'){

          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2);

          p.ovl.beginPath(); p.ovl.moveTo(s.a.x,s.a.y); p.ovl.lineTo(s.b.x,s.b.y); p.ovl.stroke();

        }else if(s.type==='text'){

          const b=bboxStroke(s); p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=2; p.ovl.setLineDash([5,4]);

          p.ovl.strokeRect(b.x,b.y,b.w,b.h); p.ovl.setLineDash([]);

        }else if(s.type==='poly' && s.points && s.points.length){

          p.ovl.strokeStyle='#ff3b3b'; p.ovl.lineWidth=Math.max(2, s.size+2); p.ovl.setLineDash([5,4]);

          p.ovl.beginPath();

          p.ovl.moveTo(s.points[0].x, s.points[0].y);

          for(let k=1;k<s.points.length;k++){ p.ovl.lineTo(s.points[k].x, s.points[k].y); }

          p.ovl.closePath();

          p.ovl.stroke();

          p.ovl.setLineDash([]);

        }

        p.ovl.restore(); return;

      }

    }

  }

  function eraseAt(pt,p){

    const eps = Math.max(6, size*2);

    let removed=false;

    const removedIds=[];

    const removedImageIds=[];

    for(let i=p.state.strokes.length-1;i>=0;i--){

      const s = p.state.strokes[i];

      let hit=false;

      if(s.type==='pen' && hitPolyline(s.points,pt,eps)){ hit=true; }

      else if(s.type==='line' && distToSegment(pt,s.a,s.b)<=eps){ hit=true; }

      else if(s.type==='poly' && s.points && hitPolyline(s.points,pt,eps)){ hit=true; }

      else if(s.type==='text'){

        const b=bboxStroke(s);

        if(pt.x>=b.x&&pt.x<=b.x+b.w&&pt.y>=b.y&&pt.y<=b.y+b.h){ hit=true; }

      }

      if(hit){

        if(s.id) removedIds.push(s.id);

        p.state.strokes.splice(i,1);

        removed=true;

      }

    }

    // Gumka nie rusza obrazów – ich kasowanie zostawiamy selekcji/koszowi.

    // (Kiedyś można dodać tryb, ale domyślnie chronimy obrazki przed przypadkowym usunięciem.)

    if(removed){

      renderAll(p);

      clearOverlay(p);

      [...removedIds, ...removedImageIds].forEach(id=>emitElementRemove(id));

    }

  }







  /* ---------- TEKST INLINE ---------- */

  let activeTextEditor = null;



  function getTextElementCanvasData(element, page, fallback){

    if(!element || !page) return fallback || null;

    const local = elementToLocalText(element, page);

    if(local) return local;

    const data = element.data || {};

    return {

      id: element.id,

      x: data.x ?? element.x ?? (fallback?.x ?? 0),

      y: data.y ?? element.y ?? (fallback?.y ?? 0),

      text: data.text ?? element.text ?? '',

      color: data.color ?? element.color ?? fallback?.color ?? '#0b1320',

      size: data.size ?? element.size ?? fallback?.size ?? 3

    };

  }



  function openTextEditorForElement(element, page, isNew, clickX, clickY){

    closeTextEditor(false);



    const rect = page.el.getBoundingClientRect();

    const local = getTextElementCanvasData(element, page, { x: clickX || 0, y: clickY || 0, color, size });



    const textarea = document.createElement('textarea');

    textarea.className = 'text-editor';

    textarea.value = local.text || '';

    textarea.style.left = (rect.left + local.x) + 'px';

    textarea.style.top  = (rect.top  + local.y) + 'px';

    textarea.style.fontSize = Math.max(14, (local.size || 3) * 6) + 'px';

    document.body.appendChild(textarea);

    textarea.focus();



    activeTextEditor = {

      el: textarea,

      elementId: element.id,

      pageIndex: page.index

    };



    textarea.addEventListener('input', ()=>{

      const txt = textarea.value;

      const current = AliboardModel.get(element.id) || element;

      const updated = {

        ...current,

        text: txt,

        data: { ...(current.data || {}), text: txt }

      };

      AliboardModel.upsert(updated);

      if (window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementUpdate === 'function'){

        window.AliboardRealtime.broadcastElementUpdate(updated);

      }

      renderAll(page);

    });



    textarea.addEventListener('keydown', (e)=>{

      if(e.key === 'Enter' && !e.shiftKey){

        e.preventDefault();

        closeTextEditor(true);

      }

      if(e.key === 'Escape'){

        e.preventDefault();

        closeTextEditor(false);

      }

    });



    textarea.addEventListener('blur', ()=>{

      closeTextEditor(true);

    });

  }



  function closeTextEditor(commit){

    if(!activeTextEditor) return;

    const { el, elementId, pageIndex } = activeTextEditor;

    const value = el.value;

    activeTextEditor = null;

    if(el && el.isConnected){

      el.remove();

    }



    const page = PAGES[pageIndex];

    if(!page) return;



    const element = AliboardModel.get(elementId);

    if(!element) return;



    if(commit){

      const trimmed = value ? value.trim() : '';

      const updated = {

        ...element,

        text: trimmed,

        data: { ...(element.data || {}), text: trimmed }

      };

      AliboardModel.upsert(updated);

      if (window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementUpdate === 'function'){

        window.AliboardRealtime.broadcastElementUpdate(updated);

      }

    }

    renderAll(page);

  }



  /* ---------- COMPOSITE STRONY ---------- */

  /* ---------- COMPOSITE STRONY ---------- */

  async function compositePageCanvas(p){

    const dpr = window.devicePixelRatio || 1;

    const cssW = p.drawC.width / dpr, cssH = p.drawC.height / dpr;

    const tmp = document.createElement('canvas');

    tmp.width = Math.ceil(cssW * dpr);

    tmp.height = Math.ceil(cssH * dpr);

    theContext = tmp.getContext('2d');

    theContext.scale(dpr, dpr);

    const currentWidth = (p?.el?.getBoundingClientRect()?.width) || (p?.gridC?.clientWidth) || p.gridC.width;
    let stepOverride = p.state.templateStepPx;
    if(p.state.templateGridSize){
      stepOverride = computeStepPx(p.state.templateGridSize, currentWidth);
    }

    drawTemplateOnContext(theContext, cssW, cssH, p.state.templateKind, stepOverride);

    await Promise.all(p.state.images.map(im => im.img ? Promise.resolve() : new Promise(res=>{ const el=new Image(); el.onload=()=>{im.img=el; res();}; el.src=im.src; })));

    for(const im of p.state.images){ if(im.img) theContext.drawImage(im.img, im.x, im.y, im.w, im.h); }



    theContext.lineCap='round'; theContext.lineJoin='round';

    for(const s of p.state.strokes){

      if(s.type==='pen'){

        theContext.strokeStyle=s.color; theContext.lineWidth=s.size; const pts=s.points; if(!pts.length) continue;

        theContext.beginPath(); theContext.moveTo(pts[0].x, pts[0].y); for(let i=1;i<pts.length;i++){ theContext.lineTo(pts[i].x, pts[i].y); } theContext.stroke();

      }else if(s.type==='line'){

        theContext.strokeStyle=s.color; theContext.lineWidth=s.size; theContext.beginPath(); theContext.moveTo(s.a.x,s.a.y); theContext.lineTo(s.b.x,s.b.y); theContext.stroke();

      }else if(s.type==='text'){

        theContext.save(); theContext.fillStyle=s.color; theContext.font = `${Math.max(14, s.size*6)}px ui-sans-serif, system-ui, Arial`; theContext.textBaseline='top'; theContext.fillText(s.text, s.x, s.y); theContext.restore();

      }else if(s.type==='poly'){

        const pts=s.points;

        if(!pts || !pts.length) continue;

        theContext.save();

        theContext.strokeStyle=s.color;

        theContext.lineWidth=s.size;

        theContext.lineCap='round';

        theContext.lineJoin='round';

        theContext.beginPath();

        theContext.moveTo(pts[0].x, pts[0].y);

        for(let i=1;i<pts.length;i++){ theContext.lineTo(pts[i].x, pts[i].y); }

        if(s.closed){ theContext.closePath(); }

        theContext.stroke();

        theContext.restore();

      }

    }

    return tmp;

  }



  /* ---------- CROP (wycinanie) ---------- */

  let cropRectEl=null, cropStart=null, cropProcessing=false, cropBusyHintEl=null, cropBusyHintTimer=null;

  function beginCrop(x,y,p){

    cropCancel();

    cropStart = {x,y};

    cropRectEl = document.createElement('div'); cropRectEl.className='crop-rect';

    const r = p.drawC.getBoundingClientRect();

    const docLeft = r.left + window.scrollX;

    const docTop  = r.top  + window.scrollY;

    cropRectEl.style.left = (docLeft + x) + 'px';

    cropRectEl.style.top  = (docTop  + y) + 'px';

    cropRectEl.style.width='0px'; cropRectEl.style.height='0px';

    document.body.appendChild(cropRectEl);

  }

  function updateCrop(x,y,p){

    if(!cropRectEl || !cropStart) return;

    const r = p.drawC.getBoundingClientRect();

    const docLeft = r.left + window.scrollX;

    const docTop  = r.top  + window.scrollY;

    const x0 = Math.min(cropStart.x, x), y0 = Math.min(cropStart.y, y);

    const x1 = Math.max(cropStart.x, x), y1 = Math.max(cropStart.y, y);

    cropRectEl.style.left = (docLeft + x0) + 'px';

    cropRectEl.style.top  = (docTop  + y0) + 'px';

    cropRectEl.style.width  = (x1 - x0) + 'px';

    cropRectEl.style.height = (y1 - y0) + 'px';

  }

  function cropCancel(){ cropStart=null; if(cropRectEl){ cropRectEl.remove(); cropRectEl=null; } }

  async function finalizeCrop(x,y,p){

    if(!cropRectEl || !cropStart){ return; }

    const x0 = Math.min(cropStart.x, x), y0 = Math.min(cropStart.y, y);

    const x1 = Math.max(cropStart.x, x), y1 = Math.max(cropStart.y, y);

    cropCancel();



    if(!selectionHasContent(p, x0, y0, x1, y1)){

      return;

    }



    cropProcessing = true;

    try{

      const placement = await askCropPlacement();



      const comp = await compositePageCanvas(p);

      const dpr = window.devicePixelRatio || 1;

      const cssWidth = Math.max(1, Math.round(x1 - x0));

      const cssHeight = Math.max(1, Math.round(y1 - y0));

      const pxWidth = Math.max(1, Math.round(cssWidth * dpr));

      const pxHeight = Math.max(1, Math.round(cssHeight * dpr));

      const sx = Math.max(0, Math.floor(x0 * dpr)), sy = Math.max(0, Math.floor(y0 * dpr));

      const cut = document.createElement('canvas'); cut.width=pxWidth; cut.height=pxHeight;

      const cctx = cut.getContext('2d');

      cctx.drawImage(comp, sx, sy, pxWidth, pxHeight, 0, 0, pxWidth, pxHeight);

      cctx.imageSmoothingEnabled = false;

      const url = cut.toDataURL('image/png');



      const margin = 24;

      const rect = p.el.getBoundingClientRect();

      const pageW = rect.width, pageH = rect.height;

      const selectionBox = {x:x0, y:y0, w:x1-x0, h:y1-y0};



      const maxW = pageW - margin*2;

      const maxH = pageH - margin*2;

      const scale = Math.min(1, maxW / cssWidth, maxH / cssHeight);

      const w = Math.max(1, Math.floor(cssWidth * scale));

      const h = Math.max(1, Math.floor(cssHeight * scale));



      let targetPage = p;

      let xPos = 0;

      let yPos = 0;

      const placeBelow = placement !== 'adjacent';



      if(placeBelow){

        const bboxBottom = bottomOfTexts(p);

        xPos = Math.floor((pageW - w)/2);

        yPos = bboxBottom + margin;



        if (yPos + h + margin > pageH){

          targetPage = createPage();

          const rect2 = targetPage.el.getBoundingClientRect();

          xPos = Math.floor((rect2.width - w)/2);

          yPos = 24;

        }

      }else{

        const adj = findAdjacentPosition(selectionBox, w, h, pageW, pageH, margin);

        xPos = adj.x;

        yPos = adj.y;

      }

      addImageFromSrc(url, w, h, xPos, yPos, {crop:true}, targetPage, {broadcast:true});

      targetPage.el.scrollIntoView({behavior:'smooth', block:'center'});

    }finally{

      cropProcessing = false;

    }

  }

  function bottomOfTexts(p){

    let bottom = 0;

    const candidates = p.state.strokes.filter(s=>s.type==='text').map(s=>{ const b=bboxStroke(s); return b.y+b.h; });

    if(candidates.length){ bottom = Math.max(...candidates); }

    else {

      const all = [

        ...p.state.strokes.map(s=>{ const b=bboxStroke(s); return b.y+b.h; }),

        ...p.state.images.map(im=> im.y + im.h)

      ];

      if(all.length) bottom = Math.max(...all);

    }

    return bottom;

  }

  /* ---------- ZDALNE KURSORY (CRDT) ---------- */

  function upsertRemoteCursor(cursor){

    if (!cursor || cursor.id == null) return;



    const pageIndex = cursor.pageIndex;

    const nx = Number.isFinite(cursor.nx) ? cursor.nx : cursor.x;

    const ny = Number.isFinite(cursor.ny) ? cursor.ny : cursor.y;



    if (!Number.isFinite(pageIndex) || !Number.isFinite(nx) || !Number.isFinite(ny)) return;



    const p = PAGES[pageIndex];

    if (!p || !p.el) return;



    let item = REMOTE_CURSORS.get(cursor.id);

    if (!item) {

      const el = document.createElement('div');

      el.className = 'remote-cursor';



      const dot = document.createElement('span');

      dot.className = 'remote-cursor-dot';



      const label = document.createElement('span');

      label.className = 'remote-cursor-label';



      el.appendChild(dot);

      el.appendChild(label);

      p.el.appendChild(el);



      item = { el, dot, label, pageIndex };

      REMOTE_CURSORS.set(cursor.id, item);

    }



    if (item.pageIndex !== pageIndex) {

      if (item.el.parentNode) {

        item.el.parentNode.removeChild(item.el);

      }

      p.el.appendChild(item.el);

      item.pageIndex = pageIndex;

    }



    const color = cursor.color || '#3b82f6';

    const labelText = cursor.label || 'Uczestnik';



    item.dot.style.backgroundColor = color;

    item.label.textContent = labelText;



    item.el.style.left = (nx * 100) + '%';

    item.el.style.top  = (ny * 100) + '%';

  }

  function selectionHasContent(p, x0, y0, x1, y1){

    const left = Math.min(x0,x1), right = Math.max(x0,x1);

    const top = Math.min(y0,y1), bottom = Math.max(y0,y1);

    const rect = {x:left, y:top, w:Math.max(0,right-left), h:Math.max(0,bottom-top)};

    if(rect.w===0 || rect.h===0) return false;

    const overlaps = (box)=> rect.x < box.x + box.w && rect.x + rect.w > box.x && rect.y < box.y + box.h && rect.y + rect.h > box.y;

    for(const s of p.state.strokes){

      if((s.type==='pen' || s.type==='poly') && (!s.points || !s.points.length)) continue;

      const box = bboxStroke(s);

      if(box.w===0 && box.h===0) continue;

      if(overlaps(box)){ return true; }

    }

    for(const im of (p.state.images||[])){

      const box = {x:im.x, y:im.y, w:im.w, h:im.h};

      if(overlaps(box)){ return true; }

    }

    return false;

  }

  function findAdjacentPosition(selection, w, h, pageW, pageH, margin){

    const clamp = (val, min, max)=> Math.min(Math.max(val, min), max);

    const maxX = Math.max(0, pageW - w);

    const maxY = Math.max(0, pageH - h);

    let xPos = selection.x + selection.w + margin;

    if(xPos + w > pageW){

      xPos = selection.x - w - margin;

    }

    xPos = clamp(xPos, 0, maxX);

    let yPos = clamp(selection.y, 0, maxY);

    if(yPos + h > pageH){

      yPos = maxY;

    }

    return {x:xPos, y:yPos};

  }

  function askCropPlacement(){

    return new Promise(resolve=>{

      const overlay=document.createElement('div');

      overlay.className='crop-choice-backdrop';

      const dialog=document.createElement('div');

      dialog.className='crop-choice-dialog';

    const text=document.createElement('p');

    text.textContent='Gdzie umieścić skopiowany fragment?';

      const actions=document.createElement('div');

      actions.className='crop-choice-actions';

      const btnBelow=document.createElement('button');

      btnBelow.className='primary';

      btnBelow.textContent='Kopiuj na dole';

      const btnAside=document.createElement('button');

      btnAside.className='secondary';

      btnAside.textContent='Kopiuj obok';



      let cleaned=false;

      function cleanup(choice){

        if(cleaned) return;

        cleaned=true;

        document.removeEventListener('keydown', onOverlayKey);

        overlay.classList.remove('open');

        let removed=false;

        const removeNow=()=>{ if(removed) return; removed=true; overlay.remove(); };

        overlay.addEventListener('transitionend', removeNow, {once:true});

        setTimeout(removeNow, 220);

        resolve(choice || 'below');

      }

      function onOverlayKey(e){

        if(e.key==='Escape'){

          cleanup('below');

        }

      }



      btnBelow.addEventListener('click', ()=> cleanup('below'));

      btnAside.addEventListener('click', ()=> cleanup('adjacent'));

      overlay.addEventListener('click', (e)=>{

        if(e.target===overlay){ cleanup('below'); }

      });

      document.addEventListener('keydown', onOverlayKey);



      actions.appendChild(btnBelow);

      actions.appendChild(btnAside);

      dialog.appendChild(text);

      dialog.appendChild(actions);

      overlay.appendChild(dialog);

      document.body.appendChild(overlay);

      requestAnimationFrame(()=> overlay.classList.add('open'));

    });

  }

  function showCropBusyHint(){

    if(cropBusyHintEl){

      clearTimeout(cropBusyHintTimer);

      cropBusyHintEl.remove();

      cropBusyHintEl=null;

    }

    const toast=document.createElement('div');

    toast.className='crop-busy-toast';

    toast.textContent='Poczekaj na zako?czenie kopiowania...';

    document.body.appendChild(toast);

    requestAnimationFrame(()=> toast.classList.add('show'));

    cropBusyHintEl=toast;

    cropBusyHintTimer=setTimeout(()=>{

      toast.classList.remove('show');

      const remove=()=>{

        toast.removeEventListener('transitionend', remove);

        if(cropBusyHintEl===toast){ cropBusyHintEl=null; cropBusyHintTimer=null; }

        toast.remove();

      };

      toast.addEventListener('transitionend', remove);

      setTimeout(remove, 400);

    }, 2000);

  }



  /* ---------- INTERAKCJE (POINTER) ---------- */

const ROTATE_HANDLE = 99;



function rectToPoly(x0,y0,x1,y1){

  const left=Math.min(x0,x1), right=Math.max(x0,x1);

  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);

  return [

    {x:left,y:top}, {x:right,y:top}, {x:right,y:bottom}, {x:left,y:bottom}

  ];

  }

  function isoTriangleFromRect(x0,y0,x1,y1){

    const left=Math.min(x0,x1), right=Math.max(x0,x1);

    const top=Math.min(y0,y1), bottom=Math.max(y0,y1);

    const midX = (left+right)/2;

    return [{x:midX,y:top},{x:right,y:bottom},{x:left,y:bottom}];

  }

  function rightTriangleFromRect(x0,y0,x1,y1){

    const left=Math.min(x0,x1), right=Math.max(x0,x1);

    const top=Math.min(y0,y1), bottom=Math.max(y0,y1);

    return [{x:left,y:top},{x:right,y:top},{x:left,y:bottom}];

  }

function hexFromRect(x0,y0,x1,y1){

  const left=Math.min(x0,x1), right=Math.max(x0,x1);

  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);

  const w=right-left, h=bottom-top;

  const cx=left+w/2, cy=top+h/2;

  const r = Math.min(w, h)/2;

  const pts=[];

  for(let i=0;i<6;i++){

    const a = Math.PI/6 + i * (Math.PI/3);

    pts.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a)});

  }

  return pts;

}

function circleFromRect(x0,y0,x1,y1){

  const left=Math.min(x0,x1), right=Math.max(x0,x1);

  const top=Math.min(y0,y1), bottom=Math.max(y0,y1);

  const w=right-left, h=bottom-top;

  const cx=left+w/2, cy=top+h/2;

  const r = Math.min(w, h)/2;

  const segments = 24;

  const pts=[];

  for(let i=0;i<segments;i++){

    const a = i*(2*Math.PI/segments);

    pts.push({x: cx + r*Math.cos(a), y: cy + r*Math.sin(a)});

  }

  return pts;

}

function shapeFromDrag(shape, x0,y0,x1,y1){

  if(shape==='rect') return rectToPoly(x0,y0,x1,y1);

  if(shape==='tri_iso') return isoTriangleFromRect(x0,y0,x1,y1);

  if(shape==='tri_right') return rightTriangleFromRect(x0,y0,x1,y1);

  if(shape==='hex') return hexFromRect(x0,y0,x1,y1);

  if(shape==='circle') return circleFromRect(x0,y0,x1,y1);

  return rectToPoly(x0,y0,x1,y1);

}

function rotatePointAround(pt, center, angle){

  const dx = pt.x - center.x;

  const dy = pt.y - center.y;

  return {

    x: center.x + dx * Math.cos(angle) - dy * Math.sin(angle),

    y: center.y + dx * Math.sin(angle) + dy * Math.cos(angle)

  };

}

function rectCorners(x,y,w,h){

  return [

    {x, y},

    {x: x+w, y},

    {x: x+w, y: y+h},

    {x, y: y+h}

  ];

}

function axisAlignedBBox(points){

  const xs = points.map(p=>p.x);

  const ys = points.map(p=>p.y);

  const minx = Math.min(...xs), maxx = Math.max(...xs);

  const miny = Math.min(...ys), maxy = Math.max(...ys);

  return {x:minx, y:miny, w:maxx-minx, h:maxy-miny};

}

function imageBoundingBox(im){

  if(!im) return {x:0,y:0,w:0,h:0};

  if(!im.rotation){

    return {x:im.x, y:im.y, w:im.w, h:im.h};

  }

  const center = {x: im.x + im.w/2, y: im.y + im.h/2};

  const corners = rectCorners(im.x, im.y, im.w, im.h).map(pt=>rotatePointAround(pt, center, im.rotation));

  return axisAlignedBBox(corners);

}

function textDimensions(s){

  const w = (Math.max(14, s.size*6)*0.6)*(s.text?.length||0);

  const h = Math.max(14, s.size*6);

  return {w,h};

}



  function bindPage(p){

    function getXY(evt){

      const r = p.drawC.getBoundingClientRect();

      return { x: evt.clientX - r.left, y: evt.clientY - r.top };

    }

    let drawing=false, startX=0, startY=0, current=null, currentSent=false, cropping=false;

    const touchPointers = new Set();   // aktywne pointerId typu touch

    const activePointers = new Set();

    let multiPan=false;                // tryb dwupalczastego scrolla

    let panCentroidY=null;             // poprzedni centroid dotyk?w (Y)

    const pointerPosY = new Map();     // pointerId -> ostatni clientY

    let panIdleTimer=null;

    const PAN_IDLE_MS = 350;



    function endMultiPan(reason){

      multiPan=false;

      panCentroidY=null;

      pointerPosY.clear();

      touchPointers.clear();

      activePointers.clear();

      if(panIdleTimer){ clearTimeout(panIdleTimer); panIdleTimer=null; }

    }



    function currentTouchCentroid(){

      let sumY=0, cnt=0;

      touchPointers.forEach(id=>{

        if(pointerPosY.has(id)){

          sumY += pointerPosY.get(id);

          cnt++;

        }

      });

      return cnt>=2 ? sumY / cnt : null;

    }



    function start(x,y){

      if(tool===TOOLS.SELECT){

        const pt={x,y};

        if(p.state.selection){

          const h = hitHandle(pt, p.state.selection.bbox);

          if(h===ROTATE_HANDLE){

            const sel = p.state.selection;

            if(sel.kind==='stroke'){

              const s = p.state.strokes[sel.index];

              if(s.type==='poly'){

                const center = {x: sel.bbox.x + sel.bbox.w/2, y: sel.bbox.y + sel.bbox.h/2};

                p.state.dragging={

                  mode:'rotate',

                  startAngle: Math.atan2(y-center.y, x-center.x),

                  center,

                  original: cloneStrokeState(s)

                };

                pushHistory(p);

                return;

              }

            }

            return;

          }else if(h>=0){

            const sel = p.state.selection;

            const original = sel.kind==='image'

              ? cloneImageState(p.state.images[sel.index])

              : cloneStrokeState(p.state.strokes[sel.index]);

            p.state.dragging={

              mode:'scale',

              handle:h,

              startX:x,

              startY:y,

              startBBox:{...sel.bbox},

              original

            };

            pushHistory(p);

            return;

          }

          const b=p.state.selection.bbox;

          if(x>=b.x&&x<=b.x+b.w&&y>=b.y&&y<=b.y+b.h){ p.state.dragging={mode:'move', startX:x, startY:y}; pushHistory(p); return; }

        }

        p.state.selection = hitTest(pt,p) || null; drawSelection(p); return;

      }

      if(tool===TOOLS.TEXT){

        const hit = hitTest({x,y}, p);

        if(hit && hit.kind === 'stroke'){

          const s = p.state.strokes[hit.index];

          if(s && s.type === 'text'){

            const elId = s.id;

            const el = elId ? AliboardModel.get(elId) : null;

            if(el){ openTextEditorForElement(el, p, false, x, y); }

            return;

          }

        }

        pushHistory(p);

        const dims = getPageDimensions(p);

        const rel = toRelativePoint({x,y}, dims) || { x: 0, y: 0 };

        const id = 'text_' + Date.now() + '_' + Math.random().toString(16).slice(2);

        const newElement = {

          id,

          kind: 'text',

          page: p.index,

          pageIndex: p.index,

          data: { x: rel.x, y: rel.y, text: '', color, size },

          text: '',

          color,

          size

        };

        AliboardModel.upsert(newElement);

        if(window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementAdd === 'function'){

          window.AliboardRealtime.broadcastElementAdd(newElement);

        }

        renderAll(p);

        openTextEditorForElement(AliboardModel.get(id) || newElement, p, true, x, y);

        return;

      }

      if(tool===TOOLS.CROP){

        if(cropProcessing){ showCropBusyHint(); return; }

        beginCrop(x,y,p); cropping=true; return;

      }

      if(tool===TOOLS.FIGURE){

        drawing=true; startX=x; startY=y; currentSent=false; pushHistory(p); clearOverlay(p);

        const pts = shapeFromDrag(currentShape, startX, startY, x, y);

        current = { id:newElementId(), type:'poly', color, size, points: pts, closed:true };

        p.state.strokes.push(current);

        renderAll(p);

        const payload = serializeStrokeElement(current, PAGES.indexOf(p));

        if(payload){

          AliboardModel.upsertElement(payload);

          const rt = window.AliboardRealtime;

          if(rt?.broadcastElementAdd){ rt.broadcastElementAdd(payload); currentSent=true; }

        }

        return;

      }



      drawing=true; startX=x; startY=y; currentSent=false; pushHistory(p);

      if(tool===TOOLS.PEN){

        current={id:newElementId(), type:'pen', color, size, points:[{x,y}]}; p.state.strokes.push(current); renderAll(p);

        const payload = serializeStrokeElement(current, PAGES.indexOf(p));

        if(payload){

          AliboardModel.upsertElement(payload);

          if(window.AliboardRealtime?.broadcastElementAdd){

            window.AliboardRealtime.broadcastElementAdd(payload);

          }

          currentSent = true;

        }

      }else if(tool===TOOLS.LINE){

        current={id:newElementId(), type:'line', color, size, a:{x,y}, b:{x,y}}; clearOverlay(p);

        const payload = serializeStrokeElement(current, PAGES.indexOf(p));

        if(payload){

          AliboardModel.upsertElement(payload);

          if(window.AliboardRealtime?.broadcastElementAdd){

            window.AliboardRealtime.broadcastElementAdd(payload);

          }

          currentSent = true;

        }

      }else if(tool===TOOLS.ERASER){

        eraseAt({x,y},p);

        current=null;

      }

    }

    function move(x,y){

      if (tool === TOOLS.SELECT){

        const d   = p.state.dragging;

        const sel = p.state.selection;



        if (d && sel){

          if (d.mode === 'move'){

            const dx = x - d.startX;

            const dy = y - d.startY;

            d.startX = x;

            d.startY = y;



            if (sel.kind === 'image'){

              const im = p.state.images[sel.index];

              if (!im) return;



              im.x += dx;

              im.y += dy;

              sel.bbox.x += dx;

              sel.bbox.y += dy;



              const updatePayload = serializeImageElement(im, PAGES.indexOf(p));

              if(updatePayload){

                AliboardModel.upsertElement(updatePayload);

                if (window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementUpdate === 'function'){

                  window.AliboardRealtime.broadcastElementUpdate(updatePayload);

                }

              }

            } else {

              const s = p.state.strokes[sel.index];

              if (!s) return;

              if (s.type === 'pen')  s.points.forEach(pt => { pt.x += dx; pt.y += dy; });

              if (s.type === 'line'){ s.a.x += dx; s.a.y += dy; s.b.x += dx; s.b.y += dy; }

              if (s.type === 'text'){ s.x += dx; s.y += dy; }

              if (s.type === 'poly' && s.points){ s.points.forEach(pt=>{pt.x+=dx;pt.y+=dy;}); }

              sel.bbox = bboxStroke(s);



              const updatePayload = serializeStrokeElement(s, PAGES.indexOf(p));

              if(updatePayload){

                AliboardModel.upsertElement(updatePayload);

                if (window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementUpdate === 'function'){

                  window.AliboardRealtime.broadcastElementUpdate(updatePayload);

                }

              }

            }



          } else if (d.mode === 'scale'){

            const nextBBox = computeScaledBBox(d.startBBox, d.handle, x, y);

            applyScaledSelection(sel, d, nextBBox, p);

            sel.bbox = nextBBox;



            // CRDT: broadcast zmiany rozmiaru obrazu/rysunku

            if (sel.kind === 'image'){

              const im = p.state.images[sel.index];

              const updatePayload = im ? serializeImageElement(im, PAGES.indexOf(p)) : null;

              if(updatePayload){

                AliboardModel.upsertElement(updatePayload);

                if (window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementUpdate === 'function'){

                  window.AliboardRealtime.broadcastElementUpdate(updatePayload);

                }

              }

            } else if (sel.kind === 'stroke'){

              const s = p.state.strokes[sel.index];

              const updatePayload = s ? serializeStrokeElement(s, PAGES.indexOf(p)) : null;

              if(updatePayload){

                AliboardModel.upsertElement(updatePayload);

                if (window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementUpdate === 'function'){

                  window.AliboardRealtime.broadcastElementUpdate(updatePayload);

                }

              }

            }

          }else if(d.mode==='rotate'){

            if(sel.kind==='stroke'){

              const s = p.state.strokes[sel.index];

              if(s && s.type==='poly'){

                const angle = Math.atan2(y-d.center.y, x-d.center.x);

                const delta = angle - d.startAngle;

                s.points = d.original.points.map(pt=>rotatePointAround(pt, d.center, delta));

                sel.bbox = bboxStroke(s);



                const updatePayload = serializeStrokeElement(s, PAGES.indexOf(p));

                if(updatePayload){

                  AliboardModel.upsertElement(updatePayload);

                  if (window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementUpdate === 'function'){

                    window.AliboardRealtime.broadcastElementUpdate(updatePayload);

                  }

                }

              }

            }

          }

            renderAll(p); drawSelection(p);

        }

        return;

      }

      if(tool===TOOLS.CROP && cropping){ updateCrop(x,y,p); return; }

      if(tool===TOOLS.ERASER){

        if(drawing){ eraseAt({x,y},p); }

        else{ previewErase({x,y},p); }

        return;

      }

      if(tool===TOOLS.FIGURE){

        if(!drawing) return;

        const pts = shapeFromDrag(currentShape, startX, startY, x, y);

        if(current){ current.points = pts; renderAll(p); }

        const payload = current ? serializeStrokeElement(current, PAGES.indexOf(p)) : null;

        if(payload){

          AliboardModel.upsertElement(payload);

          const rt = window.AliboardRealtime;

          if(rt?.broadcastElementUpdate){

            rt.broadcastElementUpdate(payload);

          }else if(!currentSent && rt?.broadcastElementAdd){

            rt.broadcastElementAdd(payload);

          }

          currentSent = true;

        }

        return;

      }

      if(!drawing) return;



      if(tool===TOOLS.PEN){

        current.points.push({x,y}); renderAll(p);

        const payload = serializeStrokeElement(current, PAGES.indexOf(p));

        if(payload){

          AliboardModel.upsertElement(payload);

          const rt = window.AliboardRealtime;

          if(rt?.broadcastElementUpdate){

            rt.broadcastElementUpdate(payload);

          }else if(!currentSent && rt?.broadcastElementAdd){

            rt.broadcastElementAdd(payload);

          }

          currentSent = true;

        }

      }

      else if(tool===TOOLS.LINE){

        current.b={x,y}; clearOverlay(p);

        p.ovl.lineCap='round'; p.ovl.lineJoin='round'; p.ovl.strokeStyle=color; p.ovl.lineWidth=size;

        p.ovl.beginPath(); p.ovl.moveTo(startX,startY); p.ovl.lineTo(x,y); p.ovl.stroke();

        const payload = serializeStrokeElement(current, PAGES.indexOf(p));

        if(payload){

          AliboardModel.upsertElement(payload);

          const rt = window.AliboardRealtime;

          if(rt?.broadcastElementUpdate){

            rt.broadcastElementUpdate(payload);

          }else if(!currentSent && rt?.broadcastElementAdd){

            rt.broadcastElementAdd(payload);

          }

          currentSent = true;

        }

      }

    }

    function end(x,y){

      let strokeToSync = null;

      if(tool===TOOLS.SELECT){

        const sel = p.state.selection;

        if (sel && sel.kind === "image" && window.AliboardRealtime && typeof window.AliboardRealtime.broadcastElementUpdate === "function"){

          const imRef = p.state.images[sel.index];

          const payload = serializeImageElement(imRef, PAGES.indexOf(p));

          if(payload){

            AliboardModel.upsertElement(payload);

            window.AliboardRealtime.broadcastElementUpdate(payload);

          }

        }

        p.state.dragging=null; return; }

      if(tool===TOOLS.CROP && cropping){ cropping=false; finalizeCrop(x,y,p); return; }

      if(tool===TOOLS.ERASER){

        drawing=false;

        clearOverlay(p);

        if(p.state.selection) drawSelection(p);

        return;

      }

      if(tool===TOOLS.FIGURE){

        if(!drawing) return;

        const pts = shapeFromDrag(currentShape, startX, startY, x, y);

        clearOverlay(p);

        if(current){

          current.points = pts;

          renderAll(p);

          strokeToSync = current;

        }

        drawing=false;

      }else{

        if(!drawing) return;

        if(tool===TOOLS.LINE){

          clearOverlay(p);

          current.b={x,y};

          p.state.strokes.push(current);

          renderAll(p);

          strokeToSync = current;

        }

        if(tool===TOOLS.PEN){

          strokeToSync = current;

        }

        drawing=false;

      }

      if(strokeToSync){

        const payload = serializeStrokeElement(strokeToSync, PAGES.indexOf(p));

        if(payload){

          AliboardModel.upsertElement(payload);

          const rt = window.AliboardRealtime;

          if(!currentSent && rt?.broadcastElementAdd){

            rt.broadcastElementAdd(payload);

          }else if(rt?.broadcastElementUpdate){

            rt.broadcastElementUpdate(payload);

          }

        }

      }

      current=null;

      currentSent=false;

    }



    function trackTouch(e, isDown){

      if(e.pointerType!=='touch') return;

      if(isDown){

        touchPointers.add(e.pointerId);

        pointerPosY.set(e.pointerId, e.clientY);

      }else{

        touchPointers.delete(e.pointerId);

        pointerPosY.delete(e.pointerId);

      }

      const shouldPan = touchPointers.size >= 2;

      if(shouldPan && !multiPan){

        multiPan = true;

        drawing = false;

        activePointers.clear();

        panCentroidY = currentTouchCentroid();

        if(panIdleTimer) clearTimeout(panIdleTimer);

        panIdleTimer = setTimeout(()=>{ endMultiPan('idle-start'); }, PAN_IDLE_MS);

        try{

          touchPointers.forEach(id=>{ try{ p.drawC.releasePointerCapture(id); }catch(_){} });

        }catch(_){ }

      }else if(!shouldPan && multiPan){

        endMultiPan('pointer-drop');

      }else if(shouldPan && multiPan){

        const centroid = currentTouchCentroid();

        if(centroid!==null){ panCentroidY = centroid; }

        if(panIdleTimer) clearTimeout(panIdleTimer);

        panIdleTimer = setTimeout(()=>{ endMultiPan('idle-change'); }, PAN_IDLE_MS);

      }

    }



    p.drawC.addEventListener('pointerdown', (e)=>{

      trackTouch(e, true);

      if(multiPan) return;

      e.preventDefault();

      p.drawC.setPointerCapture(e.pointerId);

      pointerPosY.set(e.pointerId, e.clientY);

      const {x,y}=getXY(e);

      start(x,y);

      activePointers.add(e.pointerId);

    }, {passive:false});

    p.drawC.addEventListener('pointermove', (e)=>{

      if(multiPan){

        e.preventDefault();

        if(e.pointerType==='touch'){ pointerPosY.set(e.pointerId, e.clientY); }

        const cy = currentTouchCentroid();

        if(cy!==null){

          if(panCentroidY!==null){

            const dy = cy - panCentroidY;

            wrapEl.scrollTop -= dy;

          }

          panCentroidY = cy;

          if(panIdleTimer) clearTimeout(panIdleTimer);

          panIdleTimer = setTimeout(()=>{ endMultiPan('idle'); }, PAN_IDLE_MS);

        }

        return;

      }

      if(tool!==TOOLS.SELECT || e.buttons) e.preventDefault();

      const {x,y}=getXY(e);

      move(x,y);



      // ZDALNY KURSOR: wyslij swoja pozycje (znormalizowana)

      if (window.AliboardRealtime && typeof window.AliboardRealtime.sendCursor === "function") {

        const rect = p.drawC.getBoundingClientRect();

        if (rect.width && rect.height) {

          const nx = x / rect.width;

          const ny = y / rect.height;

          window.AliboardRealtime.sendCursor({

            pageIndex: p.index != null ? p.index : PAGES.indexOf(p),

            nx,

            ny

          });

        }

      }

    }, {passive:false});

    function handlePointerRelease(e){

      trackTouch(e, false);

      if(multiPan){

        pointerPosY.delete(e.pointerId);

        const cy = currentTouchCentroid();

        if(cy!==null){ panCentroidY = cy; }

        return;

      }

      if(!activePointers.has(e.pointerId)) return;

      activePointers.delete(e.pointerId);

      e.preventDefault();

      const {x,y}=getXY(e);

      end(x,y);

      try{ p.drawC.releasePointerCapture(e.pointerId);}catch(_){ }

    }

    p.drawC.addEventListener('pointerup', handlePointerRelease, {passive:false});

    p.drawC.addEventListener('pointercancel', handlePointerRelease, {passive:false});



    function globalTouchCleanup(e, isDown){

      if(e.pointerType && e.pointerType!=='touch') return;

      if(isDown) return;

      if(pointerPosY.has(e.pointerId)) pointerPosY.delete(e.pointerId);

      if(touchPointers.has(e.pointerId)) touchPointers.delete(e.pointerId);

      if(touchPointers.size<2 && multiPan){

        endMultiPan('global-release');

      }

    }

    window.addEventListener('pointerup', (e)=>globalTouchCleanup(e,false), {passive:false});

    window.addEventListener('pointercancel', (e)=>globalTouchCleanup(e,false), {passive:false});

    window.addEventListener('touchend', ()=>{ if(multiPan) endMultiPan('touchend'); }, {passive:false});

    window.addEventListener('touchcancel', ()=>{ if(multiPan) endMultiPan('touchcancel'); }, {passive:false});

    document.addEventListener('visibilitychange', ()=>{ if(document.hidden && multiPan){ endMultiPan('hidden'); } });

  }



  /* ---------- UI OGÓLNY ---------- */

  function toolLabel(){

    return tool===TOOLS.SELECT?'Kursor':

           tool===TOOLS.PEN?'Ołówek':

           tool===TOOLS.LINE?'Linia':

           tool===TOOLS.ERASER?'Gumka':

           tool===TOOLS.TEXT?'Tekst':

           tool===TOOLS.CROP?'Wycinanie':'Figury';

  }

  function setTool(next){

    const prevTool = tool;

    tool = next;

    handleTextToolToggle(prevTool);

    updateState();

    document.querySelectorAll('#tools [data-tool]').forEach(b=>{

      b.classList.toggle('is-active', b.getAttribute('data-tool')===tool);

    });

    if(tool!==TOOLS.FIGURE){ toggleFigurePalette(false); }

    else { ensureFigurePalette(); updateFigurePaletteSelection(); }

    PAGES.forEach(p=>{ clearOverlay(p); drawSelection(p); });

  }

  function updateState(){

    const shapeLabel = tool===TOOLS.FIGURE

      ? `  ${currentShape==='rect'?'Kwadrat':currentShape==='tri_iso'?'Trójkąt':currentShape==='tri_right'?'Trójkąt 90°':currentShape==='hex'?'Sześciokąt':'Koło'}`

      : '';

    const sizeLabel = tool===TOOLS.TEXT ? `${Math.round(textFontSizePx)}px` : `${size}px`;

    stateEl.textContent = `Tryb: ${toolLabel()}  ${sizeLabel}  ${color}${shapeLabel}`;

    updateFigurePaletteSelection();

  }

const toolsRow = document.getElementById('tools');

  toolsRow.addEventListener('pointerdown', (e)=>{

    const b = e.target.closest('[data-tool]'); if(!b) return;

    e.preventDefault();

    const toolName = b.getAttribute('data-tool');

    setTool(toolName);

    if(toolName===TOOLS.FIGURE){

      figureBtn = b;

      toggleFigurePalette(true);

    }else{

      toggleFigurePalette(false);

    }

  });

  document.addEventListener('pointerdown', (e)=>{

    const sh = e.target.closest('.figure-palette .shape-btn');

    if(!sh) return;

    e.preventDefault();

    e.stopPropagation();

    currentShape = sh.getAttribute('data-shape') || 'rect';

    updateFigurePaletteSelection();

    toggleFigurePalette(false);

    setTool(TOOLS.FIGURE);

    updateState();

  });

  document.addEventListener('pointerdown', (e)=>{

    if(e.target.closest('[data-tool="figure"]') || (figurePalette && figurePalette.contains(e.target))) return;

    toggleFigurePalette(false);

  });

  if(textFontBtn){

    textFontBtn.addEventListener('pointerdown', (e)=>{

      if(tool!==TOOLS.TEXT) return;

      e.preventDefault();

      e.stopPropagation();

      const isOpen = textFontPanel?.classList.contains('open');

      toggleTextFontPanel(!isOpen);

      textFontBtn.classList.toggle('is-active', !isOpen);

    });

  }

  document.addEventListener('pointerdown', (e)=>{

    if(!textFontPanel || !textFontPanel.classList.contains('open')) return;

    if((textFontBtn && textFontBtn.contains(e.target)) || textFontPanel.contains(e.target)) return;

    toggleTextFontPanel(false);

  });

  document.addEventListener('keydown', (e)=>{

    if(e.key==='Escape' && textFontPanel && textFontPanel.classList.contains('open')){

      toggleTextFontPanel(false);

    }

  });

  document.getElementById('color').addEventListener('input', e=>{ color=e.target.value; updateState(); });

  const sizeSelect = document.getElementById('size');

  if(sizeSelect){

    const lineWidthMenu = document.getElementById('lineWidthMenu');

    const lineWidthBtn = document.getElementById('lineWidthBtn');

    const lineOptions = lineWidthMenu ? Array.from(lineWidthMenu.querySelectorAll('.line-option')) : [];



    function updateLineWidthMenuActive(val){

      lineOptions.forEach(opt=>{

        opt.classList.toggle('active', String(opt.dataset.size)===String(val));

      });

    }



    sizeSelect.addEventListener('change', e=>{

      const nextSize = parseInt(e.target.value,10);

      if(Number.isNaN(nextSize)) return;

      size = nextSize;

      updateLineWidthMenuActive(nextSize);

      if(tool===TOOLS.TEXT){

        setTextFontPx(nextSize * 6);

      }else{

        lastBrushSize = size;

        updateState();

      }

    });



    lineOptions.forEach(opt=>{

      opt.addEventListener('pointerdown', (ev)=>{

        ev.preventDefault();

        const val = parseInt(opt.dataset.size,10);

        if(Number.isNaN(val)) return;

        sizeSelect.value = String(val);

        sizeSelect.dispatchEvent(new Event('change', {bubbles:true}));

        lineWidthMenu.classList.remove('open');

      });

    });



    updateLineWidthMenuActive(sizeSelect.value);



    if(lineWidthBtn && lineWidthMenu){

      lineWidthBtn.addEventListener('pointerdown', (ev)=>{

        ev.preventDefault();

        ev.stopPropagation();

        const isOpen = lineWidthMenu.classList.contains('open');

        const r = lineWidthBtn.getBoundingClientRect();

        lineWidthMenu.style.left = `${r.left}px`;

        lineWidthMenu.style.top = `${r.bottom + 6}px`;

        lineWidthMenu.classList.toggle('open', !isOpen);

      });



      document.addEventListener('pointerdown', (ev)=>{

        if(!lineWidthMenu.classList.contains('open')) return;

        if(lineWidthMenu.contains(ev.target) || (lineWidthBtn && lineWidthBtn.contains(ev.target))) return;

        lineWidthMenu.classList.remove('open');

      });

    }

  }

  if(deleteSelectionBtn){

    deleteSelectionBtn.addEventListener('pointerdown', (e)=>{

      e.preventDefault();

      deleteCurrentSelection();

    });

  }

  updateDeleteButtonState();



  window.addEventListener('keydown', (e)=>{

    if(e.key==='v'||e.key==='V') setTool(TOOLS.SELECT);

    if(e.key==='p'||e.key==='P') setTool(TOOLS.PEN);

    if(e.key==='l'||e.key==='L') setTool(TOOLS.LINE);

    if(e.key==='e'||e.key==='E') setTool(TOOLS.ERASER);

    if(e.key==='t'||e.key==='T') setTool(TOOLS.TEXT);

    if(e.key==='c'||e.key==='C') setTool(TOOLS.CROP);

    if(e.key==='f'||e.key==='F'){

      setTool(TOOLS.FIGURE);

      figureBtn = document.querySelector('[data-tool="figure"]');

      toggleFigurePalette(true);

    }

  });



  // MENU (po prawej)

  const menuBtn = document.getElementById('menuBtn');

  const dropdown = document.getElementById('dropdown');

  const openBoardModal = document.getElementById('openBoardModal');

  const openBoardBtn = document.getElementById('openBoardBtn');

  const openBoardInput = document.getElementById('openBoardName');

  const openBoardCancel = document.getElementById('openBoardCancel');

  const openBoardCreate = document.getElementById('openBoardCreate');



  function showOpenBoardModal(){

    if(!openBoardModal) return;

    openBoardModal.classList.add('open');

    openBoardModal.removeAttribute('aria-hidden');

    if(openBoardInput){

      openBoardInput.value='';

      setTimeout(()=> openBoardInput.focus(), 50);

    }

  }

  function hideOpenBoardModal(){

    if(!openBoardModal) return;

    openBoardModal.classList.remove('open');

    openBoardModal.setAttribute('aria-hidden','true');

  }

  function handleCreateBoard(){

    resetBoard();

    const page = createPage(true);

    if(openBoardInput){

      const label = openBoardInput.value.trim();

      if(label){ page.el.setAttribute('data-board-name', label); }

    }

    hideOpenBoardModal();

  }



  function toggleMenu(force){

    const open = typeof force==='boolean' ? force : !dropdown.classList.contains('open');

    dropdown.classList.toggle('open', open);

    menuBtn.setAttribute('aria-expanded', String(open));

  }

  menuBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); e.stopPropagation(); toggleMenu(); });

  document.addEventListener('pointerdown', (e)=>{ if(!dropdown.contains(e.target) && e.target!==menuBtn){ toggleMenu(false);} });



  dropdown.querySelectorAll('[data-grid]').forEach(btn=>{

    btn.addEventListener('pointerdown', (e)=>{

      e.preventDefault();

      const val = btn.getAttribute('data-grid');

      const page = currentPage();

      const pageIndex = page ? (Number.isFinite(page.index) ? page.index : PAGES.indexOf(page)) : 0;

      let sizeKey = 'md';
      if(val === '0'){ sizeKey = 'none'; }
      else if(val === '16'){ sizeKey = 'sm'; }
      else if(val === '24'){ sizeKey = 'md'; }
      else if(val === '32'){ sizeKey = 'lg'; }

      const currentWidth = (page?.el?.getBoundingClientRect()?.width) || (page?.gridC?.clientWidth) || (page?.gridC?.width) || 0;
      const stepPx = computeStepPx(sizeKey, currentWidth);
      const templateKind = val === 'tech'
        ? TEMPLATE_KINDS.GRID_TECH
        : gridStateToTemplateKind({ kind: 'grid', gridSize: sizeKey });

      setTemplateForPage(pageIndex, templateKind, { broadcast:true, gridSize: sizeKey, stepPx });

      if(window.AliboardRealtime && typeof window.AliboardRealtime.sendGridState === 'function'){

        const gridSize = val === 'tech' ? 'md' : sizeKey;

        const kind = val === 'tech' ? 'tech' : 'grid';

        window.AliboardRealtime.sendGridState({ gridSize, kind });

      }

      toggleMenu(false);

    });

  });

  if(openBoardBtn && openBoardBtn.tagName === 'BUTTON'){

    openBoardBtn.addEventListener('click', (e)=>{ e.preventDefault(); showOpenBoardModal(); toggleMenu(false); });

  }

  if(openBoardCancel){ openBoardCancel.addEventListener('click', hideOpenBoardModal); }

  if(openBoardCreate){ openBoardCreate.addEventListener('click', handleCreateBoard); }

  if(openBoardModal){

    openBoardModal.addEventListener('click', (e)=>{ if(e.target===openBoardModal){ hideOpenBoardModal(); } });

  }

  if(openBoardInput){

    openBoardInput.addEventListener('keydown', (e)=>{

      if(e.key==='Enter'){ e.preventDefault(); handleCreateBoard(); }

      if(e.key==='Escape'){ e.preventDefault(); hideOpenBoardModal(); }

    });

  }

  const saveToggle = document.getElementById('saveToggle');

  const saveRow = document.getElementById('saveRow');

  if(saveToggle && saveRow){

    saveToggle.addEventListener('pointerdown', (e)=>{

      e.preventDefault();

      saveRow.style.display = saveRow.style.display==='none' ? 'flex' : 'none';

    });

  }

  const templatesToggle = document.getElementById('templatesToggle');

  const gridToggle = document.getElementById('gridToggle');

  const templatesRow = document.getElementById('templatesRow');

  if(templatesToggle && gridToggle && templatesRow){

    templatesToggle.addEventListener('pointerdown', (e)=>{

      e.preventDefault();

      const showGrid = gridToggle.style.display==='none';

      gridToggle.style.display = showGrid ? 'block' : 'none';

      if(!showGrid){

        templatesRow.style.display = 'none';

      }

    });

    gridToggle.addEventListener('pointerdown', (e)=>{

      e.preventDefault();

      templatesRow.style.display = templatesRow.style.display==='none' ? 'flex' : 'none';

    });

  }

  const addPageBtn = document.getElementById('addPage');

  if(addPageBtn){ addPageBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); createPage(true); toggleMenu(false); }); }



  // EXPORT (aktualna strona)

  async function exportCurrent(ext){

    const p = currentPage(); if(!p) return;

    const c = await compositePageCanvas(p);

    if(ext==='png'){

      const a=document.createElement('a'); a.href=c.toDataURL('image/png'); a.download=ts('png'); a.click();

    }else if(ext==='jpg'){

      const a=document.createElement('a'); a.href=c.toDataURL('image/jpeg', .92); a.download=ts('jpg'); a.click();

    }else if(ext==='pdf'){

      const lib = window.jspdf?.jsPDF; if(!lib) return alert('PDF niezaładowany.');

      const dataUrl = c.toDataURL('image/png');

      const pdf = new lib({orientation:'portrait', unit:'pt', format:'a4'});

      const pw = pdf.internal.pageSize.getWidth(), ph = pdf.internal.pageSize.getHeight();

      const img = new Image();

      img.onload = ()=>{ const ratio = Math.min(pw/img.width, ph/img.height); const w = img.width*ratio, h = img.height*ratio; const x = (pw-w)/2, y=(ph-h)/2; pdf.addImage(dataUrl, 'PNG', x, y, w, h); pdf.save(ts('pdf')); };

      img.src = dataUrl;

    }

  }

  function ts(ext){ return `aliboard_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.${ext}`; }

  document.getElementById('savePng').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('png'); toggleMenu(false); });

  document.getElementById('saveJpg').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('jpg'); toggleMenu(false); });

  document.getElementById('savePdf').addEventListener('pointerdown', (e)=>{ e.preventDefault(); exportCurrent('pdf'); toggleMenu(false); });



  // UNDO (aktualna strona)

  document.getElementById('undo').addEventListener('pointerdown', (e)=>{ e.preventDefault(); const p=currentPage(); if(!p || !p.state.history.length) return; const last = p.state.history.pop(); p.state.redo.push(snapshotState(p)); restoreHistoryState(p, last); });



  // CLEAR (aktualna strona)

  const clearBtn = document.getElementById('clear');

  if (clearBtn) {

    clearBtn.addEventListener('pointerdown', (e)=>{

      e.preventDefault();

      const p = currentPage();

      if (!p) return;



      pushHistory(p);

      p.state.strokes = [];

      p.state.images  = [];

      p.state.selection = null;

      renderAll(p);

      clearOverlay(p);



    });

  }



  // USUŃ ZAZNACZONY OBIEKT (przycisk "Usuń zaznaczony obiekt")

  (function setupDeleteSelectionButton(){

    const btn = document.getElementById('deleteSelection'); // ‹ PODMIEŃ ID jeśli inny

    if (!btn) return;



    btn.addEventListener('pointerdown', (e) => {

      e.preventDefault();



      const p = currentPage();

      if (!p || !p.state.selection) return;



      const sel = p.state.selection;



      // 1) Obraz – usuwamy lokalnie i przez CRDT

      if (sel.kind === 'image') {

        const im = p.state.images[sel.index];

        if (!im) return;



        const id = im.__elementId;

        pushHistory(p);



        // lokalnie

        p.state.images.splice(sel.index, 1);

        if (id){

          AliboardModel.removeElement(id);

        }

        p.state.selection = null;

        renderAll(p);

        clearOverlay(p);



        // CRDT: powiadamiamy inne klienty

        if (id && window.AliboardRealtime &&

            typeof window.AliboardRealtime.broadcastElementRemove === 'function') {

          window.AliboardRealtime.broadcastElementRemove(id);

        }

      }



      // 2) (opcjonalnie) Stroke – na razie można usuwać tylko lokalnie

      /*

      if (sel.kind === 'stroke') {

        const s = p.state.strokes[sel.index];

        if (!s) return;



        pushHistory(p);

        p.state.strokes.splice(sel.index, 1);

        p.state.selection = null;

        renderAll(p);

        clearOverlay(p);



        // Jeśli kiedyś zrobimy CRDT dla kresek, tu dodamy broadcastElementRemove dla strokes

      }

      */

    });

  })();



  // WSTAW OBRAZ/PDF

  document.getElementById('imgInput').addEventListener('change', (e)=>{

    const f = e.target.files[0];

    if (!f) return;



    const p = currentPage();

    if (!p) return;



    const reader = new FileReader();

    reader.onload = function(ev) {

      const dataUrl = ev.target.result; // data:image/...;base64,...



      const temp = new Image();

      temp.onload = () => {

        const rect  = p.el.getBoundingClientRect();

        const ratio = Math.min(rect.width / temp.width, rect.height / temp.height);



        const w = Math.max(80, temp.width  * ratio);

        const h = Math.max(80, temp.height * ratio);

        const x = (rect.width  - w) / 2;

        const y = (rect.height - h) / 2;



        const meta = {

          file: true,

          id: 'img-' + Date.now().toString(36) + '-' + Math.random().toString(16).slice(2)

        };



        // lokalnie dodaj obraz

        addImageFromSrc(dataUrl, w, h, x, y, meta, p);

      };

      temp.src = dataUrl;

    };



    reader.readAsDataURL(f);

    e.target.value = '';

  });



  document.getElementById('pdfInput').addEventListener('change', async (e)=>{

    const f=e.target.files[0]; if(!f) return;

    const p=currentPage(); if(!p) return;

    const arrayBuffer = await f.arrayBuffer();

    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;

    let pageNum = 1; const ask = prompt(`PDF ma ${pdf.numPages} stron. Wpisz numer strony do wstawienia:`, "1");

    if(ask){ const n=parseInt(ask,10); if(!isNaN(n)&&n>=1&&n<=pdf.numPages) pageNum=n; }

    const page = await pdf.getPage(pageNum);

    const viewport = page.getViewport({scale: 2});

    const c = document.createElement('canvas'); c.width=viewport.width; c.height=viewport.height;

    const cctx = c.getContext('2d'); await page.render({canvasContext:cctx, viewport}).promise;

    const url = c.toDataURL('image/png');

    const targetPage = currentPage() || p;

    const rect=targetPage.el.getBoundingClientRect();

    const ratio = Math.min(rect.width/c.width, rect.height/c.height);

    const theWidth = Math.max(120, c.width*ratio);

    const theHeight=Math.max(120, c.height*ratio);

    const x = (rect.width-theWidth)/2, y=(rect.height-theHeight)/2;

    addImageFromSrc(url, theWidth, theHeight, x, y, {pdf:true,page:pageNum}, targetPage, {broadcast:true});

    e.target.value='';

  });



        // AUTODODAWANIE KARTKI przy przewijaniu

  wrapEl.addEventListener('scroll', ()=>{

    const nearBottom = wrapEl.scrollTop + wrapEl.clientHeight >= wrapEl.scrollHeight - 80;

    if(nearBottom){

      createPage(false);

    }

  }, {passive:true});



  // AUTOSAVE wielostronicowy usunięty – stan tylko z serwera i bieżącej sesji









  // --- CRDT: nas?uch zmian siatki przez AliboardRealtime (event "grid_state") ---

  if(window.AliboardRealtime && typeof window.AliboardRealtime.on === 'function'){

    window.AliboardRealtime.on('grid_state', (payload)=>{

      if(typeof window.aliboardApplyGridState === 'function'){

        window.aliboardApplyGridState(payload);

      }

    });

  }



  // [CODEX:BEGIN OVERFLOW_MENU]

  (function setupToolsOverflow(){

    const toolsRow = document.getElementById('tools');

    if(!toolsRow) return;

    console.debug('[ALIBOARD][overflow] init', {

      toolsRowExists: !!document.getElementById('tools'),

      headerExists: !!document.querySelector('header .left'),

    });



    // 1) Utwórz przycisk „…” i panel overflow zaraz obok paska narzędzi, jeżeli nie istnieją

    let moreBtn = document.getElementById('toolsMoreBtn');

    let moreBox = document.getElementById('toolsMorePanel');



    if(!moreBtn){

      moreBtn = document.createElement('button');

      moreBtn.id = 'toolsMoreBtn';

      moreBtn.className = 'btn';

      moreBtn.type = 'button';

      moreBtn.title = 'Więcej narzędzi';

      moreBtn.textContent = '…';

    toolsRow.appendChild(moreBtn);

    }

    if(!moreBox){

      moreBox = document.createElement('div');

      moreBox.id = 'toolsMorePanel';

      moreBox.className = 'dropdown';

      // otwieramy w lewo, obok paska narz?dzi

      moreBox.style.left = '0';

      moreBox.style.right = 'auto';

      moreBtn.insertAdjacentElement('afterend', moreBox);

    }



    // 2) Oznacz ?klejone? (nigdy nie przenoszone) narz?dzia ? rdze? paska

    //    (mo?esz dopasowa? list?; domy?lnie trzymamy: select, pen, line, eraser)

    const stickySelectors = [

      '[data-tool="select"]',

      '[data-tool="pen"]',

      '[data-tool="line"]',

      '[data-tool="eraser"]'

    ];

    const stickySet = new Set(

      stickySelectors

        .map(sel => toolsRow.querySelector(sel))

        .filter(Boolean)

    );



    // 3) Funkcja: przenie? elementy z overflow z powrotem do g??wnego rz?du

    function restoreFromOverflow(){

      // przywróć wszystko co było upchnięte

      [...moreBox.children].forEach(node => toolsRow.appendChild(node));

    }



    // 4) Funkcja: wylicz które elementy trzeba schować do „…”, aż przestanie się przelewać

    function rebalanceTools(){

      if(!toolsRow) return;



      console.debug('[ALIBOARD][overflow] before', {

        clientWidth: toolsRow?.clientWidth,

        scrollWidth: toolsRow?.scrollWidth,

        childCount: toolsRow?.children?.length,

        moreBoxChildren: moreBox?.children?.length

      });



      while (moreBox.firstChild) toolsRow.appendChild(moreBox.firstChild);



      if (toolsRow.scrollWidth <= toolsRow.clientWidth) {

        moreBtn.style.display = 'none';

        moreBox.classList.remove('open');

        console.debug('[ALIBOARD][overflow] after', {

          clientWidth: toolsRow?.clientWidth,

          scrollWidth: toolsRow?.scrollWidth,

          childCount: toolsRow?.children?.length,

          moreBoxChildren: moreBox?.children?.length,

          moreBtnDisplay: moreBtn?.style?.display

        });

        return;

      }



      const essentialSel = [

        '[data-tool="select"]',

        '[data-tool="pen"]',

        '[data-tool="line"]',

        '[data-tool="eraser"]',

        '[data-tool="text"]',

        '[data-tool="crop"]'

      ].join(',');



      const children = [...toolsRow.children];

      const candidates = children

        .filter(el => !el.matches(essentialSel) && el !== moreBtn);



      for (let i = candidates.length - 1; i >= 0 && toolsRow.scrollWidth > toolsRow.clientWidth; i--){

        const el = candidates[i];

        moreBox.appendChild(el);

      }



      moreBtn.style.display = moreBox.children.length ? 'inline-flex' : 'none';



      console.debug('[ALIBOARD][overflow] after', {

        clientWidth: toolsRow?.clientWidth,

        scrollWidth: toolsRow?.scrollWidth,

        childCount: toolsRow?.children?.length,

        moreBoxChildren: moreBox?.children?.length,

        moreBtnDisplay: moreBtn?.style?.display

      });



      console.debug('[ALIBOARD][overflow] rebalanced', {

        clientWidth: toolsRow.clientWidth,

        scrollWidth: toolsRow.scrollWidth,

        moved: moreBox.children.length

      });

    }



    // 5) Toggling panelu overflow

    moreBtn.addEventListener('pointerdown', (e)=>{

      e.preventDefault();

      e.stopPropagation();

      moreBox.classList.toggle('open');

    });

    document.addEventListener('pointerdown', (e)=>{

      if(!moreBox.contains(e.target) && e.target !== moreBtn){

        moreBox.classList.remove('open');

      }

    });



    // 6) Rebalans po za?adowaniu i na resize

    window.addEventListener('load', rebalanceTools, { once: true });

    window.addEventListener('resize', rebalanceTools);



    // 7) Obs?uga ?tap? na elementach przeniesionych do overflow:

    //    delegujemy klikni?cia, ?eby zachowa?y si? identycznie jak w g??wnym rz?dzie

    moreBox.addEventListener('pointerdown', (e)=>{

      const btn = e.target.closest('button, label');

      if(!btn) return;

      const toolTarget = btn.closest('[data-tool]');

      if(toolTarget){

        e.preventDefault();

        e.stopPropagation();

        const toolName = toolTarget.getAttribute('data-tool');

        setTool(toolName);

        if(toolName===TOOLS.FIGURE){

          figureBtn = toolTarget;

          toggleFigurePalette(true);

        }else{

          toggleFigurePalette(false);

        }

      }

      setTimeout(()=> moreBox.classList.remove('open'), 0);

    });



    // 8) Publiczny hook: gdyby co? dynamicznie doda?o narz?dzie ? spr?buj zbalansowa? ponownie

    const ro = new ResizeObserver(rebalanceTools);

    ro.observe(toolsRow);

    setTimeout(rebalanceTools, 250);

    setTimeout(rebalanceTools, 800);



  })();

  // [CODEX:END OVERFLOW_MENU]



  // Aliboard Chat Module – logika czatu

  (function initAliboardChatModule(){

    const bubble = document.getElementById('aliboard-chat-bubble');

    const panel = document.getElementById('aliboard-chat-panel');

    const closeBtn = document.getElementById('aliboard-chat-close');

    const form = document.getElementById('aliboard-chat-form');

    const input = document.getElementById('aliboard-chat-input');

    const messagesEl = document.getElementById('aliboard-chat-messages');

    const pingBtn = document.getElementById('aliboard-chat-ping');

    const micBtn = document.getElementById('aliboard-chat-mic');

    const callBtn = document.getElementById('aliboard-chat-call');

    const joinCallBtn = document.getElementById('aliboard-call-join-btn');

    const hangupBtn = document.getElementById('aliboard-call-hangup-btn');

    const modeSelect = document.getElementById('aliboard-call-mode');

    const bubbleRoot = bubble ? bubble.closest('.aliboard-chat-root') : null;



    if(!bubble || !panel || !form || !input || !messagesEl){

      return;

    }



    if(modeSelect){

      if((window.ALIBOARD_USER_ROLE || '') !== 'teacher'){

        modeSelect.style.display = 'none';

      }

      window.ALIBOARD_CALL_MODE = parseInt(modeSelect.value, 10) || window.ALIBOARD_CALL_MODE || 1;

      modeSelect.addEventListener('change', ()=>{

        window.ALIBOARD_CALL_MODE = parseInt(modeSelect.value, 10) || 1;

        if(window.AliboardRealtime && typeof window.AliboardRealtime.send === 'function'){

          window.AliboardRealtime.send({

            type:'audio_mode',

            mode: window.ALIBOARD_CALL_MODE,

            teacher_id: window.ALIBOARD_USER_ID,

            room_id: window.ALIBOARD_ROOM_ID,

          });

        }

      });

    }else{

      window.ALIBOARD_CALL_MODE = window.ALIBOARD_CALL_MODE || 1;

    }



    // Na desktopie podnie? dymek czatu, by nie nachodzi? na room_id

    if(bubbleRoot && window.matchMedia('(pointer:fine)').matches){

      bubbleRoot.classList.add('desktop-offset');

    }



    window.aliboardChat = window.aliboardChat || {};

    window.aliboardChat.sendToServer = window.aliboardChat.sendToServer || null;

    window.aliboardChat.sendPing = window.aliboardChat.sendPing || null;

    window.aliboardChat.toggleMic = window.aliboardChat.toggleMic || null;

    window.aliboardChat.sendCallSignal = window.aliboardChat.sendCallSignal || null;



    const CHAT_OPEN_KEY = 'aliboard_chat_is_open';

    let isMicMuted = false;
    const remoteMicStates = new Map();
    const chatSubtitleEl = panel.querySelector('.aliboard-chat-title-sub');
    const defaultSubtitleText = chatSubtitleEl ? chatSubtitleEl.textContent : '';

    let incomingCallBanner = null;

    let ringIntervalId = null;

    let isPanelOpen = false;

    let unreadCount = 0;

    let unreadBadgeEl = null;

    function getLocalAudioStream(){
      return window.__ALIBOARD_LOCAL_STREAM || null;
    }

    function updateMuteButtonUI(muted) {
      if(!micBtn) return;
      micBtn.classList.toggle('is-muted', muted);
      micBtn.title = muted ? "Mikrofon wyciszony" : "Mikrofon włączony";
    }

    function sendMicMuteState(muted) {
      if (!window.AliboardRealtime || typeof window.AliboardRealtime.sendChatMicState !== "function") return;
      window.AliboardRealtime.sendChatMicState(muted);
    }

    function setMicMuted(muted) {
      isMicMuted = !!muted;
      const stream = getLocalAudioStream();
      if(stream && stream.getAudioTracks){
        stream.getAudioTracks().forEach(track => {
          track.enabled = !isMicMuted;
        });
      }
      updateMuteButtonUI(isMicMuted);
      sendMicMuteState(isMicMuted);
    }

    function updateRemoteMicIndicator(userId, muted) {
      if(!chatSubtitleEl) return;
      if(userId === undefined || userId === null) return;
      const myIdRaw = window.ALIBOARD_USER_ID;
      if(myIdRaw !== undefined && myIdRaw !== null && Number(userId) === Number(myIdRaw)){
        return;
      }
      remoteMicStates.set(userId, !!muted);
      const anyMuted = Array.from(remoteMicStates.values()).some(Boolean);
      chatSubtitleEl.textContent = anyMuted ? "Rozmówca wyciszony" : (defaultSubtitleText || chatSubtitleEl.textContent);
      chatSubtitleEl.title = anyMuted ? "Rozmówca ma wyciszony mikrofon" : "";
    }

    function ensureUnreadBadge(){

      if(!bubble) return;

      if(unreadBadgeEl) return;

      unreadBadgeEl = document.createElement('span');

      unreadBadgeEl.className = 'aliboard-chat-badge aliboard-chat-badge-hidden';

      unreadBadgeEl.textContent = '';

      bubble.appendChild(unreadBadgeEl);

    }



    function playCallBeepOnce(){

      try{

        const ctx = new (window.AudioContext || window.webkitAudioContext)();

        const osc = ctx.createOscillator();

        const gain = ctx.createGain();

        osc.type = 'sine';

        osc.frequency.value = 880;

        gain.gain.setValueAtTime(0.15, ctx.currentTime);

        osc.connect(gain);

        gain.connect(ctx.destination);

        osc.start();

        osc.stop(ctx.currentTime + 0.25);

      }catch(_){

        // AudioContext niedostepny - ignorujemy

      }

    }



    function startRingTone(){

      if(ringIntervalId !== null) return;

      playCallBeepOnce();

      ringIntervalId = window.setInterval(playCallBeepOnce, 1500);

    }



    function stopRingTone(){

      if(ringIntervalId !== null){

        window.clearInterval(ringIntervalId);

        ringIntervalId = null;

      }

    }



    function playMessageBeep(){

      try{

        const ctx = new (window.AudioContext || window.webkitAudioContext)();

        const osc = ctx.createOscillator();

        const gain = ctx.createGain();

        osc.type = 'triangle';

        osc.frequency.value = 600;

        gain.gain.setValueAtTime(0.1, ctx.currentTime);

        osc.connect(gain);

        gain.connect(ctx.destination);

        osc.start();

        osc.stop(ctx.currentTime + 0.15);

      }catch(_){

        // brak dzwieku - ignorujemy

      }

    }



    function showIncomingCallBanner(fromRole, fromId, mode){
      if(!panel) return;

      if(incomingCallBanner && incomingCallBanner.parentNode){

        incomingCallBanner.parentNode.removeChild(incomingCallBanner);

      }

      const banner = document.createElement('div');

      banner.className = 'aliboard-call-banner';

      banner.innerHTML = `

        <span>?? Połączenie głosowe z: <strong>${fromRole === 'teacher' ? 'Nauczyciel' : 'Uczeń'}</strong></span>

        <div class="aliboard-call-actions">

          <button class="aliboard-call-accept-btn" id="aliboard-accept-call-btn">Dołącz</button>

          <button class="aliboard-call-end-btn" id="aliboard-end-call-btn">Rozłącz</button>

        </div>

      `;
      panel.insertBefore(banner, panel.firstChild);
      incomingCallBanner = banner;
      lastRingFromId = (fromId !== undefined && fromId !== null) ? Number(fromId) : null;
      startRingTone();


      const acceptBtn = document.getElementById('aliboard-accept-call-btn');

      const endBtn = document.getElementById('aliboard-end-call-btn');



      if(acceptBtn){
        acceptBtn.addEventListener('click', ()=>{
          stopRingTone();
          if(window.aliboardVoice && typeof window.aliboardVoice.acceptIncomingCall === 'function'){
            window.aliboardVoice.acceptIncomingCall(fromId)
              .catch((err)=>{
                console.error('[AliboardVoice] acceptIncomingCall error', err);
                if(window.aliboardVoice && typeof window.aliboardVoice.hangupAll === 'function'){
                  window.aliboardVoice.hangupAll(false);
                }else if(window.aliboardVoice && typeof window.aliboardVoice.hangupCall === 'function'){
                  window.aliboardVoice.hangupCall(false);
                }
              });
          }
        });
      }


      if(endBtn){
        endBtn.addEventListener('click', ()=>{
          stopRingTone();
          handleHangupClick();
        });
      }
    }


    function setPanelOpen(isOpen){

      isPanelOpen = !!isOpen;

      if(isOpen){

        panel.classList.add('is-open');

        panel.setAttribute('aria-hidden', 'false');

        try{ localStorage.setItem(CHAT_OPEN_KEY, '1'); }catch(_){}

        setTimeout(()=> input.focus(), 20);

        unreadCount = 0;

        if(unreadBadgeEl){

          unreadBadgeEl.textContent = '';

          unreadBadgeEl.classList.add('aliboard-chat-badge-hidden');

        }

      }else{

        panel.classList.remove('is-open');

        panel.setAttribute('aria-hidden', 'true');

        try{ localStorage.setItem(CHAT_OPEN_KEY, '0'); }catch(_){}

      }

    }



    try{

      if(localStorage.getItem(CHAT_OPEN_KEY)==='1'){

        setPanelOpen(true);

      }

    }catch(_){}



    bubble.addEventListener('click', ()=>{

      const shouldOpen = !panel.classList.contains('is-open');

      setPanelOpen(shouldOpen);

    });

    if(closeBtn){

      closeBtn.addEventListener('click', ()=> setPanelOpen(false));

    }



    function appendMessage(opts){

      if(!opts || !opts.text) return;

      const author = opts.author === 'other' ? 'other' : 'me';

      const label = opts.label || (author === 'me' ? 'Ty' : 'Gość');



      const row = document.createElement('div');

      row.className = `aliboard-chat-row ${author === 'me' ? 'mine' : 'theirs'}`;



      const authorEl = document.createElement('div');

      authorEl.className = 'aliboard-chat-author';

      authorEl.textContent = label;

      row.appendChild(authorEl);



      const msgEl = document.createElement('div');

      msgEl.className = `aliboard-chat-message ${author}`;

      msgEl.textContent = opts.text.toString();

      row.appendChild(msgEl);



      if(opts.timeString){

        const meta = document.createElement('span');

        meta.className = 'aliboard-chat-meta';

        meta.textContent = opts.timeString;

        row.appendChild(meta);

      }



      messagesEl.appendChild(row);

      messagesEl.scrollTop = messagesEl.scrollHeight;

    }



    function getTimeString(){

      try{

        const d = new Date();

        return d.toLocaleTimeString(undefined, { hour:'2-digit', minute:'2-digit' });

      }catch(_){

        return '';

      }

    }



    function sendChatMessage(text) {

      if (!text.trim()) return;

      const trimmed = text.trim().slice(0, 500);



      // Ping tylko wysyłamy na serwer, bez lokalnego dopisywania

      if (window.aliboardChat && typeof window.aliboardChat.sendToServer === "function") {

        window.aliboardChat.sendToServer(trimmed);

      }



      input.value = "";

    }



    form.addEventListener('submit', (e)=>{

      e.preventDefault();

      sendChatMessage(input.value);

    });



    if(pingBtn){

      pingBtn.addEventListener('click', ()=>{

        appendMessage({

          text: '?? Wysłałeś zaczepienie (ping).',

          author: 'me',

          timeString: getTimeString()

        });

        if(typeof window.aliboardChat.sendPing === 'function'){

          window.aliboardChat.sendPing();

        }

      });

    }



        if(micBtn){
      if(!micBtn.dataset.micClickAttached){
        micBtn.dataset.micClickAttached = '1';
        micBtn.addEventListener('click', ()=>{
          setMicMuted(!isMicMuted);
        });
        updateMuteButtonUI(isMicMuted);
      }
    }



    window.aliboardChat.onServerMessage = function (text, authorId, authorName) {

      const myIdRaw = window.ALIBOARD_USER_ID;

      const myId = (myIdRaw !== null && myIdRaw !== undefined) ? Number(myIdRaw) : null;

      const serverId = (authorId !== null && authorId !== undefined) ? Number(authorId) : null;

      const isMe = (myId !== null && serverId !== null && serverId === myId);

      const label = isMe

        ? 'Ty'

        : (authorName && authorName.toString().trim()) ||

          (serverId !== null ? `Użytkownik #${serverId}` : 'Gość');



      appendMessage({

        text: text,

        author: isMe ? "me" : "other",

        label: label,

        timeString: getTimeString(),

      });



      if(!isPanelOpen && !isMe){

        ensureUnreadBadge();

        unreadCount += 1;

        unreadBadgeEl.textContent = unreadCount.toString();

        unreadBadgeEl.classList.remove('aliboard-chat-badge-hidden');

        playMessageBeep();

      }

    };



    window.aliboardChat.onCallSignal = function(payload){

      if(!payload) return;

      const fromId = payload.from_id;

      const fromRole = payload.from_role || 'unknown';

      const type = payload.type || null;

      const action = payload.action || (type === 'voice:ring' ? 'ring' : (type === 'voice:end' ? 'end' : null));

      const myId = window.ALIBOARD_USER_ID;



      if(payload.mode){

        window.ALIBOARD_CALL_MODE = Number(payload.mode) || window.ALIBOARD_CALL_MODE || 1;

      }



      if(fromId != null && myId != null && Number(fromId) === Number(myId)){

        return;

      }



      if(type === 'voice:busy'){

        appendMessage({

          text: 'Linia zajeta lub tryb nie pozwala na dolaczenie.',

          author: 'other',

          timeString: getTimeString(),

        });
        aliboardSetCallState(false);

        return;

      }



      if(action === 'ring'){

        setPanelOpen(true);

        showIncomingCallBanner(fromRole, fromId, payload.mode);

        return;

      }



      if(action === 'end' || type === 'voice:end'){

        stopRingTone();

        if(incomingCallBanner && incomingCallBanner.parentNode){

          incomingCallBanner.parentNode.removeChild(incomingCallBanner);

          incomingCallBanner = null;

        }

        if(window.aliboardVoice && typeof window.aliboardVoice.hangupAll === 'function'){

          window.aliboardVoice.hangupAll(false);

        }else if(window.aliboardVoice && typeof window.aliboardVoice.hangupCall === 'function'){

          window.aliboardVoice.hangupCall(false);

        }

        aliboardSetCallState(false);

        appendMessage({

          text: '?? Połączenie zostało zakończone',

          author: 'other',

          timeString: getTimeString(),

        });

      }

    };



    // WebRTC Voice Module (multi-peer)

    window.aliboardVoice = window.aliboardVoice || {};

    window.aliboardVoice.sendSignal = window.aliboardVoice.sendSignal || function(){};

    const aliboardCallState = {
      inCall: false,
    };

    function aliboardUpdateCallButtons() {
      const joinBtn = document.getElementById("aliboard-call-join-btn") || document.getElementById("aliboard-accept-call-btn");
      const hangupBtn = document.getElementById("aliboard-call-hangup-btn") || document.getElementById("aliboard-end-call-btn");
      if (aliboardCallState.inCall) {
        if (joinBtn) joinBtn.classList.add("hidden");
        if (hangupBtn) hangupBtn.classList.remove("hidden");
      } else {
        if (joinBtn) joinBtn.classList.add("hidden");
        if (hangupBtn) hangupBtn.classList.add("hidden");
      }
    }

    function aliboardSetCallState(inCall) {
      aliboardCallState.inCall = !!inCall;
      aliboardUpdateCallButtons();
    }

    function handleJoinCallClick() {
      setPanelOpen(true);
      aliboardSetCallState(true);
      appendMessage({
        text: '?? Próba rozpoczęcia rozmowy głosowej…',
        author: 'me',
        timeString: getTimeString(),
      });
      if(window.aliboardChat && typeof window.aliboardChat.sendCallSignal === 'function'){
        window.aliboardChat.sendCallSignal('ring');
      }
    }

    function handleHangupClick() {
      if(window.aliboardVoice && typeof window.aliboardVoice.hangupAll === 'function'){
        window.aliboardVoice.hangupAll();
      }else if(window.aliboardVoice && typeof window.aliboardVoice.hangupCall === 'function'){
        window.aliboardVoice.hangupCall();
      }
      aliboardSetCallState(false);
    }



    function isSafariBrowser() {
      const ua = navigator.userAgent || "";
      const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
      return isSafari;
    }

      const rtcConfig = {
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
      };
      const voicePeers = new Map();
      const pendingIce = new Map(); // peerId -> RTCIceCandidate[]
      const remoteAudio = document.getElementById('aliboard-remote-audio');
      if(remoteAudio){
        remoteAudio.autoplay = true;
        remoteAudio.playsInline = true;
        remoteAudio.controls = false;
      }
      let lastRingFromId = null;

      function getPeerKey(peerId){
        return peerId !== undefined && peerId !== null ? peerId : 'legacy';
      }

      function buildAudioEl(peerId){
        const elId = `aliboard-voice-${peerId}`;
        let au = document.getElementById(elId);
        if(!au){
        au = document.createElement('audio');

        au.id = elId;

        au.autoplay = true;

        au.playsInline = true;
        au.controls = false;

        au.hidden = true;

        document.body.appendChild(au);

      }

      return au;

    }



    async function ensureLocalStream(){

      if(window.__ALIBOARD_LOCAL_STREAM) return window.__ALIBOARD_LOCAL_STREAM;

      const stream = await navigator.mediaDevices.getUserMedia({

        audio: { echoCancellation:true, noiseSuppression:true },

        video: false

      });

      if(!stream.getAudioTracks || stream.getAudioTracks().length === 0){

        console.warn("[Voice] No audio tracks in stream – Safari glitch?");

      }

      window.__ALIBOARD_LOCAL_STREAM = stream;

      return stream;

      }

      function destroyPeer(peerId){
        const key = getPeerKey(peerId);
        const pc = voicePeers.get(key);
        if(pc){
          pc.ontrack = null;
          pc.onicecandidate = null;
          try{ pc.close(); }catch(_){ }
          voicePeers.delete(key);
        }
        pendingIce.delete(key);
        const el = document.getElementById(`aliboard-voice-${peerId}`);
        if(el){
          el.srcObject = null;
          el.remove();
        }
    }



    async function addLocalTracks(pc){

      const stream = await ensureLocalStream();
      setMicMuted(isMicMuted);

      stream.getTracks().forEach((track)=> pc.addTrack(track, stream));

    }



      function createPeer(peerId){
        const key = getPeerKey(peerId);
        let pc = voicePeers.get(key);
        if(pc) return pc;
        pc = new RTCPeerConnection(rtcConfig);
        pc.onicecandidate = (event)=>{
          if(event.candidate){
          if(window.AliboardRealtime && typeof window.AliboardRealtime.voiceIce === 'function' && peerId !== undefined && peerId !== null){

            window.AliboardRealtime.voiceIce(peerId, event.candidate);

          }else{

            window.aliboardVoice.sendSignal({

              type: 'webrtc_ice_candidate',

              candidate: event.candidate,

            });

          }

        }

      };

      pc.ontrack = (event)=>{

        const au = (peerId !== undefined && peerId !== null) ? buildAudioEl(peerId) : remoteAudio;

        if(au){

          au.srcObject = event.streams[0];

        }

      };

      pc.onconnectionstatechange = ()=>{

        if(['failed','disconnected','closed'].includes(pc.connectionState)){

          destroyPeer(key);

        }

        };
        voicePeers.set(key, pc);
        return pc;
      }

      function safeAddIceCandidate(peerId, candidateObj){
        const key = getPeerKey(peerId);
        const pc = voicePeers.get(key);
        if(!pc){
          console.warn("[AliboardVoice] ICE dla nieznanego peerId", peerId);
          return;
        }
        const candidate = new RTCIceCandidate(candidateObj);

        if(pc.remoteDescription && pc.remoteDescription.type){
          pc.addIceCandidate(candidate).catch((err)=>{
            console.error("[AliboardVoice] addIceCandidate error", err);
          });
        }else{
          if(!pendingIce.has(key)){
            pendingIce.set(key, []);
          }
          pendingIce.get(key).push(candidate);
          console.debug("[AliboardVoice] ICE queued (no remoteDescription yet)", peerId);
        }
      }

      async function flushPendingIce(peerId, pc){
        const key = getPeerKey(peerId);
        const queued = pendingIce.get(key);
        if(!queued || !queued.length) return;
        console.debug("[AliboardVoice] flushing queued ICE for", peerId, queued.length);
        for(const cand of queued){
          try{
            await pc.addIceCandidate(cand);
          }catch(err){
            console.error("[AliboardVoice] flush addIceCandidate error", err);
          }
        }
        pendingIce.delete(key);
      }

      function shouldHandleToId(toId){
        if(toId === undefined || toId === null) return true;
        if(window.ALIBOARD_USER_ID === undefined || window.ALIBOARD_USER_ID === null) return false;
        return Number(toId) === Number(window.ALIBOARD_USER_ID);
      }


    window.aliboardVoice.startCallTo = async function(peerId){

      if(peerId === undefined || peerId === null) return;

      const stream = await ensureLocalStream();
      setMicMuted(isMicMuted);

      const pc = createPeer(peerId);

      stream.getTracks().forEach((track)=> pc.addTrack(track, stream));

      const offer = await pc.createOffer();

      await pc.setLocalDescription(offer);
      aliboardSetCallState(true);

      if(window.AliboardRealtime && typeof window.AliboardRealtime.voiceOffer === 'function'){

        window.AliboardRealtime.voiceOffer(peerId, pc.localDescription);

      }else{

        window.aliboardVoice.sendSignal({

          type: 'webrtc_offer',

          sdp: pc.localDescription,

        });

      }

    };



    window.aliboardVoice.onOffer = async function(data){

      const fromId = data.from_id;

      const toId = data.to_id;

      if(fromId != null && window.ALIBOARD_USER_ID != null && Number(fromId) === Number(window.ALIBOARD_USER_ID)){

        return;

      }

      if(!shouldHandleToId(toId)) return;

        const pc = createPeer(fromId);
        const desc = new RTCSessionDescription(data.sdp);

        if(isSafariBrowser()){
          await pc.setRemoteDescription(desc);
          await flushPendingIce(fromId, pc);
          const stream = await ensureLocalStream();
          setMicMuted(isMicMuted);
          stream.getTracks().forEach((track)=> pc.addTrack(track, stream));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
        }else{
          const stream = await ensureLocalStream();
          setMicMuted(isMicMuted);
          stream.getTracks().forEach((track)=> pc.addTrack(track, stream));
          await pc.setRemoteDescription(desc);
          await flushPendingIce(fromId, pc);
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
        }
        if(window.AliboardRealtime && typeof window.AliboardRealtime.voiceAnswer === 'function'){
          window.AliboardRealtime.voiceAnswer(fromId, pc.localDescription);
        }else{
        window.aliboardVoice.sendSignal({

          type: 'webrtc_answer',

          sdp: pc.localDescription,

        });

      }
        aliboardSetCallState(true);

    };



    window.aliboardVoice.onAnswer = async function(data){

      const fromId = data.from_id;

      const toId = data.to_id;

      if(fromId != null && window.ALIBOARD_USER_ID != null && Number(fromId) === Number(window.ALIBOARD_USER_ID)){

        return;

      }

      if(!shouldHandleToId(toId)) return;

        const pc = voicePeers.get(fromId != null ? fromId : 'legacy');
        if(!pc) return;
        try{
          const desc = new RTCSessionDescription(data.sdp);
          await pc.setRemoteDescription(desc);
          await flushPendingIce(fromId, pc);
          aliboardSetCallState(true);
        }catch(err){
          console.error('[AliboardVoice] setRemoteDescription error', err);
          window.aliboardVoice.hangupAll(false);
        }
      };


    window.aliboardVoice.onIceCandidate = async function(data){

      const fromId = data.from_id;

      const toId = data.to_id;

        if(fromId != null && window.ALIBOARD_USER_ID != null && Number(fromId) === Number(window.ALIBOARD_USER_ID)){
          return;
        }
        if(!shouldHandleToId(toId)) return;
        safeAddIceCandidate(fromId != null ? fromId : 'legacy', data.candidate);
      };

      window.aliboardVoice.hangupAll = function(sendSignal = true){
        stopRingTone();
        Array.from(voicePeers.keys()).forEach((pid)=> destroyPeer(pid));
      const ls = window.__ALIBOARD_LOCAL_STREAM;

      if(ls){

        ls.getTracks().forEach((t)=> t.stop());

        window.__ALIBOARD_LOCAL_STREAM = null;

      }

      if(remoteAudio){

        remoteAudio.srcObject = null;

      }

      if(incomingCallBanner && incomingCallBanner.parentNode){

        incomingCallBanner.parentNode.removeChild(incomingCallBanner);

        incomingCallBanner = null;

      }

      lastRingFromId = null;
      aliboardSetCallState(false);

      if(sendSignal){

        if(window.AliboardRealtime && typeof window.AliboardRealtime.send === 'function'){

          window.AliboardRealtime.send({

            type:'voice:end',

            room_id: window.ALIBOARD_ROOM_ID,

            from_id: window.ALIBOARD_USER_ID,

          });

        }

        if(window.aliboardChat && typeof window.aliboardChat.sendCallSignal === 'function'){

          window.aliboardChat.sendCallSignal('end');

        }

      }

    };



    window.aliboardVoice.hangupCall = window.aliboardVoice.hangupAll;

    window.aliboardVoice.acceptIncomingCall = async function(peerId){

      const target = peerId !== undefined && peerId !== null ? peerId : lastRingFromId;

      if(target === undefined || target === null) return;

      const audioEl = buildAudioEl(target);
      try{
        const playPromise = audioEl.play();
        if(playPromise && typeof playPromise.then === "function"){
          playPromise.catch((e)=>{
            console.warn("[Voice] Safari blocked autoplay", e);
          });
        }
      }catch(e){
        console.warn("[Voice] play() error", e);
      }

      await window.aliboardVoice.startCallTo(target);

    };

    window.aliboardVoice.startOutgoingCall = window.aliboardVoice.startCallTo;

    document.addEventListener("DOMContentLoaded", () => {
      if(callBtn){
        callBtn.addEventListener('click', ()=>{
          handleJoinCallClick();
        });
      }

      if(joinCallBtn){
        joinCallBtn.addEventListener('click', ()=>{
          handleJoinCallClick();
        });
      }

      if(hangupBtn){
        hangupBtn.addEventListener('click', ()=>{
          handleHangupClick();
        });
      }

      aliboardSetCallState(false);
    });



    function wireRealtimeBridge(){

      const tryAttach = ()=>{

        const realtime = window.AliboardRealtime;

        if(!realtime){

          setTimeout(tryAttach, 600);

          return;

        }

        if(typeof realtime.sendChatMessage === 'function'){

          window.aliboardChat.sendToServer = (text)=> realtime.sendChatMessage(text);

        }

        if(typeof realtime.sendChatPing === 'function'){

          window.aliboardChat.sendPing = ()=> realtime.sendChatPing();

        }

        if(typeof realtime.sendCallSignal === 'function'){

          window.aliboardChat.sendCallSignal = (action)=> realtime.sendCallSignal(action);

        }

        if(typeof realtime.sendChatMicState === 'function'){

          window.aliboardChat.toggleMic = (muted)=> setMicMuted(muted);

        }

      };

      tryAttach();

    }

    function attachMicStateListener(){
      const rt = window.AliboardRealtime;
      if(!rt || typeof rt.on !== 'function'){
        setTimeout(attachMicStateListener, 600);
        return;
      }
      if(attachMicStateListener._attached) return;
      rt.on("chat_mic_state", ({ user_id, muted })=>{
        updateRemoteMicIndicator(user_id, muted);
      });
      attachMicStateListener._attached = true;
    }


    wireRealtimeBridge();
    attachMicStateListener();


    (function enableChatBubbleDrag(){

      const bubble = document.getElementById('aliboard-chat-bubble');

      if(!bubble) return;



      let dragging = false, startX=0, startY=0, startLeft=0, startTop=0;



    bubble.style.position = 'fixed';

    bubble.style.right = bubble.style.right || '16px';

    bubble.style.bottom = bubble.style.bottom || '16px';



    const onMove = (e)=>{

      if(!dragging) return;

      const x = e.clientX ?? (e.touches && e.touches[0]?.clientX);

      const y = e.clientY ?? (e.touches && e.touches[0]?.clientY);

        if(x==null || y==null) return;

        const dx = x - startX;

        const dy = y - startY;

        bubble.style.right = 'auto';

        bubble.style.bottom = 'auto';

        bubble.style.left = `${startLeft + dx}px`;

        bubble.style.top = `${startTop + dy}px`;

      };



      const onUp = ()=>{

        dragging = false;

        window.removeEventListener('pointermove', onMove);

        window.removeEventListener('pointerup', onUp);

      };



      bubble.addEventListener('pointerdown', (e)=>{

        e.preventDefault();

        dragging = true;

        startX = e.clientX;

        startY = e.clientY;

        const rect = bubble.getBoundingClientRect();

        startLeft = rect.left;

        startTop = rect.top;

        window.addEventListener('pointermove', onMove);

        window.addEventListener('pointerup', onUp);

      });

    })();

  })();



    // PODPINAMY SIĘ DO ALIBOARD REALTIME (jeśli dostępny) – retry aż do skutku

  (function attachCursorListener(){

    const rt = window.AliboardRealtime;

    if(!rt || typeof rt.on !== 'function'){

      setTimeout(attachCursorListener, 600);

      return;

    }

    if (attachCursorListener._attached) return;

    rt.on("cursor", function(cursor){

      try{

        if (cursor && cursor.id === rt.clientId) {

          return;

        }

        upsertRemoteCursor(cursor);

      }catch(err){

        console.error("[Aliboard][cursor] błąd przy nakładaniu zdalnego kursora", err);

      }

    });

    attachCursorListener._attached = true;

  })();



  // START

  (function startAliboard(){

    if (PAGES.length === 0) {

      createPage(false);

    }

    syncAllPagesFromModel();

    setTool(TOOLS.SELECT);

  })();

})();



/* === ALIBOARD: pokazuj przycisk wielko?ci czcionki tylko przy narz?dziu Tekst === */

const textFontBtn = document.getElementById("textFontBtn");



function updateFontButtonVisibility(activeTool){

    if(activeTool === "text"){

        textFontBtn.classList.add("is-visible");

    } else {

        textFontBtn.classList.remove("is-visible");

    }

}



document.querySelectorAll('#tools .btn[data-tool]').forEach(btn=>{

    btn.addEventListener('click', ()=>{

        const tool = btn.getAttribute('data-tool');

        updateFontButtonVisibility(tool);

    });

});

</script>

<script>

  (function(){

    const root = document.getElementById('aliboard-root');

    window.ALIBOARD_USER_ID = Number(root.dataset.userId);

    window.ALIBOARD_USER_ROLE = root.dataset.userRole || 'unknown';

  })();

</script>

<script>

  (function(){

    let roomId = window.ALIBOARD_ROOM_ID;

    if(!roomId){

      const root = document.getElementById('aliboard-root') || document.body;

      roomId = (root && root.dataset.roomId) || "{{ room_id|default:'local-test' }}";

      window.ALIBOARD_ROOM_ID = roomId;

    }

    window.ALIBOARD_CONFIG = {

      roomId,

      wsBase: "{% if request.is_secure %}wss{% else %}ws{% endif %}://{{ request.get_host }}/ws/aliboard/"

    };

  })();

</script>

<script src="{% static 'panel/js/aliboard_realtime.js' %}"></script>

</body>

</html>













































