{% load static %}
<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aliboard 2.1 ‚Äî PolubiszTo.pl (test)</title>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>
<style>
  :root{
    --brand:#0b74ff; --ink:#0b1320; --muted:#5b6777; --line:#e6edff;
    --card:#fff; --bg:#f7f9fe; --radius:16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{
    position:sticky; top:0; z-index:10; background:#fff; border-bottom:1px solid var(--line);
    display:flex; align-items:stretch; gap:16px; padding:10px 12px;
  }
  /* lewa kolumna: brand nad narzƒôdziami */
  .left{
    display:flex; flex-direction:column; gap:8px; min-width:240px;
  }
  .brand{display:flex;align-items:center;gap:10px}
  .brand .mark{width:36px;height:36px;border-radius:10px;background:var(--brand);
    display:grid;place-items:center;color:#fff;flex:0 0 auto}
  .state{font-size:12px;color:var(--muted)}
  .toolrow{display:flex;gap:8px;flex-wrap:wrap}
  .btn,.seg{border:1px solid var(--line);background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer;font-weight:700}
  .seg{display:inline-flex;gap:6px}
  .btn.primary{background:var(--brand);color:#fff;border-color:transparent}
  .btn.is-active{ outline:2px solid var(--brand); outline-offset:2px }
  .wrap{height:calc(100% - 64px)}
  .stage{
    position:relative; height:100%; width:100%; overflow:hidden; background:#fff;
    border-top:1px solid var(--line);
  }
  canvas{
    position:absolute; inset:0; width:100%; height:100%;
    touch-action:none;
  }
  #grid{pointer-events:none}
  #overlay{pointer-events:none}

  /* PRAWY PRZYCISK MENU + DROPDOWN */
  .right{margin-left:auto; display:flex; align-items:flex-start;}
  .menu-wrap{position:relative}
  .menu-btn{display:inline-flex; align-items:center; gap:8px}
  .dropdown{
    position:absolute; right:0; top:calc(100% + 8px); min-width:220px;
    background:#fff; border:1px solid var(--line); border-radius:12px;
    box-shadow:0 12px 40px rgba(11,116,255,.12); padding:8px; display:none;
  }
  .dropdown.open{display:block}
  .drop-group{padding:6px 6px}
  .drop-title{font-size:12px; color:var(--muted); margin:4px 6px 6px}
  .drop-item{width:100%; text-align:left; background:#fff; border:1px solid var(--line);
    border-radius:10px; padding:8px 10px; cursor:pointer; margin:4px 0}
  .drop-row{display:flex; gap:6px}
  .drop-item.primary{background:var(--brand);color:#fff;border-color:transparent}

  /* Tooltip pod przyciskiem (nie nad!) */
  .btn[title]{position:relative}
  .btn[title]:hover::after{
    content:attr(title); position:absolute; top:calc(100% + 6px); left:50%; transform:translateX(-50%);
    background:#111;color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;white-space:nowrap
  }

  .footer{
    position:fixed; right:12px; bottom:12px; display:flex; gap:8px; flex-wrap:wrap;
  }

  @media (max-width: 900px){
    .left{min-width:unset}
  }
</style>
</head>
<body>
<header>
  <!-- LEWA: brand nad narzƒôdziami -->
  <div class="left">
    <div class="brand">
      <div class="mark">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 7l9-4 9 4-9 4-9-4z" stroke="#fff"/>
        </svg>
      </div>
      <div>
        <div style="font-weight:800">Aliboard</div>
        <div class="state" id="state">Tryb: O≈Ç√≥wek ‚Ä¢ 3px ‚Ä¢ #0b74ff</div>
      </div>
    </div>

    <div class="toolrow" id="tools">
      <button class="btn" data-tool="pen"    title="O≈Ç√≥wek (P)">‚úèÔ∏è</button>
      <button class="btn" data-tool="line"   title="Linia (L)">Ôºè</button>
      <button class="btn" data-tool="eraser" title="Gumka ‚Äî usu≈Ñ kreskƒô (E)">ü©π</button>
      <button class="btn" data-tool="text"   title="Tekst (T)">T</button>

      <!-- Kolor i grubo≈õƒá zostajƒÖ na pasku (≈ºeby by≈Çy pod rƒôkƒÖ) -->
      <label class="btn" title="Kolor pisaka">
        üé® <input type="color" id="color" value="#0b74ff" style="width:28px;height:28px;border:0;padding:0;background:#fff;border-radius:8px;margin-left:6px">
      </label>
      <label class="btn" title="Grubo≈õƒá linii">
        ‚ÜïÔ∏è
        <select id="size" style="border:1px solid var(--line);border-radius:8px;padding:6px 8px;background:#fff;margin-left:6px">
          <option value="1">1px</option>
          <option value="3" selected>3px</option>
          <option value="5">5px</option>
          <option value="8">8px</option>
        </select>
      </label>

      <label class="btn" title="Wstaw obraz">
        üì∑ Obraz
        <input id="imgInput" type="file" accept="image/*" style="display:none">
      </label>

      <button class="btn" id="undo" title="Cofnij (Ctrl+Z)">‚Ü∂</button>
      <button class="btn" id="redo" title="Pon√≥w (Ctrl+Y)">‚Ü∑</button>
      <button class="btn" id="clear" title="Wyczy≈õƒá">üóëÔ∏è</button>
    </div>
  </div>

  <!-- PRAWA: MENU -->
  <div class="right">
    <div class="menu-wrap">
      <button class="btn primary menu-btn" id="menuBtn" aria-expanded="false" aria-controls="dropdown">
        ‚ò∞ Menu
      </button>
      <div class="dropdown" id="dropdown" role="menu" aria-labelledby="menuBtn">
        <div class="drop-group">
          <div class="drop-title">Zapisz</div>
          <div class="drop-row">
            <button class="drop-item primary" id="savePng">üíæ PNG</button>
            <button class="drop-item" id="saveJpg">üñºÔ∏è JPG</button>
            <button class="drop-item" id="savePdf">üìÑ PDF</button>
          </div>
        </div>
        <div class="drop-group">
          <div class="drop-title">Siatka</div>
          <div class="drop-row">
            <button class="drop-item" data-grid="0">Brak</button>
            <button class="drop-item" data-grid="16">Ma≈Ça</button>
            <button class="drop-item" data-grid="24">≈örednia</button>
            <button class="drop-item" data-grid="32">Du≈ºa</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="stage" id="stage">
    <canvas id="grid"></canvas>
    <canvas id="board"></canvas>
    <canvas id="overlay"></canvas>
  </div>
</div>

<div class="footer">
  <a href="{% url 'pokoj_testowy' %}" class="btn">‚Üê Powr√≥t do Pokoju Testowego</a>
  <span class="btn" id="roomInfo" title="Room ID z query string">room_id: ‚Äî</span>
</div>

<script>
(function(){
  /* ====== Opcjonalnie: URL zapisu na serwer ======
     window.SERVER_SAVE_URL = "/api/boards/save/";
  */

  // CANVASY
  const stage = document.getElementById('stage');
  const gridC = document.getElementById('grid');
  const drawC = document.getElementById('board');
  const ovlC  = document.getElementById('overlay');
  const g = gridC.getContext('2d');
  const ctx = drawC.getContext('2d');
  const ovl = ovlC.getContext('2d');
  const stateEl = document.getElementById('state');

  // Narzƒôdzia
  const TOOLS = { PEN:'pen', LINE:'line', ERASER:'eraser', TEXT:'text' };
  let tool = TOOLS.PEN;
  let color = '#0b74ff';
  let size  = 3;
  let gridSize = 0; // kontrolowane z menu
  // room_id z QS
  const qs = new URLSearchParams(location.search);
  const roomId = qs.get('room') || 'local-test';
  document.getElementById('roomInfo').textContent = 'room_id: ' + roomId;

  // MODEL WEKTOROWY ‚Äî ≈ºeby gumka mog≈Ça usuwaƒá ca≈Çe kreski
  /** stroke:
   *  { type:'pen', color, size, points:[{x,y},...] }
   *  { type:'line', color, size, a:{x,y}, b:{x,y} }
   *  { type:'text', color, size, x, y, text }
   *  { type:'image', x, y, w, h, src } (proste osadzanie)
   */
  let strokes = [];
  let images = [];

  // Historia
  const history = [];
  let redoStack = [];

  function pushHistory(){
    redoStack = [];
    try{
      history.push(JSON.stringify({strokes, images}));
      if(history.length>100) history.shift();
    }catch(_){}
  }
  function restoreHistoryState(json){
    try{
      const s = JSON.parse(json);
      strokes = s.strokes||[];
      images  = s.images||[];
      renderAll();
    }catch(_){}
  }

  // DPI-aware resize
  function resize(){
    const {clientWidth:w, clientHeight:h} = stage;
    const dpr = window.devicePixelRatio || 1;
    [gridC, drawC, ovlC].forEach(c=>{
      c.width = Math.floor(w*dpr);
      c.height = Math.floor(h*dpr);
      c.style.width = w+'px';
      c.style.height = h+'px';
      const c2d = c.getContext('2d');
      c2d.setTransform(dpr,0,0,dpr,0,0);
    });
    drawGrid();
    renderAll();
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // Siatka
  function drawGrid(){
    const dpr = window.devicePixelRatio || 1;
    const w = gridC.width / dpr;
    const h = gridC.height / dpr;
    g.clearRect(0,0,w,h);
    if(!gridSize) return;
    g.save();
    g.strokeStyle = '#e6edff';
    g.lineWidth = 1;
    for(let x=0; x<=w; x+=gridSize){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke(); }
    for(let y=0; y<=h; y+=gridSize){ g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke(); }
    g.restore();
  }

  // RENDER
  function renderAll(){
    const dpr = window.devicePixelRatio || 1;
    const w = drawC.width / dpr, h = drawC.height / dpr;
    ctx.clearRect(0,0,w,h);
    // images
    for(const im of images){
      const img = new Image();
      img.onload = ()=>{ ctx.drawImage(img, im.x, im.y, im.w, im.h); };
      img.src = im.src;
    }
    // strokes
    ctx.lineCap='round'; ctx.lineJoin='round';
    for(const s of strokes){
      if(s.type==='pen'){
        ctx.strokeStyle = s.color; ctx.lineWidth = s.size;
        ctx.beginPath();
        const pts = s.points;
        if(pts.length){ ctx.moveTo(pts[0].x, pts[0].y); }
        for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y); }
        ctx.stroke();
      }else if(s.type==='line'){
        ctx.strokeStyle = s.color; ctx.lineWidth = s.size;
        ctx.beginPath(); ctx.moveTo(s.a.x, s.a.y); ctx.lineTo(s.b.x, s.b.y); ctx.stroke();
      }else if(s.type==='text'){
        ctx.save();
        ctx.fillStyle = s.color;
        ctx.font = `${Math.max(14, s.size*6)}px ui-sans-serif, system-ui, Arial`;
        ctx.textBaseline = 'top';
        ctx.fillText(s.text, s.x, s.y);
        ctx.restore();
      }
    }
  }

  // STATUS
  function toolLabel(){ return tool===TOOLS.PEN?'O≈Ç√≥wek':tool===TOOLS.LINE?'Linia':tool===TOOLS.ERASER?'Gumka':'Tekst'; }
  function updateState(){ stateEl.textContent = `Tryb: ${toolLabel()} ‚Ä¢ ${size}px ‚Ä¢ ${color}`; }

  // Aktywny wyglƒÖd
  const toolButtons = Array.from(document.querySelectorAll('[data-tool]'));
  function setTool(next){
    tool = next; updateState();
    toolButtons.forEach(b=> b.classList.toggle('is-active', b.getAttribute('data-tool')===tool));
  }

  // Pickery
  const colorEl = document.getElementById('color');
  const sizeEl  = document.getElementById('size');
  colorEl.addEventListener('input', (e)=>{ color=e.target.value; updateState(); });
  sizeEl.addEventListener('change', (e)=>{ size=parseInt(e.target.value,10); updateState(); });
  color = colorEl.value; size = parseInt(sizeEl.value,10);
  setTool(TOOLS.PEN);

  // MENU (prawe)
  const menuBtn = document.getElementById('menuBtn');
  const dropdown = document.getElementById('dropdown');
  function toggleMenu(force){
    const open = typeof force==='boolean' ? force : !dropdown.classList.contains('open');
    dropdown.classList.toggle('open', open);
    menuBtn.setAttribute('aria-expanded', String(open));
  }
  menuBtn.addEventListener('click', ()=> toggleMenu());
  document.addEventListener('click', (e)=>{
    if(!dropdown.contains(e.target) && e.target!==menuBtn){ toggleMenu(false); }
  });

  // GRID w menu
  dropdown.querySelectorAll('[data-grid]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      gridSize = parseInt(btn.getAttribute('data-grid'),10)||0;
      drawGrid(); toggleMenu(false);
    });
  });

  // OBRAZ
  document.getElementById('imgInput').addEventListener('change', (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const img = new Image();
    img.onload = ()=>{
      pushHistory();
      const dpr = window.devicePixelRatio || 1;
      const W = drawC.width / dpr, H = drawC.height / dpr;
      const ratio = Math.min(W/img.width, H/img.height);
      const w = img.width * ratio, h = img.height * ratio;
      const x = (W - w)/2, y = (H - h)/2;
      images.push({type:'image', x, y, w, h, src: URL.createObjectURL(f)});
      renderAll();
    };
    img.src = URL.createObjectURL(f);
  });

  // UNDO / REDO / CLEAR
  document.getElementById('undo').addEventListener('click', ()=>{
    if(!history.length) return;
    const last = history.pop();
    redoStack.push(JSON.stringify({strokes, images}));
    restoreHistoryState(last);
  });
  document.getElementById('redo').addEventListener('click', ()=>{
    if(!redoStack.length) return;
    const next = redoStack.pop();
    history.push(JSON.stringify({strokes, images}));
    restoreHistoryState(next);
  });
  document.getElementById('clear').addEventListener('click', ()=>{
    pushHistory(); strokes = []; images = []; renderAll();
  });

  // ZAPIS PNG/JPG/PDF (menu)
  function exportDataURL(mime, quality){
    // zrenderuj siatkƒô + rysunki do tymczasowego canvasu w pe≈Çnym rozmiarze CSS
    const dpr = window.devicePixelRatio || 1;
    const W = drawC.width / dpr, H = drawC.height / dpr;
    const tmp = document.createElement('canvas'); tmp.width = W; tmp.height = H;
    const tctx = tmp.getContext('2d');
    // grid (opcjonalnie)
    if(gridSize){
      tctx.save(); tctx.strokeStyle='#e6edff'; tctx.lineWidth=1;
      for(let x=0;x<=W;x+=gridSize){ tctx.beginPath(); tctx.moveTo(x,0); tctx.lineTo(x,H); tctx.stroke(); }
      for(let y=0;y<=H;y+=gridSize){ tctx.beginPath(); tctx.moveTo(0,y); tctx.lineTo(W,y); tctx.stroke(); }
      tctx.restore();
    }
    // images
    const drawImagesThenStrokes = () => {
      let pending = images.length;
      if(pending===0){ drawStrokes(); return; }
      images.forEach(im=>{
        const imEl = new Image();
        imEl.onload = ()=>{ tctx.drawImage(imEl, im.x, im.y, im.w, im.h); if(--pending===0) drawStrokes(); };
        imEl.src = im.src;
      });
    };
    const drawStrokes = () => {
      tctx.lineCap='round'; tctx.lineJoin='round';
      for(const s of strokes){
        if(s.type==='pen'){
          tctx.strokeStyle=s.color; tctx.lineWidth=s.size;
          tctx.beginPath();
          const pts=s.points; if(pts.length){ tctx.moveTo(pts[0].x, pts[0].y); }
          for(let i=1;i<pts.length;i++){ tctx.lineTo(pts[i].x, pts[i].y); }
          tctx.stroke();
        }else if(s.type==='line'){
          tctx.strokeStyle=s.color; tctx.lineWidth=s.size;
          tctx.beginPath(); tctx.moveTo(s.a.x, s.a.y); tctx.lineTo(s.b.x, s.b.y); tctx.stroke();
        }else if(s.type==='text'){
          tctx.save(); tctx.fillStyle=s.color;
          tctx.font = `${Math.max(14, s.size*6)}px ui-sans-serif, system-ui, Arial`;
          tctx.textBaseline='top'; tctx.fillText(s.text, s.x, s.y); tctx.restore();
        }
      }
      const url = tmp.toDataURL(mime, quality);
      const a = document.createElement('a');
      const ext = mime==='image/jpeg'?'jpg':'png';
      a.href = url; a.download = `aliboard_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.${ext}`;
      a.click();
    };
    drawImagesThenStrokes();
  }

  document.getElementById('savePng').addEventListener('click', ()=>{ exportDataURL('image/png'); toggleMenu(false); });
  document.getElementById('saveJpg').addEventListener('click', ()=>{ exportDataURL('image/jpeg', 0.92); toggleMenu(false); });
  document.getElementById('savePdf').addEventListener('click', ()=>{
    const { jsPDF } = window.jspdf || {}; if(!jsPDF){ alert('PDF nieza≈Çadowany.'); return; }
    // eksportuj do PNG a potem do PDF
    const dpr = window.devicePixelRatio || 1;
    const W = drawC.width / dpr, H = drawC.height / dpr;
    const tmp = document.createElement('canvas'); tmp.width = W; tmp.height = H;
    const tctx = tmp.getContext('2d');
    // grid
    if(gridSize){
      tctx.save(); tctx.strokeStyle='#e6edff'; tctx.lineWidth=1;
      for(let x=0;x<=W;x+=gridSize){ tctx.beginPath(); tctx.moveTo(x,0); tctx.lineTo(x,H); tctx.stroke(); }
      for(let y=0;y<=H;y+=gridSize){ tctx.beginPath(); tctx.moveTo(0,y); tctx.lineTo(W,y); tctx.stroke(); }
      tctx.restore();
    }
    // images + strokes async
    let pending = images.length;
    const finish = ()=>{
      const dataUrl = tmp.toDataURL('image/png');
      const pdf = new jsPDF({orientation:'landscape', unit:'pt', format:'a4'});
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgEl = new Image();
      imgEl.onload = ()=>{
        const ratio = Math.min(pageW/imgEl.width, pageH/imgEl.height);
        const w = imgEl.width*ratio, h = imgEl.height*ratio;
        const x=(pageW-w)/2, y=(pageH-h)/2;
        pdf.addImage(dataUrl,'PNG',x,y,w,h);
        pdf.save(`aliboard_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.pdf`);
      };
      imgEl.src = dataUrl;
    };
    if(pending===0){ drawVec(); }
    images.forEach(im=>{
      const imEl = new Image();
      imEl.onload = ()=>{ tctx.drawImage(imEl, im.x, im.y, im.w, im.h); if(--pending===0) drawVec(); };
      imEl.src = im.src;
    });
    function drawVec(){
      tctx.lineCap='round'; tctx.lineJoin='round';
      for(const s of strokes){
        if(s.type==='pen'){
          tctx.strokeStyle=s.color; tctx.lineWidth=s.size;
          tctx.beginPath(); const pts=s.points;
          if(pts.length){ tctx.moveTo(pts[0].x, pts[0].y); }
          for(let i=1;i<pts.length;i++){ tctx.lineTo(pts[i].x, pts[i].y); }
          tctx.stroke();
        }else if(s.type==='line'){
          tctx.strokeStyle=s.color; tctx.lineWidth=s.size;
          tctx.beginPath(); tctx.moveTo(s.a.x, s.a.y); tctx.lineTo(s.b.x, s.b.y); tctx.stroke();
        }else if(s.type==='text'){
          tctx.save(); tctx.fillStyle=s.color;
          tctx.font = `${Math.max(14, s.size*6)}px ui-sans-serif, system-ui, Arial`;
          tctx.textBaseline='top'; tctx.fillText(s.text, s.x, s.y); tctx.restore();
        }
      }
      finish();
    }
    toggleMenu(false);
  });

  // RYSOWANIE
  let drawing=false; let startX=0, startY=0; let currentStroke=null;

  function begin(x,y){
    drawing=true; startX=x; startY=y;
    pushHistory();
    if(tool===TOOLS.PEN){
      currentStroke = {type:'pen', color, size, points:[{x,y}]};
      strokes.push(currentStroke);
    }else if(tool===TOOLS.LINE){
      currentStroke = {type:'line', color, size, a:{x,y}, b:{x,y}};
      // rysujemy podglƒÖd na overlay
      ovl.clearRect(0,0, ovlC.width, ovlC.height);
    }else if(tool===TOOLS.ERASER){
      // nic ‚Äî eraser dzia≈Ça na click/tap (hit-test)
      eraseAt({x,y});
      drawing=false; currentStroke=null;
      return;
    }else if(tool===TOOLS.TEXT){
      const txt = prompt('Wpisz tekst:');
      if(txt && txt.trim()){
        const s = {type:'text', color, size, x, y, text: txt.trim()};
        strokes.push(s); renderAll();
      }else{
        // anulowano ‚Äî cofamy snapshot pushHistory z begin()
        if(history.length){ const last=history.pop(); restoreHistoryState(last); }
      }
      drawing=false; currentStroke=null;
      return;
    }
    renderAll();
  }
  function move(x,y){
    if(!drawing) return;
    if(tool===TOOLS.PEN){
      currentStroke.points.push({x,y});
      renderAll();
    }else if(tool===TOOLS.LINE){
      currentStroke.b = {x,y};
      ovl.clearRect(0,0, ovlC.width, ovlC.height);
      ovl.lineCap='round'; ovl.lineJoin='round';
      ovl.strokeStyle=color; ovl.lineWidth=size;
      ovl.beginPath(); ovl.moveTo(startX,startY); ovl.lineTo(x,y); ovl.stroke();
    }
  }
  function end(x,y){
    if(!drawing) return;
    if(tool===TOOLS.LINE){
      ovl.clearRect(0,0, ovlC.width, ovlC.height);
      currentStroke.b = {x,y};
      strokes.push(currentStroke);
      renderAll();
    }
    drawing=false; currentStroke=null;
  }

  // GUMKA ‚Äî hit-test i usuniƒôcie ca≈Çej kreski/figury
  function eraseAt(p){
    // sprawdzamy od ko≈Ñca (ostatnie na wierzchu)
    const eps = Math.max(6, size*2); // tolerancja
    for(let i=strokes.length-1;i>=0;i--){
      const s = strokes[i];
      if(s.type==='pen'){
        if(hitPolyline(s.points, p, eps)){ strokes.splice(i,1); renderAll(); return; }
      }else if(s.type==='line'){
        if(distToSegment(p, s.a, s.b) <= eps){ strokes.splice(i,1); renderAll(); return; }
      }else if(s.type==='text'){
        // prosty bounding box tekstu
        const w = approxTextWidth(s); const h = Math.max(14, s.size*6);
        if(p.x>=s.x && p.x<=s.x+w && p.y>=s.y && p.y<=s.y+h){ strokes.splice(i,1); renderAll(); return; }
      }
    }
  }
  function approxTextWidth(s){
    // prosta aproksymacja szeroko≈õci (nie wymaga measureText)
    return (Math.max(14, s.size*6) * 0.6) * (s.text?.length || 0);
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function distToSegment(p, a, b){
    const A = {x:a.x, y:a.y}, B = {x:b.x, y:b.y}, P = {x:p.x, y:p.y};
    const ABx = B.x - A.x, ABy = B.y - A.y;
    const APx = P.x - A.x, APy = P.y - A.y;
    const ab2 = ABx*ABx + ABy*ABy;
    const t = ab2 ? Math.max(0, Math.min(1, (APx*ABx + APy*ABy)/ab2)) : 0;
    const proj = {x: A.x + t*ABx, y: A.y + t*ABy};
    return dist(P, proj);
  }
  function hitPolyline(pts, p, eps){
    for(let i=1;i<pts.length;i++){
      if(distToSegment(p, pts[i-1], pts[i]) <= eps) return true;
    }
    return false;
  }

  // Pozycja wska≈∫nika
  function getXY(e){
    const rect = drawC.getBoundingClientRect();
    if(e.touches && e.touches[0]){
      return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    }
    if(typeof e.clientX === 'number'){
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    if(e.changedTouches && e.changedTouches[0]){
      return { x: e.changedTouches[0].clientX - rect.left, y: e.changedTouches[0].clientY - rect.top };
    }
    return { x: startX, y: startY };
  }

  // Eventy
  drawC.addEventListener('mousedown', (e)=>{ const {x,y}=getXY(e); begin(x,y); });
  drawC.addEventListener('touchstart', (e)=>{ e.preventDefault(); const {x,y}=getXY(e); begin(x,y); }, {passive:false});

  window.addEventListener('mousemove', (e)=>{ if(!drawing) return; const {x,y}=getXY(e); move(x,y); }, {passive:true});
  window.addEventListener('touchmove',  (e)=>{ if(!drawing) return; e.preventDefault(); const {x,y}=getXY(e); move(x,y); }, {passive:false});

  window.addEventListener('mouseup',   (e)=>{ if(!drawing) return; const {x,y}=getXY(e); end(x,y); }, {passive:true});
  window.addEventListener('touchend',  (e)=>{ if(!drawing) return; e.preventDefault(); const {x,y}=getXY(e); end(x,y); }, {passive:false});
  window.addEventListener('mouseleave',(e)=>{ if(!drawing) return; const {x,y}=getXY(e); end(x,y); }, {passive:true});

  // Skr√≥ty
  document.getElementById('tools').addEventListener('click', (e)=>{
    const b = e.target.closest('[data-tool]'); if(!b) return; setTool(b.getAttribute('data-tool'));
  });
  window.addEventListener('keydown', (e)=>{
    if(e.key==='p'||e.key==='P') setTool(TOOLS.PEN);
    if(e.key==='l'||e.key==='L') setTool(TOOLS.LINE);
    if(e.key==='e'||e.key==='E') setTool(TOOLS.ERASER);
    if(e.key==='t'||e.key==='T') setTool(TOOLS.TEXT);
    if(e.ctrlKey && e.key==='z'){ document.getElementById('undo').click(); }
    if(e.ctrlKey && (e.key==='y' || (e.shiftKey && e.key==='Z'))){ document.getElementById('redo').click(); }
  });

  // AUTOSAVE lokalny
  const AUTOSAVE_KEY = 'aliboard_v21_state';
  function autosave(){
    try{ localStorage.setItem(AUTOSAVE_KEY, JSON.stringify({strokes, images})); }catch(_){}
  }
  setInterval(autosave, 30000);
  (function tryRestoreFromLocal(){
    try{
      const raw = localStorage.getItem(AUTOSAVE_KEY);
      if(!raw) return;
      const s = JSON.parse(raw);
      strokes = s.strokes||[]; images = s.images||[];
      renderAll();
    }catch(_){}
  })();

  updateState();
})();
</script>
</body>
</html>
